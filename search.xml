<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript学习笔记（3）数据类型-进阶</title>
    <url>//blog/note/code/JavaScript3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>对象允许存储键值集合，这很好。</p>
<p>但很多时候我们发现还需要 <strong>有序集合</strong>，里面的元素都是按顺序排列的。例如，我们可能需要存储一些列表，比如用户、商品以及 HTML 元素等。</p>
<p>这里使用对象就不是很方便了，因为<strong>对象不能提供能够管理元素顺序的方法</strong>。我们不能在已有的元素“之间”插入一个新的属性。这种场景下对象就不太适用了。</p>
<p>这时一个特殊的数据结构数组（<code>Array</code>）就派上用场了，它能<strong>存储有序的集合</strong>。</p>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><hr>
<p>创建一个空数组有两种语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br></pre></td></tr></table></figure>

<p>绝大多数情况下使用的都是<strong>第二种语法</strong>。我们可以在方括号中添加初始元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>数组元素从 0 开始编号。</p>
<p>我们可以通过方括号中的数字获取元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits[<span class="number">0</span>] ); <span class="comment">// Apple</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits[<span class="number">1</span>] ); <span class="comment">// Orange</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits[<span class="number">2</span>] ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure>

<p>可以替换元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fruits[<span class="number">2</span>] = <span class="string">&#x27;Pear&#x27;</span>; <span class="comment">// 现在数组变成了 [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;]</span></span><br></pre></td></tr></table></figure>

<p>……或者向数组新加一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fruits[<span class="number">3</span>] = <span class="string">&#x27;Lemon&#x27;</span>; <span class="comment">// 现在数组变成 [&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Lemon&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>length</code> <strong>属性</strong>的值是数组中元素的总个数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits.<span class="property">length</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>也可以用 <code>console.log</code> 来显示整个数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Apple,Orange,Plum</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;数组可以存储任何类型的元素。&#x3D;&#x3D;</p>
<p>例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 混合值</span></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="string">&#x27;Apple&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;, <span class="literal">true</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>); &#125; ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引为 1 的对象然后显示它的 name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr[<span class="number">1</span>].<span class="property">name</span> ); <span class="comment">// John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取索引为 3 的函数并执行</span></span><br><span class="line">arr[<span class="number">3</span>](); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>以逗号结尾</p>
<p>数组就像对象一样，可以以逗号结尾：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [</span><br><span class="line">  <span class="string">&quot;Apple&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Orange&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Plum&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>因为每一行都是相似的，所以这种以“逗号结尾”的方式使得插入&#x2F;移除项变得更加简单。</p>
<h2 id="使用-“at”-获取最后一个元素"><a href="#使用-“at”-获取最后一个元素" class="headerlink" title="使用 “at” 获取最后一个元素"></a>使用 “at” 获取最后一个元素</h2><p>最近新增的特性</p>
<p>这是一个最近添加到 JavaScript 的特性。</p>
<p>假设我们想要数组的最后一个元素。</p>
<p>一些编程语言允许我们使用负数索引来实现这一点，例如 <code>fruits[-1]</code>。</p>
<p>但在 JavaScript 中这行不通。结果将是 <code>undefined</code>，因为方括号中的索引是被按照其字面意思处理的。</p>
<p>我们可以显式地计算最后一个元素的索引，然后访问它：<code>fruits[fruits.length - 1]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits[fruits.<span class="property">length</span>-<span class="number">1</span>] ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure>

<p>有点麻烦，不是吗？我们需要写两次变量名。</p>
<p>幸运的是，这里有一个更简短的语法 <code>fruits.at(-1)</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 fruits[fruits.length-1] 相同</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits.<span class="title function_">at</span>(-<span class="number">1</span>) ); <span class="comment">// Plum</span></span><br></pre></td></tr></table></figure>

<p>换句话说，<code>arr.at(i)</code>：</p>
<ul>
<li>如果 <code>i &gt;= 0</code>，则与 <code>arr[i]</code> 完全相同。</li>
<li>对于 <code>i</code> 为负数的情况，它则从数组的尾部向前数。</li>
</ul>
<h2 id="pop-push-shift-unshift-方法"><a href="#pop-push-shift-unshift-方法" class="headerlink" title="pop&#x2F;push, shift&#x2F;unshift 方法"></a>pop&#x2F;push, shift&#x2F;unshift 方法</h2><p>队列（queue）是最常见的使用数组的方法之一。在计算机科学中，这表示支持两个操作的一个有序元素的集合：</p>
<ul>
<li><code>push</code> 在末端添加一个元素.</li>
<li><code>shift</code> 取出队列首端的一个元素，整个队列往前移，这样原先排第二的元素现在排在了第一。</li>
</ul>
<p><img src="https://zh.javascript.info/article/array/queue.svg"></p>
<p>这两种操作数组都支持。</p>
<p>队列的应用在实践中经常会碰到。例如需要在屏幕上显示消息队列。</p>
<p>数组还有另一个用例，就是数据结构 <strong>栈</strong>。</p>
<p>它支持两种操作：</p>
<ul>
<li><code>push</code> 在末端添加一个元素.</li>
<li><code>pop</code> 从末端取出一个元素.</li>
</ul>
<p>所以新元素的添加和取出都是从“末端”开始的。</p>
<p>栈通常被被形容成一叠卡片：要么在最上面添加卡片，要么从最上面拿走卡片。</p>
<p><img src="https://zh.javascript.info/article/array/stack.svg"></p>
<p>对于栈来说，最后放进去的内容是最先接收的，也叫做 <strong>LIFO（Last-In-First-Out）</strong>，即<strong>后进先出</strong>法则。</p>
<p>而与队列相对应的叫做 <strong>FIFO（First-In-First-Out）</strong>，即<strong>先进先出</strong>。</p>
<p>JavaScript 中的数组既可以用作队列，也可以用作栈。它们允许你从首端&#x2F;末端来添加&#x2F;删除元素。</p>
<p>这在计算机科学中，允许这样的操作的数据结构被称为 双端队列（deque）</p>
<h3 id="作用于数组末端的方法："><a href="#作用于数组末端的方法：" class="headerlink" title="作用于数组末端的方法："></a><strong>作用于数组末端的方法：</strong></h3><p><code>pop</code></p>
<p>取出并返回数组的最后一个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits.<span class="title function_">pop</span>() ); <span class="comment">// 移除 &quot;Pear&quot; 然后 console.log 显示出来</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Apple, Orange</span></span><br></pre></td></tr></table></figure>

<p><code>fruits.pop()</code> 和 <code>fruits.at(-1)</code> 都返回数组的最后一个元素，但 <code>fruits.pop()</code> 同时也删除了数组的最后一个元素，进而修改了原数组。</p>
<p><code>push</code></p>
<p>在数组末端添加元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">push</span>(<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Apple, Orange, Pear</span></span><br></pre></td></tr></table></figure>

<p>调用 <code>fruits.push(...)</code> 与 <code>fruits[fruits.length] = ...</code> 是一样的。</p>
<h3 id="作用于数组首端的方法："><a href="#作用于数组首端的方法：" class="headerlink" title="作用于数组首端的方法："></a><strong>作用于数组首端的方法：</strong></h3><p><code>shift</code></p>
<p>移除数组的第一个元素并返回它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits.<span class="title function_">shift</span>() ); <span class="comment">// 移除 Apple 然后 console.log 显示出来</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Orange, Pear</span></span><br></pre></td></tr></table></figure>



<p><code>unshift</code></p>
<p>在数组的首端添加元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">unshift</span>(<span class="string">&#x27;Apple&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Apple, Orange, Pear</span></span><br></pre></td></tr></table></figure>

<p><code>push</code> 和 <code>unshift</code> 方法都可以一次添加多个元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>];</span><br><span class="line"></span><br><span class="line">fruits.<span class="title function_">push</span>(<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Peach&quot;</span>);</span><br><span class="line">fruits.<span class="title function_">unshift</span>(<span class="string">&quot;Pineapple&quot;</span>, <span class="string">&quot;Lemon&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// [&quot;Pineapple&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Orange&quot;, &quot;Peach&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits );</span><br></pre></td></tr></table></figure>



<h2 id="内部"><a href="#内部" class="headerlink" title="内部"></a>内部</h2><p>数组是一种特殊的对象。使用方括号来访问属性 <code>arr[0]</code> 实际上是来自于对象的语法。它其实与 <code>obj[key]</code> 相同，其中 <code>arr</code> 是对象，而数字用作键（key）。</p>
<p>它们扩展了对象，提供了特殊的方法来处理有序的数据集合以及 <code>length</code> 属性。但从本质上讲，它仍然是一个对象。</p>
<p>记住，在 JavaScript 中只有 8 种基本的数据类型。数组是一个对象，因此其行为也像一个对象。</p>
<p>例如，它是通过引用来复制的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Banana&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = fruits; <span class="comment">// 通过引用复制 (两个变量引用的是相同的数组)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr === fruits ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">push</span>(<span class="string">&quot;Pear&quot;</span>); <span class="comment">// 通过引用修改数组</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits ); <span class="comment">// Banana, Pear — 现在有 2 项了</span></span><br></pre></td></tr></table></figure>

<p>……但是数组真正特殊的是它们的内部实现。JavaScript 引擎尝试把这些元素一个接一个地存储在连续的内存区域，就像本章的插图显示的一样，而且还有一些其它的优化，以使数组运行得非常快。</p>
<p>但是，如果我们不像“有序集合”那样使用数组，而是像常规对象那样使用数组，这些就都不生效了。</p>
<p>例如，从技术上讲，我们可以这样做:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = []; <span class="comment">// 创建一个数组</span></span><br><span class="line"></span><br><span class="line">fruits[<span class="number">99999</span>] = <span class="number">5</span>; <span class="comment">// 分配索引远大于数组长度的属性</span></span><br><span class="line"></span><br><span class="line">fruits.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 创建一个具有任意名称的属性</span></span><br></pre></td></tr></table></figure>

<p>这是可以的，因为数组是基于对象的。我们可以给它们添加任何属性。</p>
<p>但是 Javascript 引擎会发现，我们在像使用常规对象一样使用数组，那么针对数组的优化就不再适用了，然后对应的优化就会被关闭，这些优化所带来的优势也就荡然无存了。</p>
<p>数组误用的几种方式:</p>
<ul>
<li>添加一个非数字的属性，比如 <code>arr.test = 5</code>。</li>
<li>制造空洞，比如：添加 <code>arr[0]</code>，然后添加 <code>arr[1000]</code> (它们中间什么都没有)。</li>
<li>以倒序填充数组，比如 <code>arr[1000]</code>，<code>arr[999]</code> 等等。</li>
</ul>
<p>请将数组视为作用于 <strong>有序数据</strong> 的特殊结构。它们为此提供了特殊的方法。数组在 JavaScript 引擎内部是经过特殊调整的，使得更好地作用于连续的有序数据，所以请以正确的方式使用数组。如果你需要任意键值，那很有可能实际上你需要的是常规对象 <code>&#123;&#125;</code>。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p><code>push/pop</code> 方法运行的比较快，而 <code>shift/unshift</code> 比较慢。</p>
<p><img src="https://zh.javascript.info/article/array/array-speed.svg"></p>
<p>为什么作用于数组的末端会比首端快呢？让我们看看在执行期间都发生了什么：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits.shift(); // 从首端取出一个元素</span><br></pre></td></tr></table></figure>

<p>只获取并移除索引 <code>0</code> 对应的元素是不够的。其它元素也需要被重新编号。</p>
<p><code>shift</code> 操作必须做三件事:</p>
<ol>
<li>移除索引为 <code>0</code> 的元素。</li>
<li>把所有的元素向左移动，把索引 <code>1</code> 改成 <code>0</code>，<code>2</code> 改成 <code>1</code> 以此类推，对其重新编号。</li>
<li>更新 <code>length</code> 属性。</li>
</ol>
<p><img src="https://zh.javascript.info/article/array/array-shift.svg"></p>
<p><strong>数组里的元素越多，移动它们就要花越多的时间，也就意味着越多的内存操作。</strong></p>
<p><code>unshift</code> 也是一样：为了在数组的首端添加元素，我们首先需要将现有的元素向右移动，增加它们的索引值。</p>
<p>那 <code>push/pop</code> 是什么样的呢？它们不需要移动任何东西。如果从末端移除一个元素，<code>pop</code> 方法只需要清理索引值并缩短 <code>length</code> 就可以了。</p>
<p><code>pop</code> 操作的行为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fruits.pop(); // 从末端取走一个元素</span><br></pre></td></tr></table></figure>

<p><img src="https://zh.javascript.info/article/array/array-pop.svg"></p>
<p><strong><code>pop</code> 方法不需要移动任何东西，因为其它元素都保留了各自的索引。这就是为什么 <code>pop</code> 会特别快。</strong></p>
<p><code>push</code> 方法也是一样的。</p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>遍历数组最古老的方式就是 <code>for</code> 循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( arr[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但对于数组来说还有另一种循环方式，<code>for..of</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Plum&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> fruit <span class="keyword">of</span> fruits) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( fruit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for..of</code> 不能获取当前元素的索引，只是获取元素值，但大多数情况是够用的。而且这样写更短。</p>
<p>技术上来讲，因为数组也是对象，所以使用 <code>for..in</code> 也是可以的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Pear&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( arr[key] ); <span class="comment">// Apple, Orange, Pear</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这其实是一个很不好的想法。会有一些潜在问题存在：</p>
<ol>
<li><p><code>for..in</code> 循环会遍历 <strong>所有属性</strong>，不仅仅是这些数字属性。</p>
<p>在浏览器和其它环境中有一种称为“类数组”的对象，它们 <strong>看似是数组</strong>。也就是说，它们有 <code>length</code> 和索引属性，但是也可能有其它的非数字的属性和方法，这通常是我们不需要的。<code>for..in</code> 循环会把它们都列出来。所以如果我们需要处理类数组对象，这些“额外”的属性就会存在问题。</p>
</li>
<li><p><code>for..in</code> 循环适用于普通对象，并且做了对应的优化。但是不适用于数组，因此速度要慢 10-100 倍。当然即使是这样也依然非常快。只有在遇到瓶颈时可能会有问题。但是我们仍然应该了解这其中的不同。</p>
</li>
</ol>
<p>通常来说，我们不应该用 <code>for..in</code> 来处理数组。</p>
<h2 id="关于-“length”"><a href="#关于-“length”" class="headerlink" title="关于 “length”"></a>关于 “length”</h2><p>当我们修改数组的时候，<code>length</code> 属性会<strong>自动更新</strong>。<br>准确来说，<strong>数组长度实际上不是数组里元素的个数，而是最大的数字索引值加一</strong>。</p>
<p>例如，一个数组只有一个元素，但是这个元素的索引值很大，那么这个数组的 <code>length</code> 也会很大：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [];</span><br><span class="line">fruits[<span class="number">123</span>] = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( fruits.<span class="property">length</span> ); <span class="comment">// 124</span></span><br></pre></td></tr></table></figure>

<p>要知道的是我们通常不会这样使用数组。</p>
<p><code>length</code> 属性的另一个有意思的点是它是可写的。</p>
<p>如果我们手动增加它，则不会发生任何有趣的事儿。但是如果我们减少它，数组就会被截断。该过程是不可逆的，下面是例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">2</span>; <span class="comment">// 截断到只剩 2 个元素</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr ); <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>; <span class="comment">// 又把 length 加回来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr[<span class="number">3</span>] ); <span class="comment">// undefined：被截断的那些数值并没有回来</span></span><br></pre></td></tr></table></figure>

<p>所以，清空数组最简单的方法就是：<code>arr.length = 0;</code>。</p>
<h2 id="new-Array"><a href="#new-Array" class="headerlink" title="new Array()"></a>new Array()</h2><p>这是创建数组的另一种语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;etc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>它很少被使用，因为方括号 <code>[]</code> 更短更简洁。而且，这种语法还有一个棘手的特性。</p>
<p>如果使用单个参数（即数字）调用 <code>new Array</code>，那么它会创建一个 <strong>指定了长度，却没有任何项</strong> 的数组。</p>
<p>让我们看看如何搬起石头砸自己的脚:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>); <span class="comment">// 会创建一个 [2] 的数组吗？</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr[<span class="number">0</span>] ); <span class="comment">// undefined！没有元素。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr.<span class="property">length</span> ); <span class="comment">// length 2</span></span><br></pre></td></tr></table></figure>

<p>为了避免这种意外情况，我们通常使用方括号，除非我们真的知道自己在做什么。</p>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>数组里的项也可以是数组。我们可以将其用于多维数组，例如存储矩阵：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> matrix = [</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">  [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( matrix[<span class="number">1</span>][<span class="number">1</span>] ); <span class="comment">// 最中间的那个数</span></span><br></pre></td></tr></table></figure>


<h2 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h2><p>数组有自己的 <code>toString</code> 方法的实现，会返回以逗号隔开的元素列表。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( arr ); <span class="comment">// 1,2,3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(arr) === <span class="string">&#x27;1,2,3&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>此外，我们试试运行一下这个：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( [] + <span class="number">1</span> ); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( [<span class="number">1</span>] + <span class="number">1</span> ); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( [<span class="number">1</span>,<span class="number">2</span>] + <span class="number">1</span> ); <span class="comment">// &quot;1,21&quot;</span></span><br></pre></td></tr></table></figure>

<p>数组没有 <code>Symbol.toPrimitive</code>，也没有 <code>valueOf</code>，它们只能执行 <code>toString</code> 进行转换，所以这里 <code>[]</code> 就变成了一个空字符串，<code>[1]</code> 变成了 <code>&quot;1&quot;</code>，<code>[1,2]</code> 变成了 <code>&quot;1,2&quot;</code>。</p>
<p>当 <code>&quot;+&quot;</code> 运算符把一些项加到字符串后面时，加号后面的项也会被转换成字符串，所以下一步就会是这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;&quot;</span> + <span class="number">1</span> ); <span class="comment">// &quot;1&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;1&quot;</span> + <span class="number">1</span> ); <span class="comment">// &quot;11&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;1,2&quot;</span> + <span class="number">1</span> ); <span class="comment">// &quot;1,21&quot;</span></span><br></pre></td></tr></table></figure>



<h2 id="不要使用-比较数组"><a href="#不要使用-比较数组" class="headerlink" title="不要使用 &#x3D;&#x3D; 比较数组"></a>不要使用 &#x3D;&#x3D; 比较数组</h2><p>JavaScript 中的数组与其它一些编程语言的不同，不应该使用 <code>==</code> 运算符比较 JavaScript 中的数组。</p>
<p>该运算符不会对数组进行特殊处理，它会像处理任意对象那样处理数组。</p>
<p>让我们回顾一下规则：</p>
<ul>
<li>仅当两个对象引用的是同一个对象时，它们才相等 <code>==</code>。</li>
<li>如果 <code>==</code> 左右两个参数之中有一个参数是对象，另一个参数是原始类型，那么该对象将会被转换为原始类型，转换规则如 <a href="https://zh.javascript.info/object-toprimitive">对象 —— 原始值转换</a> 一章所述。</li>
<li>……<code>null</code> 和 <code>undefined</code> 相等 <code>==</code>，且各自不等于任何其他的值。</li>
</ul>
<p>严格比较 <code>===</code> 更简单，因为它不会进行类型转换。</p>
<p>所以，如果我们使用 <code>==</code> 来比较数组，除非我们比较的是两个引用同一数组的变量，否则它们永远不相等。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( [] == [] ); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( [<span class="number">0</span>] == [<span class="number">0</span>] ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>从技术上讲，这些数组是不同的对象。所以它们不相等。<code>==</code> 运算符不会进行逐项比较。</p>
<p>与原始类型的比较也可能会产生看似很奇怪的结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> == [] ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;0&#x27;</span> == [] ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>在这里的两个例子中，我们将原始类型和数组对象进行比较。因此，数组 <code>[]</code> 被转换为原始类型以进行比较，被转换成了一个空字符串 <code>&#39;&#39;</code>。</p>
<p>然后，接下来的比较就是原始类型之间的比较，如 <a href="https://zh.javascript.info/type-conversions">类型转换</a> 一章所述：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 [] 被转换为 &#x27;&#x27; 后</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> == <span class="string">&#x27;&#x27;</span> ); <span class="comment">// true，因为 &#x27;&#x27; 被转换成了数字 0</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;0&#x27;</span> == <span class="string">&#x27;&#x27;</span> ); <span class="comment">// false，没有进一步的类型转换，是不同的字符串</span></span><br></pre></td></tr></table></figure>

<p>那么，我们应该如何对数组进行比较呢？</p>
<p>很简单，不要使用 <code>==</code> 运算符。而是，可以在循环中或者使用下一章中我们将介绍的迭代方法逐项地比较它们。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数组是一种特殊的对象，适用于存储和管理有序的数据项。</p>
<p>声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方括号 (常见用法)</span><br><span class="line">let arr = [item1, item2...];</span><br><span class="line"></span><br><span class="line">// new Array (极其少见)</span><br><span class="line">let arr = new Array(item1, item2...);</span><br></pre></td></tr></table></figure>

<p>调用 <code>new Array(number)</code> 会创建一个给定长度的数组，但不含有任何项。</p>
<ul>
<li><code>length</code> 属性是数组的长度，准确地说，它是数组最后一个数字索引值加一。它由数组方法自动调整。</li>
<li>如果我们手动缩短 <code>length</code>，那么数组就会被截断。</li>
</ul>
<p>获取元素：</p>
<ul>
<li>你可以通过元素的索引获取元素，例如 <code>arr[0]</code></li>
<li>我们也可以使用允许负索引的 <code>at(i)</code> 方法。对于负值的 <code>i</code>，它会从数组的末尾往回数。如果 <code>i &gt;= 0</code>，它的工作方式与 <code>arr[i]</code> 相同。</li>
</ul>
<p>我们可以通过下列操作以双端队列的方式使用数组：</p>
<ul>
<li><code>push(...items)</code> 在末端添加 <code>items</code> 项。</li>
<li><code>pop()</code> 从末端移除并返回该元素。</li>
<li><code>shift()</code> 从首端移除并返回该元素。</li>
<li><code>unshift(...items)</code> 从首端添加 <code>items</code> 项。</li>
</ul>
<p>遍历数组的元素：</p>
<ul>
<li><code>for (let i=0; i&lt;arr.length; i++)</code> — 运行得最快，可兼容旧版本浏览器。</li>
<li><code>for (let item of arr)</code> — 现代语法，只能访问 items。</li>
<li><code>for (let i in arr)</code> — 永远不要用这个。</li>
</ul>
<p>比较数组时，不要使用 <code>==</code> 运算符（当然也不要使用 <code>&gt;</code> 和 <code>&lt;</code> 等运算符），因为它们不会对数组进行特殊处理。它们通常会像处理任意对象那样处理数组，这通常不是我们想要的。</p>
<p>但是，我们可以使用 <code>for..of</code> 循环来逐项比较数组。</p>
<p>在下一章 <a href="https://zh.javascript.info/array-methods">数组方法</a> 中，我们将继续学习数组，学习更多添加、移除、提取元素和数组排序的方法。</p>
<hr>
<h1 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h1><p>数组提供的方法有很多。为了方便起见，在本章中，我们将按组讲解。</p>
<h2 id="添加-移除数组元素"><a href="#添加-移除数组元素" class="headerlink" title="添加 &#x2F; 移除数组元素"></a>添加 &#x2F; 移除数组元素</h2><p>我们已经学了从数组的首端或尾端添加和删除元素的方法：</p>
<ul>
<li><code>arr.push(...items)</code> —— 从尾端添加元素，</li>
<li><code>arr.pop()</code> —— 从尾端提取元素，</li>
<li><code>arr.shift()</code> —— 从首端提取元素，</li>
<li><code>arr.unshift(...items)</code> —— 从首端添加元素。</li>
</ul>
<p>这里还有其他几种方法。</p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><p>如何从数组中删除元素？</p>
<p>数组是对象，所以我们可以尝试使用 <code>delete</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;home&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> arr[<span class="number">1</span>]; <span class="comment">// remove &quot;go&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr[<span class="number">1</span>] ); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// now arr = [&quot;I&quot;,  , &quot;home&quot;];</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="property">length</span> ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>元素被删除了，但数组仍然有 3 个元素，我们可以看到 <code>arr.length == 3</code>。</p>
<p>这很正常，因为 <code>delete obj.key</code> 是通过 <code>key</code> 来移除对应的值。对于对象来说是可以的。但是对于数组来说，我们通常希望剩下的元素能够移动并占据被释放的位置。我们希望得到一个更短的数组。</p>
<p>所以应该使用特殊的方法。</p>
<p><code>arr.splice</code> 方法可以说是处理数组的瑞士军刀。它可以做所有事情：<strong>添加，删除和插入元素</strong>。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">splice</span>(start[, deleteCount, elem1, ..., elemN])</span><br></pre></td></tr></table></figure>

<p>它从索引 <code>start</code> 开始修改 <code>arr</code>：删除 <code>deleteCount</code> 个元素并在当前位置插入 <code>elem1, ..., elemN</code>。最后返回被删除的元素所组成的数组。</p>
<p>通过例子我们可以很容易地掌握这个方法。</p>
<p>让我们从删除开始：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 从索引 1 开始删除 1 个元素</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// [&quot;I&quot;, &quot;JavaScript&quot;]</span></span><br></pre></td></tr></table></figure>

<p>简单，对吧？从索引 <code>1</code> 开始删除 <code>1</code> 个元素。（译注：当只填写了 <code>splice</code> 的 <code>start</code> 参数时，将删除从索引 <code>start</code> 开始的所有数组项）</p>
<p>在下一个例子中，我们删除了 3 个元素，并用另外两个元素替换它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除数组的前三项，并使用其他内容代替它们</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="string">&quot;Let&#x27;s&quot;</span>, <span class="string">&quot;dance&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ) <span class="comment">// 现在 [&quot;Let&#x27;s&quot;, &quot;dance&quot;, &quot;right&quot;, &quot;now&quot;]</span></span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到 <code>splice</code> 返回了被删除的元素所组成的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;now&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除前两个元素</span></span><br><span class="line"><span class="keyword">let</span> removed = arr.<span class="title function_">splice</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( removed ); <span class="comment">// &quot;I&quot;, &quot;study&quot; &lt;-- 被从数组中删除了的元素</span></span><br></pre></td></tr></table></figure>

<p>我们可以将 <code>deleteCount</code> 设置为 <code>0</code>，<code>splice</code> 方法就能够插入元素而不用删除任何元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;I&quot;</span>, <span class="string">&quot;study&quot;</span>, <span class="string">&quot;JavaScript&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 2 开始</span></span><br><span class="line"><span class="comment">// 删除 0 个元素</span></span><br><span class="line"><span class="comment">// 然后插入 &quot;complex&quot; 和 &quot;language&quot;</span></span><br><span class="line">arr.<span class="title function_">splice</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;complex&quot;</span>, <span class="string">&quot;language&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// &quot;I&quot;, &quot;study&quot;, &quot;complex&quot;, &quot;language&quot;, &quot;JavaScript&quot;</span></span><br></pre></td></tr></table></figure>

<p>允许负向索引</p>
<p>在这里和其他数组方法中，负向索引都是被允许的。它们从数组末尾计算位置，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从索引 -1（尾端前一位）</span></span><br><span class="line"><span class="comment">// 删除 0 个元素，</span></span><br><span class="line"><span class="comment">// 然后插入 3 和 4</span></span><br><span class="line">arr.<span class="title function_">splice</span>(-<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// 1,2,3,4,5</span></span><br></pre></td></tr></table></figure>



<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><p><code>arr.slice</code> 方法比 <code>arr.splice</code> 简单得多。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">slice</span>([start], [end])</span><br></pre></td></tr></table></figure>

<p>它会返回一个新数组，将所有从索引 <code>start</code> 到 <code>end</code>（不包括 <code>end</code>）的数组项复制到一个新的数组。<code>start</code> 和 <code>end</code> 都可以是负数，在这种情况下，从末尾计算索引。</p>
<p>它和字符串的 <code>str.slice</code> 方法有点像，就是把子字符串替换成子数组。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;t&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">slice</span>(<span class="number">1</span>, <span class="number">3</span>) ); <span class="comment">// e,s（复制从位置 1 到位置 3 的元素）</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">slice</span>(-<span class="number">2</span>) ); <span class="comment">// s,t（复制从位置 -2 到尾端的元素）</span></span><br></pre></td></tr></table></figure>

<p>我们也可以不带参数地调用它：<code>arr.slice()</code> 会创建一个 <code>arr</code> 的副本。其通常用于获取副本，以进行不影响原始数组的进一步转换。</p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>arr.concat</code> 创建一个新数组，其中包含来自于其他数组和其他项的值。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">concat</span>(arg1, arg2...)</span><br></pre></td></tr></table></figure>

<p>它接受任意数量的参数 —— 数组或值都可以。</p>
<p>结果是一个包含来自于 <code>arr</code>，然后是 <code>arg1</code>，<code>arg2</code> 的元素的新数组。</p>
<p>如果参数 <code>argN</code> 是一个数组，那么其中的所有元素都会被复制。否则，将复制参数本身。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 arr 和 [3,4] 创建一个新数组</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>]) ); <span class="comment">// 1,2,3,4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 arr、[3,4] 和 [5,6] 创建一个新数组</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]) ); <span class="comment">// 1,2,3,4,5,6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 arr、[3,4]、5 和 6 创建一个新数组</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>([<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>, <span class="number">6</span>) ); <span class="comment">// 1,2,3,4,5,6</span></span><br></pre></td></tr></table></figure>

<p>通常，它只复制数组中的元素。其他对象，即使它们看起来像数组一样，但仍然会被作为一个整体添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>(arrayLike) ); <span class="comment">// 1,2,[object Object]</span></span><br></pre></td></tr></table></figure>

<p>……但是，如果类数组对象具有 <code>Symbol.isConcatSpreadable</code> 属性，那么它就会被 <code>concat</code> 当作一个数组来处理：此对象中的元素将被添加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;something&quot;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&quot;else&quot;</span>,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">isConcatSpreadable</span>]: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">concat</span>(arrayLike) ); <span class="comment">// 1,2,something,else</span></span><br></pre></td></tr></table></figure>



<h2 id="遍历：forEach"><a href="#遍历：forEach" class="headerlink" title="遍历：forEach"></a>遍历：forEach</h2><p><code>arr.forEach</code> 方法允许为数组的每个元素都运行一个函数。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// ... do something with item</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例如，下面这个程序显示了数组的每个元素：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对每个元素调用 alert</span></span><br><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">forEach</span>(alert);</span><br></pre></td></tr></table></figure>

<p>而这段代码更详细地介绍了它们在目标数组中的位置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="string">`<span class="subst">$&#123;item&#125;</span> is at index <span class="subst">$&#123;index&#125;</span> in <span class="subst">$&#123;array&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该函数的结果（如果它有返回）会被抛弃和忽略。</p>
<h2 id="在数组中搜索"><a href="#在数组中搜索" class="headerlink" title="在数组中搜索"></a>在数组中搜索</h2><p>现在，让我们介绍在数组中进行搜索的方法。</p>
<h3 id="indexOf-lastIndexOf-和-includes"><a href="#indexOf-lastIndexOf-和-includes" class="headerlink" title="indexOf&#x2F;lastIndexOf 和 includes"></a>indexOf&#x2F;lastIndexOf 和 includes</h3><p><code>arr.indexOf</code> 和 <code>arr.includes</code> 方法语法相似，并且作用基本上也与字符串的方法相同，只不过这里是对数组元素而不是字符进行操作：</p>
<ul>
<li><code>arr.indexOf(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回索引，否则返回 <code>-1</code>。</li>
<li><code>arr.includes(item, from)</code> —— 从索引 <code>from</code> 开始搜索 <code>item</code>，如果找到则返回 <code>true</code>（译注：如果没找到，则返回 <code>false</code>）。</li>
</ul>
<p>通常使用这些方法时只会传入一个参数：传入 <code>item</code> 开始搜索。默认情况下，搜索是从头开始的。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">0</span>, <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">indexOf</span>(<span class="number">0</span>) ); <span class="comment">// 1</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">indexOf</span>(<span class="literal">false</span>) ); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">indexOf</span>(<span class="literal">null</span>) ); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">includes</span>(<span class="number">1</span>) ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>indexOf</code> 和 <code>includes</code> 使用严格相等 <code>===</code> 进行比较。所以，如果我们搜索 <code>false</code>，它会准确找到 <code>false</code> 而不是数字 <code>0</code>。</p>
<p>如果我们想检查数组中是否包含元素 <code>item</code>，并且不需要知道其确切的索引，那么 <code>arr.includes</code> 是首选。</p>
<p>方法 <code>arr.lastIndexOf</code> 与 <code>indexOf</code> 相同，但从右向左查找。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruits = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">indexOf</span>(<span class="string">&#x27;Apple&#x27;</span>) ); <span class="comment">// 0（第一个 Apple）</span></span><br><span class="line"><span class="title function_">alert</span>( fruits.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;Apple&#x27;</span>) ); <span class="comment">// 2（最后一个 Apple）</span></span><br></pre></td></tr></table></figure>

<p>方法 <code>includes</code> 可以正确的处理 <code>NaN</code></p>
<p>方法 <code>includes</code> 的一个次要但值得注意的特性是，它可以正确处理 <code>NaN</code>，这与 <code>indexOf</code> 不同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="title class_">NaN</span>];</span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">indexOf</span>(<span class="title class_">NaN</span>) ); <span class="comment">// -1（错，应该为 0）</span></span><br><span class="line"><span class="title function_">alert</span>( arr.<span class="title function_">includes</span>(<span class="title class_">NaN</span>) );<span class="comment">// true（正确）</span></span><br></pre></td></tr></table></figure>

<p>这是因为 <code>includes</code> 是在比较晚的时候才被添加到 JavaScript 中的，并且在内部使用了更新了的比较算法。</p>
<h3 id="find-和-findIndex-findLastIndex"><a href="#find-和-findIndex-findLastIndex" class="headerlink" title="find 和 findIndex&#x2F;findLastIndex"></a>find 和 findIndex&#x2F;findLastIndex</h3><p>想象一下，我们有一个对象数组。我们如何找到具有特定条件的对象？</p>
<p>这时可以用 <code>arr.find</code> 方法。</p>
<p>语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">find</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果返回 true，则返回 item 并停止迭代</span></span><br><span class="line">  <span class="comment">// 对于假值（falsy）的情况，则返回 undefined</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>依次对数组中的每个元素调用该函数：</p>
<ul>
<li><code>item</code> 是元素。</li>
<li><code>index</code> 是它的索引。</li>
<li><code>array</code> 是数组本身。</li>
</ul>
<p>如果它返回 <code>true</code>，则搜索停止，并返回 <code>item</code>。如果没有搜索到，则返回 <code>undefined</code>。</p>
<p>例如，我们有一个存储用户的数组，每个用户都有 <code>id</code> 和 <code>name</code> 字段。让我们找到 <code>id == 1</code> 的那个用户：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = users.<span class="title function_">find</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>在现实生活中，对象数组是很常见的，所以 <code>find</code> 方法非常有用。</p>
<p>注意在这个例子中，我们传给了 <code>find</code> 一个单参数函数 <code>item =&gt; item.id == 1</code>。这很典型，并且 <code>find</code> 方法的其他参数很少使用。</p>
<p><code>arr.findIndex</code> 方法（与 <code>arr.find</code>）具有相同的语法，但它返回找到的元素的索引，而不是元素本身。如果没找到，则返回 <code>-1</code>。</p>
<p><code>arr.findLastIndex</code> 方法类似于 <code>findIndex</code>，但从右向左搜索，类似于 <code>lastIndexOf</code>。</p>
<p>这是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找第一个 John 的索引</span></span><br><span class="line"><span class="title function_">alert</span>(users.<span class="title function_">findIndex</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">name</span> == <span class="string">&#x27;John&#x27;</span>)); <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找最后一个 John 的索引</span></span><br><span class="line"><span class="title function_">alert</span>(users.<span class="title function_">findLastIndex</span>(<span class="function"><span class="params">user</span> =&gt;</span> user.<span class="property">name</span> == <span class="string">&#x27;John&#x27;</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><a href="https://zh.javascript.info/array-methods#filter">filter</a></h3><p><code>find</code> 方法搜索的是使函数返回 <code>true</code> 的第一个（单个）元素。</p>
<p>如果需要匹配的有很多，我们可以使用 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">arr.filter(fn)</a>。</p>
<p>语法与 <code>find</code> 大致相同，但是 <code>filter</code> 返回的是所有匹配元素组成的数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> results = arr.<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 true item 被 push 到 results，迭代继续</span></span><br><span class="line">  <span class="comment">// 如果什么都没找到，则返回空数组</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回前两个用户的数组</span></span><br><span class="line"><span class="keyword">let</span> someUsers = users.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">id</span> &lt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(someUsers.<span class="property">length</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a><a href="https://zh.javascript.info/array-methods#zhuan-huan-shu-zu">转换数组</a></h2><p>让我们继续学习进行数组转换和重新排序的方法。</p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a><a href="https://zh.javascript.info/array-methods#map">map</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/map">arr.map</a> 方法是最有用和经常使用的方法之一。</p>
<p>它对数组的每个元素都调用函数，并返回结果数组。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// 返回新值而不是当前元素</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>例如，在这里我们将每个元素转换为它的字符串长度：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lengths = [<span class="string">&quot;Bilbo&quot;</span>, <span class="string">&quot;Gandalf&quot;</span>, <span class="string">&quot;Nazgul&quot;</span>].<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">length</span>);</span><br><span class="line"><span class="title function_">alert</span>(lengths); <span class="comment">// 5,7,6</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-fn"><a href="#sort-fn" class="headerlink" title="sort(fn)"></a><a href="https://zh.javascript.info/array-methods#sortfn">sort(fn)</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">arr.sort</a> 方法对数组进行 <strong>原位（in-place）</strong> 排序，更改元素的顺序。(译注：原位是指在此数组内，而非生成一个新数组。)</p>
<p>它还返回排序后的数组，但是返回值通常会被忽略，因为修改了 <code>arr</code> 本身。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法重新排列 arr 的内容</span></span><br><span class="line">arr.<span class="title function_">sort</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr );  <span class="comment">// 1, 15, 2</span></span><br></pre></td></tr></table></figure>

<p>你有没有注意到结果有什么奇怪的地方？</p>
<p>顺序变成了 <code>1, 15, 2</code>。不对，但为什么呢？</p>
<p><strong>这些元素默认情况下被按字符串进行排序。</strong></p>
<p>从字面上看，所有元素都被转换为字符串，然后进行比较。对于字符串，按照词典顺序进行排序，实际上应该是 <code>&quot;2&quot; &gt; &quot;15&quot;</code>。</p>
<p>要使用我们自己的排序顺序，我们需要提供一个函数作为 <code>arr.sort()</code> 的参数。</p>
<p>该函数应该比较两个任意值并返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compare</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值大</span></span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果两个值相等</span></span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">// 如果第一个值比第二个值小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，按数字进行排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compareNumeric</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (a == b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(compareNumeric);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr);  <span class="comment">// 1, 2, 15</span></span><br></pre></td></tr></table></figure>

<p>现在结果符合预期了。</p>
<p>我们思考一下这儿发生了什么。<code>arr</code> 可以是由任何内容组成的数组，对吗？它可能包含数字、字符串、对象或其他任何内容。我们有一组 <strong>一些元素</strong>。要对其进行排序，我们需要一个 <strong>排序函数</strong> 来确认如何比较这些元素。默认是按字符串进行排序的。</p>
<p><code>arr.sort(fn)</code> 方法实现了通用的排序算法。我们不需要关心它的内部工作原理（大多数情况下都是经过 <a href="https://en.wikipedia.org/wiki/Quicksort">快速排序</a> 或 <a href="https://en.wikipedia.org/wiki/Timsort">Timsort</a> 算法优化的）。它将遍历数组，使用提供的函数比较其元素并对其重新排序，我们所需要的就是提供执行比较的函数 <code>fn</code>。</p>
<p>顺便说一句，如果我们想知道要比较哪些元素 —— 那么什么都不会阻止 alert 它们：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, -<span class="number">2</span>, <span class="number">15</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">8</span>].<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( a + <span class="string">&quot; &lt;&gt; &quot;</span> + b );</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>该算法可以在此过程中，将一个元素与多个其他元素进行比较，但是它会尝试进行尽可能少的比较。</p>
<p>比较函数可以返回任何数字</p>
<p>实际上，比较函数只需要返回一个正数表示“大于”，一个负数表示“小于”。</p>
<p>通过这个原理我们可以编写更短的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">15</span> ];</span><br><span class="line"></span><br><span class="line">arr.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a - b; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr);  <span class="comment">// 1, 2, 15</span></span><br></pre></td></tr></table></figure>

<p>箭头函数最好</p>
<p>你还记得 <a href="https://zh.javascript.info/arrow-functions-basics">箭头函数</a> 吗？这里使用箭头函数会更加简洁：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b );</span><br></pre></td></tr></table></figure>

<p>这与上面更长的版本完全相同。</p>
<p>使用 <code>localeCompare</code> for strings</p>
<p>你记得 <a href="https://zh.javascript.info/string#correct-comparisons">字符串比较</a> 算法吗？默认情况下，它通过字母的代码比较字母。</p>
<p>对于许多字母，最好使用 <code>str.localeCompare</code> 方法正确地对字母进行排序，例如 <code>Ö</code>。</p>
<p>例如，让我们用德语对几个国家&#x2F;地区进行排序：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> countries = [<span class="string">&#x27;Österreich&#x27;</span>, <span class="string">&#x27;Andorra&#x27;</span>, <span class="string">&#x27;Vietnam&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( countries.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a &gt; b ? <span class="number">1</span> : -<span class="number">1</span>) ); <span class="comment">// Andorra, Vietnam, Österreich（错的）</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( countries.<span class="title function_">sort</span>( <span class="function">(<span class="params">a, b</span>) =&gt;</span> a.<span class="title function_">localeCompare</span>(b) ) ); <span class="comment">// Andorra,Österreich,Vietnam（对的！）</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a><a href="https://zh.javascript.info/array-methods#reverse">reverse</a></h3><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse">arr.reverse</a> 方法用于颠倒 <code>arr</code> 中元素的顺序。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr.<span class="title function_">reverse</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( arr ); <span class="comment">// 5,4,3,2,1</span></span><br></pre></td></tr></table></figure>

<p>它也会返回颠倒后的数组 <code>arr</code>。</p>
<h3 id="split-和-join"><a href="#split-和-join" class="headerlink" title="split 和 join"></a><a href="https://zh.javascript.info/array-methods#split-he-join">split 和 join</a></h3><p>举一个现实生活场景的例子。我们正在编写一个消息应用程序，并且该人员输入以逗号分隔的接收者列表：<code>John, Pete, Mary</code>。但对我们来说，名字数组比单个字符串舒适得多。怎么做才能获得这样的数组呢？</p>
<p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/split">str.split(delim)</a> 方法可以做到。它通过给定的分隔符 <code>delim</code> 将字符串分割成一个数组。</p>
<p>在下面的例子中，我们用“逗号后跟着一个空格”作为分隔符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = <span class="string">&#x27;Bilbo, Gandalf, Nazgul&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = names.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="title function_">alert</span>( <span class="string">`A message to <span class="subst">$&#123;name&#125;</span>.`</span> ); <span class="comment">// A message to Bilbo（和其他名字）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>split</code> 方法有一个可选的第二个数字参数 —— 对数组长度的限制。如果提供了，那么额外的元素会被忽略。但实际上它很少使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="string">&#x27;Bilbo, Gandalf, Nazgul, Saruman&#x27;</span>.<span class="title function_">split</span>(<span class="string">&#x27;, &#x27;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(arr); <span class="comment">// Bilbo, Gandalf</span></span><br></pre></td></tr></table></figure>

<p>拆分为字母</p>
<p>调用带有空参数 <code>s</code> 的 <code>split(s)</code>，会将字符串拆分为字母数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>) ); <span class="comment">// t,e,s,t</span></span><br></pre></td></tr></table></figure>

<p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/join">arr.join(glue)</a> 与 <code>split</code> 相反。它会在它们之间创建一串由 <code>glue</code> 粘合的 <code>arr</code> 项。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;Bilbo&#x27;</span>, <span class="string">&#x27;Gandalf&#x27;</span>, <span class="string">&#x27;Nazgul&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = arr.<span class="title function_">join</span>(<span class="string">&#x27;;&#x27;</span>); <span class="comment">// 使用分号 ; 将数组粘合成字符串</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( str ); <span class="comment">// Bilbo;Gandalf;Nazgul</span></span><br></pre></td></tr></table></figure>

<h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce&#x2F;reduceRight"></a><a href="https://zh.javascript.info/array-methods#reducereduceright">reduce&#x2F;reduceRight</a></h3><p>当我们需要遍历一个数组时 —— 我们可以使用 <code>forEach</code>，<code>for</code> 或 <code>for..of</code>。</p>
<p>当我们需要遍历并返回每个元素的数据时 —— 我们可以使用 <code>map</code>。</p>
<p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 方法和上面的种类差不多，但稍微复杂一点。它们用于根据数组计算单个值。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = arr.<span class="title function_">reduce</span>(<span class="keyword">function</span>(<span class="params">accumulator, item, index, array</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;, [initial]);</span><br></pre></td></tr></table></figure>

<p>该函数一个接一个地应用于所有数组元素，并将其结果“搬运（carry on）”到下一个调用。</p>
<p>参数：</p>
<ul>
<li><code>accumulator</code> —— 是上一个函数调用的结果，第一次等于 <code>initial</code>（如果提供了 <code>initial</code> 的话）。</li>
<li><code>item</code> —— 当前的数组元素。</li>
<li><code>index</code> —— 当前索引。</li>
<li><code>arr</code> —— 数组本身。</li>
</ul>
<p>应用函数时，上一个函数调用的结果将作为第一个参数传递给下一个函数。</p>
<p>因此，第一个参数本质上是累加器，用于存储所有先前执行的组合结果。最后，它成为 <code>reduce</code> 的结果。</p>
<p>听起来复杂吗？</p>
<p>掌握这个知识点的最简单的方法就是通过示例。</p>
<p>在这里，我们通过一行代码得到一个数组的总和：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(result); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>传递给 <code>reduce</code> 的函数仅使用了 2 个参数，通常这就足够了。</p>
<p>让我们看看细节，到底发生了什么。</p>
<ol>
<li>在第一次运行时，<code>sum</code> 的值为初始值 <code>initial</code>（<code>reduce</code> 的最后一个参数），等于 0，<code>current</code> 是第一个数组元素，等于 <code>1</code>。所以函数运行的结果是 <code>1</code>。</li>
<li>在第二次运行时，<code>sum = 1</code>，我们将第二个数组元素（<code>2</code>）与其相加并返回。</li>
<li>在第三次运行中，<code>sum = 3</code>，我们继续把下一个元素与其相加，以此类推……</li>
</ol>
<p>计算流程：</p>
<p>或者以表格的形式表示，每一行代表的是对下一个数组元素的函数调用：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>sum</code></th>
<th><code>current</code></th>
<th><code>result</code></th>
</tr>
</thead>
<tbody><tr>
<td>第 1 次调用</td>
<td><code>0</code></td>
<td><code>1</code></td>
<td><code>1</code></td>
</tr>
<tr>
<td>第 2 次调用</td>
<td><code>1</code></td>
<td><code>2</code></td>
<td><code>3</code></td>
</tr>
<tr>
<td>第 3 次调用</td>
<td><code>3</code></td>
<td><code>3</code></td>
<td><code>6</code></td>
</tr>
<tr>
<td>第 4 次调用</td>
<td><code>6</code></td>
<td><code>4</code></td>
<td><code>10</code></td>
</tr>
<tr>
<td>第 5 次调用</td>
<td><code>10</code></td>
<td><code>5</code></td>
<td><code>15</code></td>
</tr>
</tbody></table>
<p>在这里，我们可以清楚地看到上一个调用的结果如何成为下一个调用的第一个参数。</p>
<p>我们也可以省略初始值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 reduce 的初始值（没有 0）</span></span><br><span class="line"><span class="keyword">let</span> result = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( result ); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<p>结果是一样的。这是因为如果没有初始值，那么 <code>reduce</code> 会将数组的第一个元素作为初始值，并从第二个元素开始迭代。</p>
<p>计算表与上面相同，只是去掉第一行。</p>
<p>但是这种使用需要非常小心。如果数组为空，那么在没有初始值的情况下调用 <code>reduce</code> 会导致错误。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error: Reduce of empty array with no initial value</span></span><br><span class="line"><span class="comment">// 如果初始值存在，则 reduce 将为空 arr 返回它（即这个初始值）。</span></span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">sum, current</span>) =&gt;</span> sum + current);</span><br></pre></td></tr></table></figure>

<p>所以建议始终指定初始值。</p>
<p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight">arr.reduceRight</a> 和 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce">arr.reduce</a> 方法的功能一样，只是遍历为从右到左。</p>
<h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray"></a><a href="https://zh.javascript.info/array-methods#arrayisarray">Array.isArray</a></h2><p>数组是基于对象的，不构成单独的语言类型。</p>
<p>所以 <code>typeof</code> 不能帮助从数组中区分出普通对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="keyword">typeof</span> []); <span class="comment">// object（相同）</span></span><br></pre></td></tr></table></figure>

<p>……但是数组经常被使用，因此有一种特殊的方法用于判断：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray(value)</a>。如果 <code>value</code> 是一个数组，则返回 <code>true</code>；否则返回 <code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(&#123;&#125;)); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>([])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="大多数方法都支持-“thisArg”"><a href="#大多数方法都支持-“thisArg”" class="headerlink" title="大多数方法都支持 “thisArg”"></a><a href="https://zh.javascript.info/array-methods#da-duo-shu-fang-fa-dou-zhi-chi-thisarg">大多数方法都支持 “thisArg”</a></h2><p>几乎所有调用函数的数组方法 —— 比如 <code>find</code>，<code>filter</code>，<code>map</code>，除了 <code>sort</code> 是一个特例，都接受一个可选的附加参数 <code>thisArg</code>。</p>
<p>上面的部分中没有解释该参数，因为该参数很少使用。但是为了完整性，我们需要讲讲它。</p>
<p>以下是这些方法的完整语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.<span class="title function_">find</span>(func, thisArg);</span><br><span class="line">arr.<span class="title function_">filter</span>(func, thisArg);</span><br><span class="line">arr.<span class="title function_">map</span>(func, thisArg);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// thisArg 是可选的最后一个参数</span></span><br></pre></td></tr></table></figure>

<p><code>thisArg</code> 参数的值在 <code>func</code> 中变为 <code>this</code>。</p>
<p>例如，在这里我们使用 <code>army</code> 对象方法作为过滤器，<code>thisArg</code> 用于传递上下文（passes the context）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> army = &#123;</span><br><span class="line">  <span class="attr">minAge</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">maxAge</span>: <span class="number">27</span>,</span><br><span class="line">  <span class="title function_">canJoin</span>(<span class="params">user</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> user.<span class="property">age</span> &gt;= <span class="variable language_">this</span>.<span class="property">minAge</span> &amp;&amp; user.<span class="property">age</span> &lt; <span class="variable language_">this</span>.<span class="property">maxAge</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> users = [</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">20</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">23</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">age</span>: <span class="number">30</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 army.canJoin 返回 true 的 user</span></span><br><span class="line"><span class="keyword">let</span> soldiers = users.<span class="title function_">filter</span>(army.<span class="property">canJoin</span>, army);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(soldiers.<span class="property">length</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="title function_">alert</span>(soldiers[<span class="number">0</span>].<span class="property">age</span>); <span class="comment">// 20</span></span><br><span class="line"><span class="title function_">alert</span>(soldiers[<span class="number">1</span>].<span class="property">age</span>); <span class="comment">// 23</span></span><br></pre></td></tr></table></figure>

<p>如果在上面的示例中我们使用了 <code>users.filter(army.canJoin)</code>，那么 <code>army.canJoin</code> 将被作为独立函数调用，并且这时 <code>this=undefined</code>，从而会导致即时错误。</p>
<p>可以用 <code>users.filter(user =&gt; army.canJoin(user))</code> 替换对 <code>users.filter(army.canJoin, army)</code> 的调用。前者的使用频率更高，因为对于大多数人来说，它更容易理解。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><a href="https://zh.javascript.info/array-methods#zong-jie">总结</a></h2><p>数组方法备忘单：</p>
<ul>
<li><p>添加&#x2F;删除元素：</p>
<ul>
<li><code>push(...items)</code> —— 向尾端添加元素，</li>
<li><code>pop()</code> —— 从尾端提取一个元素，</li>
<li><code>shift()</code> —— 从首端提取一个元素，</li>
<li><code>unshift(...items)</code> —— 向首端添加元素，</li>
<li><code>splice(pos, deleteCount, ...items)</code> —— 从 <code>pos</code> 开始删除 <code>deleteCount</code> 个元素，并插入 <code>items</code>。</li>
<li><code>slice(start, end)</code> —— 创建一个新数组，将从索引 <code>start</code> 到索引 <code>end</code>（但不包括 <code>end</code>）的元素复制进去。</li>
<li><code>concat(...items)</code> —— 返回一个新数组：复制当前数组的所有元素，并向其中添加 <code>items</code>。如果 <code>items</code> 中的任意一项是一个数组，那么就取其元素。</li>
</ul>
</li>
<li><p>搜索元素：</p>
<ul>
<li><code>indexOf/lastIndexOf(item, pos)</code> —— 从索引 <code>pos</code> 开始搜索 <code>item</code>，搜索到则返回该项的索引，否则返回 <code>-1</code>。</li>
<li><code>includes(value)</code> —— 如果数组有 <code>value</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</li>
<li><code>find/filter(func)</code> —— 通过 <code>func</code> 过滤元素，返回使 <code>func</code> 返回 <code>true</code> 的第一个值&#x2F;所有值。</li>
<li><code>findIndex</code> 和 <code>find</code> 类似，但返回索引而不是值。</li>
</ul>
</li>
<li><p>遍历元素：</p>
<ul>
<li><code>forEach(func)</code> —— 对每个元素都调用 <code>func</code>，不返回任何内容。</li>
</ul>
</li>
<li><p>转换数组：</p>
<ul>
<li><code>map(func)</code> —— 根据对每个元素调用 <code>func</code> 的结果创建一个新数组。</li>
<li><code>sort(func)</code> —— 对数组进行原位（in-place）排序，然后返回它。</li>
<li><code>reverse()</code> —— 原位（in-place）反转数组，然后返回它。</li>
<li><code>split/join</code> —— 将字符串拆分为数组并返回&#x2F;将数组项组合成字符串并返回。</li>
<li><code>reduce/reduceRight(func, initial)</code> —— 通过对每个元素调用 <code>func</code> 计算数组上的单个值，并在调用之间传递中间结果。</li>
</ul>
</li>
<li><p>其他：</p>
<ul>
<li><code>Array.isArray(value)</code> 检查 <code>value</code> 是否是一个数组，如果是则返回 <code>true</code>，否则返回 <code>false</code>。</li>
</ul>
</li>
</ul>
<p>请注意，<code>sort</code>，<code>reverse</code> 和 <code>splice</code> 方法修改的是数组本身。</p>
<p>这些是最常用的方法，它们覆盖 99％ 的用例。但是还有其他几个：</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/some">arr.some(fn)</a>&#x2F;<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/every">arr.every(fn)</a> 检查数组。</p>
<p>与 <code>map</code> 类似，对数组的每个元素调用函数 <code>fn</code>。如果任何&#x2F;所有结果为 <code>true</code>，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>这两个方法的行为类似于 <code>||</code> 和 <code>&amp;&amp;</code> 运算符：如果 <code>fn</code> 返回一个真值，<code>arr.some()</code> 立即返回 <code>true</code> 并停止迭代其余数组项；如果 <code>fn</code> 返回一个假值，<code>arr.every()</code> 立即返回 <code>false</code> 并停止对其余数组项的迭代。</p>
<p>我们可以使用 <code>every</code> 来比较数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">arraysEqual</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr1.<span class="property">length</span> === arr2.<span class="property">length</span> &amp;&amp; arr1.<span class="title function_">every</span>(<span class="function">(<span class="params">value, index</span>) =&gt;</span> value === arr2[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( <span class="title function_">arraysEqual</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/fill">arr.fill(value, start, end)</a> —— 从索引 <code>start</code> 到 <code>end</code>，用重复的 <code>value</code> 填充数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin">arr.copyWithin(target, start, end)</a> —— 将从位置 <code>start</code> 到 <code>end</code> 的所有元素复制到 <strong>自身</strong> 的 <code>target</code> 位置（覆盖现有元素）。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flat">arr.flat(depth)</a>&#x2F;<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">arr.flatMap(fn)</a> 从多维数组创建一个新的扁平数组。</p>
</li>
<li><p><a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/of">Array.of(element0[, element1[, …[, elementN]]])</a> 基于可变数量的参数创建一个新的 <code>Array</code> 实例，而不需要考虑参数的数量或类型。</p>
</li>
</ul>
<p>有关完整列表，请参阅 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array">手册</a>。</p>
<p>乍看起来，似乎有很多方法，很难记住。但实际上这比看起来要容易得多。</p>
<p>浏览这个备忘单，以了解这些方法。然后解决本章中的习题来进行练习，以便让你有数组方法的使用经验。</p>
<p>然后，每当你需要对数组进行某些操作，而又不知道怎么做的时候，请回到这儿，查看这个备忘单，然后找到正确的方法。示例将帮助你正确编写它。用不了多久，你就自然而然地记住这些方法了，根本不需要你死记硬背。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>国际化学-学习指北</title>
    <url>//blog/chemistry/international-chemistry/international-chemistry-study-guide.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="考试类型介绍"><a href="#考试类型介绍" class="headerlink" title="考试类型介绍"></a>考试类型介绍</h1><h2 id="IG与ALevel"><a href="#IG与ALevel" class="headerlink" title="IG与ALevel"></a>IG与ALevel</h2><p>IG（International General Certificate of Secondary Education，国际普通中等教育证书）和ALevel（Advanced Level，高级水平证书）是两种不同的<strong>英国教育</strong>体系中的资格证书，它们在教育阶段、课程内容、考试结构和目的上有所不同。以下是它们的主要区别：</p>
<ol>
<li><p><strong>教育阶段</strong>：</p>
<ul>
<li><strong>IGCSE</strong>：相当于中国的<strong>初中</strong>阶段，通常是学生在完成小学教育后，进入高中教育之前的一个过渡阶段。它是一个为期两年的课程，面向14至16岁的学生。</li>
<li><strong>ALevel</strong>：相当于中国的<strong>高中</strong>阶段，是一个为期两年的课程，面向16至18岁的学生，是英国大学入学的主要资格之一。</li>
</ul>
</li>
<li><p><strong>课程内容</strong>：</p>
<ul>
<li><strong>IGCSE</strong>：课程内容较为广泛，旨在为学生提供广泛的知识基础，涵盖多个学科领域。学生通常需要学习5到14门科目，包括核心科目（如数学、英语）和选修科目。</li>
<li><strong>ALevel</strong>：课程内容更加专业化和深入，学生可以选择3到4门科目进行深入学习，这些科目通常与他们未来大学专业或职业规划相关。</li>
</ul>
</li>
<li><p><strong>考试结构</strong>：</p>
<ul>
<li><strong>IGCSE</strong>：考试通常包括笔试、口试、课程作业和实践评估等多种评估方式。</li>
<li><strong>ALevel</strong>：考试主要侧重于笔试，但也包括一些科目的实践评估和课程作业。</li>
</ul>
</li>
<li><p><strong>目的</strong>：</p>
<ul>
<li><strong>IGCSE</strong>：目的是为学生提供广泛的教育，帮助他们发展必要的学习技能，为进一步的学习做好准备。</li>
<li><strong>ALevel</strong>：目的是为学生提供深入的专业知识，帮助他们为大学学习或特定职业领域做准备。</li>
</ul>
</li>
<li><p><strong>国际认可度</strong>：</p>
<ul>
<li><strong>IGCSE</strong> 和 <strong>ALevel</strong>：两者都是国际认可的资格证书，被全球许多大学和雇主接受。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：</p>
<ul>
<li><strong>IGCSE</strong>：学生可以选择的科目范围更广，灵活性较高。</li>
<li><strong>ALevel</strong>：学生需要在较少的科目中选择，但可以在这些科目上进行更深入的学习。</li>
</ul>
</li>
</ol>
<p>总的来说，IGCSE是一个更为基础和广泛的课程，而ALevel则是一个更专业和深入的课程，两者都是英国教育体系中的重要组成部分。</p>
<h2 id="AP"><a href="#AP" class="headerlink" title="AP"></a>AP</h2><p><strong>AP</strong>：Advanced Placement，美国大学预修课程，与IGCSE和ALevel类似，提供高中学生提前学习大学课程的机会。</p>
<p>本篇内容主要以IG与ALevel为主。</p>
<h1 id="学习资源下载"><a href="#学习资源下载" class="headerlink" title="学习资源下载"></a>学习资源下载</h1><h1 id="学习教材的选取与使用"><a href="#学习教材的选取与使用" class="headerlink" title="学习教材的选取与使用"></a>学习教材的选取与使用</h1><h2 id="IG"><a href="#IG" class="headerlink" title="IG"></a>IG</h2><p>这些文件名表明它们是与Cambridge IGCSE Chemistry（剑桥国际普通中等教育证书化学课程）相关的教材和工作簿。以下是每个文件可能的用途：</p>
<ol>
<li><p>《cambridge igcse chemistry by bryan earl and doug wilford》**：一本全面的IGCSE化学教科书，由Bryan Earl和Doug Wilford编写，涵盖了课程的所有主题和概念。</p>
</li>
<li><p>《cambridge igcse chemistry coursebook(fourth edition)》：这是IGCSE化学的课程书，包含了最新的课程内容和教学大纲，适合学生和教师使用。</p>
</li>
<li><p>《cambridge igcse chemistry practical workbook》：IGCSE化学的实验和实践活动，提供了实验指导和相关练习，帮助学生掌握实验技能。</p>
</li>
<li><p>《cambridge igcse chemistry workbook》：包含各种练习题、复习题和例题，用于帮助学生巩固和练习课堂上学到的知识。</p>
</li>
<li><p>《complete chemistry for cambridge igcse》：一个全面的复习指南，涵盖了IGCSE化学的所有主题，适合学生进行全面复习和准备考试。</p>
</li>
<li><p>《igcse chemistry maths skills workbook-sample》：IGCSE化学中的数学技能，如化学计算和数据分析，提供了相关的练习和示例。</p>
</li>
<li><p>《igcse chemistry work book by richard harwood》：这是另一本IGCSE化学工作簿，由Richard Harwood编写，可能包含了一系列的练习题和复习材料，帮助学生准备考试。</p>
</li>
</ol>
<p>选择合适的教材和工作簿可以帮助学生更有效地学习和复习。</p>
<p>在IGCSE化学教学过程中，不同的教材和工作簿有各自的用途和建议：</p>
<ol>
<li><p><strong>教科书</strong>：如《Cambridge IGCSE Chemistry》系列，是学生学习的主要资源，内容详实且符合教学大纲要求。教师应确保学生能够充分理解和掌握教科书中的概念和原理。</p>
</li>
<li><p><strong>课程书</strong>：如《cambridge igcse chemistry coursebook(fourth edition)》提供了课程的详细内容和教学活动，是教师规划课程和学生自学的重要工具。</p>
</li>
<li><p><strong>实践工作簿</strong>：如《cambridge igcse chemistry practical workbook》专注于实验技能的培养，教师应重视实验教学，确保学生有机会进行实践活动，以加深对化学知识的理解。</p>
</li>
<li><p><strong>工作簿</strong>：如《cambridge igcse chemistry workbook》和《igcse chemistry work book by richard harwood》包含练习题和复习材料，用于巩固知识。教师应鼓励学生定期完成工作簿中的练习，以提高解题技能。</p>
</li>
<li><p><strong>复习指南</strong>：如《complete chemistry for cambridge igcse》提供了全面的复习材料，适合学生在考试前进行全面复习。教师可以利用这些资源帮助学生识别和强化薄弱环节。</p>
</li>
<li><p><strong>数学技能工作簿</strong>：如《igcse chemistry maths skills workbook-sample》专注于化学中的数学技能，教师应确保学生能够运用数学技能解决化学问题。</p>
</li>
</ol>
<p>教学建议包括：</p>
<ul>
<li><strong>实验技能的重要性</strong>：实验不仅是理论知识的延伸，也是科学探究的一部分。教师应强调实验安全、数据记录与分析以及团队合作精神。</li>
<li><strong>学习资源与参考书目</strong>：推荐使用权威出版社出版的教科书和在线学习平台，如Khan Academy、Coursera等，以及模拟试卷与练习册。</li>
<li><strong>备考建议</strong>：制定合理的复习计划，结合课堂学习、教科书阅读、做题训练和实验实践，全方位提升化学水平。</li>
</ul>
<p>通过这些资源和建议，教师可以更有效地指导学生，帮助他们在IGCSE化学课程中取得成功。</p>
]]></content>
      <categories>
        <category>化学</category>
        <category>国际化学</category>
      </categories>
      <tags>
        <tag>国际化学</tag>
      </tags>
  </entry>
  <entry>
    <title>微软双拼-键盘示意</title>
    <url>//blog/note/software-use/wei-ruan-shuang-pin.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://api.ihint.me/shuang/">https://api.ihint.me/shuang/</a></p>
<p>【空白键盘】</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvstqowjhtj31v50my77u.jpg "  style="zoom:50%;" />



<p>【微软双拼1】</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvsskvap6sj31690f1acl.jpg "  style="zoom:60%;" />



<p>【微软双拼2】</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hvstqasum9j31sa0s3q6p.jpg "  style="zoom:50%;" />





]]></content>
      <categories>
        <category>笔记</category>
        <category>软件使用教程</category>
      </categories>
      <tags>
        <tag>双拼</tag>
      </tags>
  </entry>
  <entry>
    <title>微软双拼-键盘示意-测试</title>
    <url>//blog/note/software-use/wei-ruan-shuang-pin.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://api.ihint.me/shuang/">https://api.ihint.me/shuang/</a></p>
<p>【空白键盘】</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvstqowjhtj31v50my77u.jpg "  style="zoom:50%;" />



<p>【微软双拼1】</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvsskvap6sj31690f1acl.jpg "  style="zoom:60%;" />



<p>【微软双拼2】</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hvstqasum9j31sa0s3q6p.jpg "  style="zoom:50%;" />





]]></content>
      <categories>
        <category>笔记</category>
        <category>软件使用教程</category>
      </categories>
      <tags>
        <tag>双拼</tag>
      </tags>
  </entry>
  <entry>
    <title>提问的智慧</title>
    <url>//blog/note/mind/How-To-Ask-Questions-The-Smart-Way.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>你所提出问题而获得解答的好坏, 很大程度上取决于你提问的方式与此问题的难度。</p>
<p>本指南将教你如何正确地提问以获得你满意的答案。</p>
<p><strong>以下内容中的<code>&quot;专家&quot;</code>——代指你所求助的对象，默认这类人对你所求助的问题解决经验丰富。</strong></p>
<p>现在 AI 软件已经相当盛行，您通常可以从 AI 那里获得与”专家”一样好的答案，这是件<strong>好事</strong>；和”专家”相比，AI 往往对那些新手常遇到的问题更宽容一些。</p>
<p>在此推荐的方式是<code>从 AI 那里获得有用答案</code>。</p>
<p>首先你应该明白，”专家”们喜爱有挑战性的问题，或者能激发他们思维的好问题。</p>
<p>如果你给了”专家”一个值得反复咀嚼玩味的好问题，”专家”自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高”专家”的理解力，而且通常会暴露”专家”以前从没意识到或者思考过的问题。对”专家”而言，“好问题！”是诚挚的大力称赞。</p>
<p>尽管如此，”专家”们有着蔑视或傲慢面对简单问题的坏名声，这有时让”专家”看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p>
<p>“专家”不忌讳”专家”对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。</p>
<p>那些人是时间杀手 —— 他们只想索取，从不付出，消耗”专家”可用在更有趣的问题或更值得回答的人身上的时间。”专家”称这样的人为 <code>失败者（loser）</code> 。</p>
<p>“专家”意识到许多人只是想得到”专家”的答案 &#x2F; 解决方案，他们对学习技术细节没有兴趣。对大多数人而言，他们有自己的生活并且有更要紧的事要做。”专家”认可这点，也从不指望每个人都对这些让”专家”着迷的技术问题感兴趣。尽管如此，”专家”只为那些真正有兴趣并愿意积极参与问题解决的人而回答问题，这点不会变，也不该变；否则，”专家”会在最擅长的事情上降低效率。</p>
<p>“专家”（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以”专家”无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答<code>赢家（winner）</code>的问题。</p>
<p>如果你厌恶”专家”的态度，高高在上，或过于傲慢，不妨也设身处地想想。<code>&quot;专家&quot;并没有要求你向&quot;专家&quot;屈服</code> —— 事实上，大多数”专家”非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，”专家”就会欢迎你与他们交流。但让”专家”帮助那些不愿意帮助自己的人是没有效率的。<code>无知没有关系，但装白痴就是不行</code>。</p>
<p>&#x3D;&#x3D;所以，你不必在技术上很在行才能吸引”专家”的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。&#x3D;&#x3D;如果你做不到这些使你与众不同的事情，”专家”建议你花点钱寻求付费服务，而不是要求”专家”个人无偿地帮助你。</p>
<p>如果你决定向”专家”求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p>
<h1 id="在提问之前"><a href="#在提问之前" class="headerlink" title="在提问之前"></a>在提问之前</h1><p>在你准备要提出技术问题前，请先做到以下事情：</p>
<ol>
<li><p>尝试像 AI 寻求帮助。 </p>
</li>
<li><p>尝试在你准备提问的论坛的旧文章中搜索答案。</p>
</li>
<li><p>尝试上网搜索以找到答案。</p>
</li>
<li><p>尝试阅读手册以找到答案。</p>
</li>
<li><p>尝试阅读常见问题文件（FAQ）以找到答案。</p>
</li>
<li><p>尝试自己检查或试验以找到答案。</p>
</li>
<li><p>向你身边的强者朋友打听以找到答案。</p>
</li>
</ol>
<p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>获得</strong>的信息会更好，因为”专家”更乐于回答那些表现出能从答案中学习的人的问题。</p>
<p>运用某些策略，比如先用 Google&#x2F;Bing 或者是 AI 搜索你所遇到的问题，这样很可能直接就找到了能解决问题的线索。</p>
<p>即使没有结果，在寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p>
<p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信”专家”，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。在寻求帮助时，展现出你已经尽力去解决问题的态度是非常重要的。&#x3D;&#x3D;如果你只是简单地抛出问题，而没有显示出你已经尝试过自己解决，那么专家可能会觉得你没有认真对待这个问题，从而影响他们回答你问题的积极性。&#x3D;&#x3D;不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。因为这可能会让你的问题显得杂乱无章，难以理解，从而降低得到有效帮助的可能性。</p>
<p>准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p>
<p>小心别问错了问题。如果你的问题基于错误的假设，某个普通”专家”多半会一边在心里想着<code>蠢问题…</code>，一边故意用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p>
<p>绝不要自以为<strong>理所当然</strong>得到答案。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。</p>
<p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p>
<h1 id="当你提问时"><a href="#当你提问时" class="headerlink" title="当你提问时"></a>当你提问时</h1><h2 id="慎选提问的论坛"><a href="#慎选提问的论坛" class="headerlink" title="慎选提问的论坛"></a>慎选提问的论坛</h2><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p>
<ul>
<li>在与主题不合的论坛上贴出你的问题。</li>
<li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li>
<li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li>
<li>向既非熟人也没有义务解决你问题的人发送私人电子邮件。</li>
</ul>
<p>“专家”会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。</p>
<p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p>
<p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个”经验丰富的专家”会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p>
<p>在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p>
<p>别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p>
<p>搞清楚你的主题！</p>
<p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。”专家”较愿意回答那些能帮助到许多人的问题。</p>
<p>老练的”专家”正在接受过多的错发信息，就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经有很多例子了，一些”热心的专家”由于收到大量不堪忍受的”错误问题”而不再提供帮助，故而回复你——“我也不知道”。</p>
<h2 id="如何向-AI-获得有效帮助"><a href="#如何向-AI-获得有效帮助" class="headerlink" title="如何向 AI 获得有效帮助"></a>如何向 AI 获得有效帮助</h2><ul>
<li>确保你的问题清晰无歧义，以减少AI误解的可能性。</li>
<li>如果问题复杂，提供足够的背景信息，帮助AI更好地理解问题。</li>
<li>如果你的问题涉及多个方面，尝试将其分解成几个小问题，逐一提问。</li>
<li>确保你的问题没有歧义，使用准确的词汇来表达你的需求。</li>
<li>将对话视为一个多轮的交流过程，逐步深入问题。</li>
</ul>
<h2 id="使用有意义且描述明确的标题"><a href="#使用有意义且描述明确的标题" class="headerlink" title="使用有意义且描述明确的标题"></a>使用有意义且描述明确的标题</h2><p>大约 50 字以内的问题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动”专家”，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p>
<p>一个好标题范例是<code>目标 —— 差异</code>式的描述。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p>
<blockquote>
<p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p>
</blockquote>
<blockquote>
<p>聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。</p>
</blockquote>
<blockquote>
<p>更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p>
</blockquote>
<p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ </p>
<p>一个”专家”只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p>
<p>总而言之，请想像一下你正在一个只显示标题的存档讨论索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论，而不用再次提问相同的问题。</p>
<p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p>
<p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些站点允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p>
<p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p>
<p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p>
<h2 id="使问题容易回复"><a href="#使问题容易回复" class="headerlink" title="使问题容易回复"></a>使问题容易回复</h2><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，”专家”也觉得花几秒钟思考你的问题更麻烦。</p>
<p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p>
<h3 id="使用清晰、正确、精准且合乎语法的语句"><a href="#使用清晰、正确、精准且合乎语法的语句" class="headerlink" title="使用清晰、正确、精准且合乎语法的语句"></a>使用清晰、正确、精准且合乎语法的语句</h3><p>“专家”从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，”专家”宁愿把时间耗在别处。</p>
<p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那”专家”也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，”专家”文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p>
<p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读）。</p>
<p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/%E5%B0%8F%E7%99%BD">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/%E7%81%AB%E6%98%9F%E6%96%87">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p>
<p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，”专家”通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的”专家”一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p>
<p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p>
<blockquote>
<p>English is not my native language; please excuse typing errors.</p>
</blockquote>
<ul>
<li>英文不是我的母语，请原谅我的错字或语法。</li>
</ul>
<blockquote>
<p>If you speak $LANGUAGE, please email&#x2F;PM me;<br>I may need assistance translating my question.</p>
</blockquote>
<ul>
<li>如果你说<strong>某语言</strong>，请向我发电邮&#x2F;私信；</li>
<li>我需要有人协助我翻译我的问题。</li>
</ul>
<blockquote>
<p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p>
</blockquote>
<ul>
<li>我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。</li>
</ul>
<blockquote>
<p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p>
</blockquote>
<ul>
<li>我把我的问题用<strong>某语言</strong>和英文写出来。</li>
<li>如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。</li>
</ul>
<h2 id="使用易于读取且标准的文件格式发送问题"><a href="#使用易于读取且标准的文件格式发送问题" class="headerlink" title="使用易于读取且标准的文件格式发送问题"></a>使用易于读取且标准的文件格式发送问题</h2><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p>
<ul>
<li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li>
<li>使用 邮件附件 通常是可以的，前提是真正有内容（譬如附带的图片或其他文件），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li>
<li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li>
<li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li>
<li>绝对，<strong>永远</strong>不要指望”专家”们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数”专家”对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li>
<li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li>
<li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li>
</ul>
<p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p>
<h2 id="精确地描述问题并言之有物"><a href="#精确地描述问题并言之有物" class="headerlink" title="精确地描述问题并言之有物"></a>精确地描述问题并言之有物</h2><ul>
<li>仔细、清楚地描述你的问题或 Bug 的症状。</li>
<li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li>
<li>描述在提问前你是怎样去研究和理解这个问题的。</li>
<li>描述在提问前为确定问题而采取的诊断步骤。</li>
<li>描述最近做过什么可能相关的硬件或软件变更。</li>
<li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li>
</ul>
<p>尽量去揣测一个”专家”会怎样反问你，在你提问之前预先将”专家”们可能提出的问题回答一遍。</p>
<p>以上几点中，当你报告的是你认为可能在代码中的问题时，给”专家”一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p>
<p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效地报告Bug</a>》的出色文章。强力推荐你也读一读。</p>
<h2 id="话不在多而在精"><a href="#话不在多而在精" class="headerlink" title="话不在多而在精"></a>话不在多而在精</h2><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的截图或者资料完全复制到你的提问中。</p>
<p>如果你有庞大而复杂的测试样例能重现问题的情境，尽量将它剪裁得越小越好。</p>
<p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p>
<h2 id="别动辄声称找到-Bug"><a href="#别动辄声称找到-Bug" class="headerlink" title="别动辄声称找到 Bug"></a>别动辄声称找到 Bug</h2><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p>
<p>请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#%E5%9C%A8%E6%8F%90%E9%97%AE%E4%B9%8B%E5%89%8D">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p>
<p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p>
<p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p>
<h2 id="低声下气不能代替你的功课"><a href="#低声下气不能代替你的功课" class="headerlink" title="低声下气不能代替你的功课"></a>低声下气不能代替你的功课</h2><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个失败者，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p>
<p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p>
<p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p>
<h2 id="描述问题症状而非你的猜测"><a href="#描述问题症状而非你的猜测" class="headerlink" title="描述问题症状而非你的猜测"></a>描述问题症状而非你的猜测</h2><p>告诉”专家”们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？）</p>
<p>因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让”专家”们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p>
</blockquote>
<p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给”专家”看吧！</p>
<h2 id="按发生时间先后列出问题症状"><a href="#按发生时间先后列出问题症状" class="headerlink" title="按发生时间先后列出问题症状"></a>按发生时间先后列出问题症状</h2><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p>
<p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p>
<p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样”专家”们在读你的记录时就知道该注意哪些内容了。</p>
<h2 id="描述目标而不是过程"><a href="#描述目标而不是过程" class="headerlink" title="描述目标而不是过程"></a>描述目标而不是过程</h2><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p>
<p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p>
<p><strong>蠢问题</strong></p>
<blockquote>
<p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p>
</blockquote>
<p><strong>聪明问题</strong></p>
<blockquote>
<p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p>
</blockquote>
<p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p>
<h2 id="别要求使用私人电邮回复"><a href="#别要求使用私人电邮回复" class="headerlink" title="别要求使用私人电邮回复"></a>别要求使用私人电邮回复</h2><p>“专家”们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p>
<p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。</p>
<p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p>
<h2 id="清楚明确地表达你的问题以及需求"><a href="#清楚明确地表达你的问题以及需求" class="headerlink" title="清楚明确地表达你的问题以及需求"></a>清楚明确地表达你的问题以及需求</h2><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p>
<p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p>
<p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p>
<p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好地理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p>
<h2 id="询问有关代码的问题时"><a href="#询问有关代码的问题时" class="headerlink" title="询问有关代码的问题时"></a>询问有关代码的问题时</h2><p>如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。</p>
<p>只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p>
<p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。</p>
<p>什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。</p>
<p>怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#%E8%AF%9D%E4%B8%8D%E5%9C%A8%E5%A4%9A%E8%80%8C%E5%9C%A8%E7%B2%BE">话不在多而在精</a>一节）。</p>
<p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，”专家”们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p>
<p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p>
<h2 id="别把自己家庭作业的问题贴上来"><a href="#别把自己家庭作业的问题贴上来" class="headerlink" title="别把自己家庭作业的问题贴上来"></a>别把自己家庭作业的问题贴上来</h2><p>“专家”们很擅长分辨哪些问题是家庭作业式的问题；因为”专家”中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p>
<p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的<strong>用户</strong>邮件列表或论坛中提问。尽管”专家”们<strong>会</strong>看出来，但一些有经验的用户也许仍会给你一些提示。</p>
<h2 id="去掉无意义的提问句"><a href="#去掉无意义的提问句" class="headerlink" title="去掉无意义的提问句"></a>去掉无意义的提问句</h2><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p>
<p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p>
<p>其次：由于这样问是画蛇添足，”专家”们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p>
<p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="https://strcat.de/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p>
<h2 id="即使你很急也不要在标题写紧急"><a href="#即使你很急也不要在标题写紧急" class="headerlink" title="即使你很急也不要在标题写紧急"></a>即使你很急也不要在标题写<code>紧急</code></h2><p>这是你的问题，不是”专家”的。宣称<code>紧急</code>极有可能事与愿违：大多数”专家”会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p>
<p>有半个例外的情况是，如果你是在一些很高调，会使”专家”们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p>
<p>当然，这风险很大，因为”专家”们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛茸茸的小海豹！</code>肯定让你被”专家”忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。</p>
<p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p>
<h2 id="礼多人不怪，而且有时还很有帮助"><a href="#礼多人不怪，而且有时还很有帮助" class="headerlink" title="礼多人不怪，而且有时还很有帮助"></a>礼多人不怪，而且有时还很有帮助</h2><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p>
<p>坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。”专家”们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住”专家”是按问题能教给”专家”什么来评价问题的价值的）</p>
<p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p>
<p>（”专家”注意到，自从本指南发布后，从资深”专家”那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些”专家”觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。”专家”的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p>
<h2 id="问题解决后，加个简短的补充说明"><a href="#问题解决后，加个简短的补充说明" class="headerlink" title="问题解决后，加个简短的补充说明"></a>问题解决后，加个简短的补充说明</h2><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p>
<p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>有趣），因此可以利用此时间去解决其它问题。</p>
<p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p>
<p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p>
<p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p>
<p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者”专家”，那就相信”专家”，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；”专家”们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p>
<p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p>
<p>在”专家”中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p>
<h1 id="如何解读答案"><a href="#如何解读答案" class="headerlink" title="如何解读答案"></a>如何解读答案</h1><h2 id="RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="RTFM 和 STFW：如何知道你已完全搞砸了"></a><a href="RTFM">RTFM</a> 和 STFW：如何知道你已完全搞砸了</h2><p>有一个古老而神圣的传统：如果你收到<code>RTFM（Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p>
<p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **<a href="http://lmgtfy.com/">Google 是你的朋友</a>**！）</p>
<p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p>
<p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：</p>
<ul>
<li><strong>你需要的信息非常容易获得</strong>；</li>
<li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li>
</ul>
<p>你不应该因此不爽；<strong>依照”专家”的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p>
<h2 id="如果还是搞不懂"><a href="#如果还是搞不懂" class="headerlink" title="如果还是搞不懂"></a>如果还是搞不懂</h2><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p>
<p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code></p>
<p><strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> </p>
<p><strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p>
<h2 id="处理无礼的回应"><a href="#处理无礼的回应" class="headerlink" title="处理无礼的回应"></a>处理无礼的回应</h2><p>很多”专家”圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p>
<p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在”专家”社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p>
<p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，”专家”们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p>
<p>（有些人断言很多”专家”都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是”专家”，兴许你认为”专家”脑袋有问题还能帮助你应付”专家”的古怪行为。只管这么干好了，”专家”不在乎。”专家”<strong>喜欢</strong>“专家”现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p>
<p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p>
<p>在下一节，”专家”会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p>
<h1 id="如何避免扮演失败者"><a href="#如何避免扮演失败者" class="headerlink" title="如何避免扮演失败者"></a>如何避免扮演失败者</h1><p>在”专家”社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p>
<p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：</p>
<p>熬过去，这很正常。事实上，它是有益健康且合理的。</p>
<p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p>
<p>也有其它的”专家”论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p>
<p>夸张的讲法是：你要的是“友善”（以上述方式）还是“有用”？两个里面挑一个。</p>
<p>记着：当”专家”说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。</p>
<p>对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p>
<p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p>
<p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p>
<p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p>
<h1 id="不该问的问题"><a href="#不该问的问题" class="headerlink" title="不该问的问题"></a>不该问的问题</h1><p>以下是几个经典蠢问题，以及”专家”没回答时心中所想的：</p>
<p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p>
<p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p>
<p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p>
<p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</a></p>
<p>问题：<a href="#q5">我的程序&#x2F;设定&#x2F;SQL 语句没有用</a></p>
<p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p>
<p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p>
<p>问题：<a href="#q9">我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</a></p>
<hr>
<blockquote>
<p>问题：我能在哪找到 X 程序或 X 资源？</p>
</blockquote>
<p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com/">Google</a> 吗？</p>
<blockquote>
<p>问题：我怎样用 X 做 Y？</p>
</blockquote>
<p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p>
<blockquote>
<p>问题：如何设定我的 shell 提示？？</p>
</blockquote>
<p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p>
<p><a id="q4"></a></p>
<blockquote>
<p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p>
</blockquote>
<p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p>
<blockquote>
<p>问题：我的{程序&#x2F;设定&#x2F;SQL 语句}没有用</p>
</blockquote>
<p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p>
<ul>
<li>你还有什么要补充的吗？</li>
<li>真糟糕，希望你能搞定。</li>
<li>这关我屁事？</li>
</ul>
<blockquote>
<p>问题：我的 Windows 电脑有问题，你能帮我吗？</p>
</blockquote>
<p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p>
<p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p>
<blockquote>
<p>问题：我的程序不会动了，我认为系统工具 X 有问题</p>
</blockquote>
<p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p>
<blockquote>
<p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p>
</blockquote>
<p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p>
<p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p>
<blockquote>
<p>问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？</p>
</blockquote>
<p>回答：想要这样做，说明了你是个卑鄙小人；想找个”专家”帮你，说明你是个白痴！</p>
<h1 id="好问题与蠢问题"><a href="#好问题与蠢问题" class="headerlink" title="好问题与蠢问题"></a>好问题与蠢问题</h1><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p>
</blockquote>
<p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p>
</blockquote>
<p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p>
</blockquote>
<p>他觉得都是别人的错，这个傲慢自大的提问者。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p>
</blockquote>
<p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p>
<p><strong>蠢问题</strong>：</p>
<blockquote>
<p>我的主机板有问题了，谁来帮我？</p>
</blockquote>
<p>某”专家”对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p>
<p><strong>聪明问题</strong>：</p>
<blockquote>
<p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p>
</blockquote>
<p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p>
<p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p>
<p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p>
<p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p>
<p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p>
<p>“专家”从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p>
<h1 id="如果得不到回答"><a href="#如果得不到回答" class="headerlink" title="如果得不到回答"></a>如果得不到回答</h1><p>如果仍得不到回答，请不要以为”专家”觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p>
<p>总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p>
<p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p>
<p>有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p>
<p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p>
<p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p>
<h1 id="如何更好地回答问题"><a href="#如何更好地回答问题" class="headerlink" title="如何更好地回答问题"></a>如何更好地回答问题</h1><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p>
<p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p>
<p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p>
<p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p>
<p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了”专家”都曾是新手。</p>
<p>尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p>
<p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p>
<p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p>
<p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p>
<p>如果你在研究一番后才作出了回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p>
<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><ul>
<li><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p>
</li>
<li><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way/blob/main/README-zh_CN.md">提问的智慧</a></li>
<li><a href="https://perrykum.github.io/rtcls/writing/howtoask/howtoask.html">提问的艺术</a></li>
<li><a href="https://github.com/betaseeker/How-To-Ask-Questions">如何在群里提问</a></li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/undefined</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h1><ul>
<li>识别考点</li>
<li>回忆方法</li>
<li>应用解题</li>
<li>总结回顾</li>
<li>迁移拓展</li>
</ul>
<img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hup7dewyc0j31680f1ta8.jpg "  style="zoom:50%;" />

<h2 id="识别考点"><a href="#识别考点" class="headerlink" title="识别考点"></a>识别考点</h2><img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hup7dppefej311g04it9d.jpg "  style="zoom:50%;" />



<h2 id="回忆方法"><a href="#回忆方法" class="headerlink" title="回忆方法"></a>回忆方法</h2><img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hup7e5szzcj317l08kjtw.jpg "  style="zoom:50%;" />





<h2 id="应用解题"><a href="#应用解题" class="headerlink" title="应用解题"></a>应用解题</h2><img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hup7fbelvlj3110087q47.jpg "  style="zoom:50%;" />



<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hup7ft12dsj311d08dgok.jpg "  style="zoom:50%;" />



<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hup7g6dqwoj30ty03f74h.jpg "  style="zoom:50%;" />



<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hup7h4i6axj310n0bzq6m.jpg "  style="zoom:50%;" />

<h2 id="总结回顾"><a href="#总结回顾" class="headerlink" title="总结回顾"></a>总结回顾</h2><img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hup7huz8p2j314n08uq4w.jpg "  style="zoom:50%;" />



<h2 id="迁移拓展"><a href="#迁移拓展" class="headerlink" title="迁移拓展"></a>迁移拓展</h2><img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hup7ir8ro4j314l08ajt4.jpg "  style="zoom:50%;" />









]]></content>
  </entry>
  <entry>
    <title>如何获取驾驶证</title>
    <url>//blog/note/getlicense/driving-license.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>&#x3D;&#x3D;【相关文件】&#x3D;&#x3D;</p>
<p><a href="https://www.mps.gov.cn/n6557558/c8281680/content.html">机动车驾驶证申领和使用规定</a></p>
<p><a href="https://xxgk.mot.gov.cn/2020/gz/202210/t20221008_3691619.html">机动车驾驶员培训管理规定</a></p>
<p><a href="https://jtgl.beijing.gov.cn/jgj/jgxx/flfg/fl/205308/index.html">中华人民共和国道路交通安全法</a></p>
<p><a href="https://www.gov.cn/gongbao/content/2022/content_5682413.htm">机动车登记规定</a></p>
<p><a href="https://www.gov.cn/gongbao/content/2022/content_5679697.htm">道路交通安全违法行为记分管理办法</a></p>
<hr>
<h1 id="科目一"><a href="#科目一" class="headerlink" title="科目一"></a>科目一</h1><p>道路交通安全法律、法规和相关知识考试。</p>
<p>驾照科目一考试范围主要包括以下几个方面：</p>
<ol>
<li><p><strong>道路交通安全法律、法规和规章</strong>：包括中华人民共和国道路交通安全法及实施条例，涉及到灯光、喇叭的使用，有划分车道的道路通行，无划分车道的道路通行，交叉路口通行，变更车道，机动车限速通行，跟车与限制超车，会车规定，铁路道口及渡口通行，避让行人和非机动车，掉头与倒车等内容。</p>
</li>
<li><p><strong>交通信号</strong>：包括道路交通信号灯、道路交通标志、道路交通标线和交通警察手势等，要求考生熟练掌握各类道路交通信号的种类、识别和作用。</p>
</li>
<li><p><strong>安全行车、文明驾驶基础知识</strong>：包括驾驶行为要求，驾驶人对所驾车辆应负的安全责任，避让特种车辆，避让道路养护作业车辆，机动车停车，高速公路安全行驶等内容。</p>
</li>
<li><p><strong>机动车驾驶操作相关基础知识</strong>：包括仪表与指示灯、操纵装置、安全装置等，要求考生掌握机动车主要仪表、指示灯和操纵、安全装置的基本知识。</p>
</li>
<li><p><strong>地方性法规</strong>：根据地方性法规选定的重点内容，要求考生掌握地方性法规的重点内容。</p>
</li>
<li><p><strong>违法行为处罚</strong>：掌握主要交通安全违法行为情形、法律责任的基本知识、驾驶机动车禁止行为。</p>
</li>
<li><p><strong>驾驶证申领规定</strong>：包括驾驶证申领年龄规定，初次申领规定，驾驶证补换领等都是常考的内容。</p>
</li>
</ol>
<p>科目一考试总时间为45分钟，考试试卷由100道题目组成，题型为判断题和单项选择题，满分100分，90分合格。考试内容涵盖了驾车理论基础、道路安全法律法规、地方性法规等相关知识。</p>
<p>【我的易错题】</p>
<ol>
<li><p>《机动车驾驶证申领和使用规定》第十三：机动车驾驶证有效期分为六年、十年和长期。</p>
</li>
<li><p>交通警察只能扣留车辆，不能对人进行拘留。</p>
</li>
<li><p>申请小型汽车准驾车型驾驶证的人年龄在18周岁以上，无年龄上限。只是70岁的人每年要交体检报告。</p>
</li>
<li><p>换证90,合格60,审验30,调解10天。</p>
</li>
<li><p>大型客车、重型牵引挂车、城市公交车、中型客车、大型货车驾驶人若一个记分周期内有记分的，应当在一年一次审验时提交身体条件证明；若没有记分，则不必审验。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第八条：驾驶机动车在高速公路、城市快速路上倒车、逆行、穿越中央分隔带掉头的，一次记12分。（普通道路逆行记3分）</p>
</li>
<li><p>对于获取驾驶证，作弊未遂1年，作弊成功3年。（假一吊二撤三毒三罪五逃终生）</p>
</li>
<li><p>自愿降级的驾驶人需要到车辆管理所申请换领驾驶证。（为什么会自愿降级呢？因为越高级的驾照，定期审验的要求也越高，如果你用不到，还是自愿降级吧。）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十一条：在道路上车辆发生故障、事故停车后，不按规定使用灯光或者设置警告标志的，一次记3分。（正常驾驶不按规定使用灯光扣1， 故障后不按规定扣3）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》规定：机动车驾驶人在一个记分周期内二次累积记分满12分或累积记分满24分但未满36分的，应当在道路交通安全法律、法规和相关知识考试（科目1）合格后，参加道路驾驶技能考试（科目3）。（如果扣分满了36分，那就科1、2、3全部重考）</p>
</li>
<li><p>补驾驶证是核发地（最初领取驾驶证的地方）；换驾驶证是居住地；行驶证是登记地。【如果您的<strong>驾驶证遗失或损坏需要补办</strong>，您需要到驾驶证的核发地车辆管理所进行申请补发。（毕竟当初是A车辆管理所受理的事务，B车辆管理所没有权限）】【当您的<strong>驾驶证到期需要更换，或者您的个人信息发生变化</strong>需要更新驾驶证信息时，您可以在您的居住地车辆管理所申请换证（因为你现在居住地信息变化了，当然是在居住地办理咯！）】【<strong>行驶证</strong>是与车辆相关的证件，如果您的行驶证遗失、损毁或者需要变更车辆信息，您需要到车辆的登记地车辆管理所进行补发或变更，登记地是指车辆注册登记的地方，也就是车辆牌照发放地。（你车辆注册登记的地方有权限决定这辆车能不能在当地开）】</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第八条：使用伪造、变造的机动车号牌、行驶证、驾驶证、校车标牌或者使用其他机动车号牌、行驶证的，一次记12分。（假照扣12，遮挡无照扣9分）。</p>
</li>
<li><p>初次申领驾照<strong>不能</strong>申领“牵引车”。（要先开小车一年后申请增驾）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》规定：驾驶机动车不按规定会车，或者在<strong>高速公路、城市快速路以外</strong>的道路上不按规定倒车、掉头的，一次记1分。（会车1分 倒车1分 掉头1分 ，不让、逆行、超速3分 仅限普通道路口）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十一条：驾驶机动车在<strong>高速公路或者城市快速路</strong>上<strong>不按规定车道</strong>行驶的，一次记3分。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第八条：驾驶机动车在<strong>高速公路、城市快速路</strong>上<strong>倒车、逆行、穿越中央分隔带掉头</strong>的，一次记12分。</p>
</li>
<li><p>一般道路：会车，倒车，掉头扣一分； 不让行，逆行，超车扣三分 。</p>
</li>
<li><p>高速路：倒车，逆行，掉头扣十二分。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十一条：驾驶机动车遇前方机动车停车排队或者缓慢行驶时，借道超车或者占用对面车道、穿插等候车辆的，一次记3分。（<strong>占用对面车道扣3分 ，占用应急车道扣6分</strong>）</p>
</li>
<li><p><strong>一个以外扣9分</strong>：指的是驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速50%以上的，一次记9分。（中型汽车普路超速50%扣9分）</p>
</li>
<li><p><strong>两个以外扣六分</strong>：指的是驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路以外的道路上行驶超过规定时速50%以上的，一次记6分。</p>
</li>
<li><p>道路交通安全违法行为记分管理办法》第十条：驾驶机动车不按交通信号灯指示通行的，一次记6分。（闯红灯6分；不规范使用车灯1分）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十四条：机动车驾驶人<strong>可以一次性处理完毕同一辆机动车</strong>的多起交通违法行为记录，记分分值累积计算。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第二十六条：机动车驾驶人申请接受交通安全教育扣减交通违法行为记分的，机动车驾驶证在实习期内，或者机动车驾驶证逾期未审验，或者机动车驾驶证被扣留、暂扣期间的不予受理。（实习期期间的记分，不可以通过学法减分扣减。这个时期的驾驶人驾驶经验不足，对交通规则的掌握可能还不够熟练，因此需要更加严格的管理和监督）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十八条：机动车驾驶人在一个记分周期内累积记分满12分的，应当参加为期七天的道路交通安全法律、法规和相关知识学习。（<strong>扣完12分，学习一周</strong>）</p>
</li>
<li><p>《机动车登记规定》规定：机动车所有权转让后，现机动车所有人未在机动车交付之日起三十日内向登记地车辆管理所申请转让登记的，由公安机关交通管理部门处警告或者二百元以下罚款。（看到一千就全错，看到200就选✓）。</p>
</li>
<li><p><strong>一个记分周期内三次以上累积记分满12分</strong>（即累积扣满36分），这种情况机动车驾驶人应当在道路交通安全法律、法规和相关知识考试合格后，按照《机动车驾驶证申领和使用规定》参加场地驾驶技能（科目2）和道路驾驶技能考试（科目3）。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十条：驾驶机动车载运爆炸物品、易燃易爆化学物品以及剧毒、放射性等危险物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志并采取必要的安全措施的，一次记6分。（<strong>三个危险物品找6</strong>）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十二条：驾驶机动车载货长度、宽度、高度超过规定的，一次记1分。（长宽高超过规定的扣1分）</p>
</li>
<li><p>《机动车驾驶证申领和使用规定》：代替实际机动车驾驶人参加审验教育的，由公安机关交通管理部门处二千元以下罚款。<strong>（自己作弊1000 他人代替2000 组织罚两万）</strong></p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》规定：驾驶校车、公路客运汽车、旅游客运汽车、7座以上载客汽车以外的其他载客汽车载人超过核定人数百分之五十以上未达到百分之百的，一次记6分。（七座以上6-9-12 ，七座以下3-6-12）（20%<del>50%，50%</del>100%，&gt;100%）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十一条：驾驶机动车不按规定避让校车的，一次记3分。（不礼让校车和人扣三分，闯红灯扣六分）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十二条：驾驶机动车在道路上行驶时，机动车驾驶人未按规定系安全带的，一次记1分。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十九条：机动车驾驶人参加现场学习、网络学习的天数累计不得少于五天，其中，现场学习的天数不得少于二天。（<strong>网5现2</strong>）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》规定：行政处罚决定被依法变更或者撤销的，相应记分应当变更或者撤销。</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》第十条：驾驶载货汽车载物超过最大允许总质量百分之五十以上的，一次记6分。（<strong>30%扣一分，30%~50%或货车载客扣三分，50%以上扣六分</strong>）（校车人数超20%就扣12）</p>
</li>
<li><p>《道路交通安全违法行为记分管理办法》中提到的“机动车驾驶人有二起以上交通违法行为的应当予以分别记分，记分分值要累加计算”意味着，如果一个驾驶人有多项交通违法行为需要记分，那么这些违法行为的记分不是单独计算的，而是要加在一起计算总和。具体来说：</p>
<ol>
<li><p><strong>分别记分</strong>：每一项交通违法行为都会根据其违法行为的性质和严重程度，按照规定记相应的分数。</p>
</li>
<li><p><strong>累积计算</strong>：不是单独处理每一项违法行为的记分，而是将所有违法行为的记分加在一起。如果一个驾驶人有多个违法行为，那么这些违法行为的记分将会累加。</p>
</li>
<li><p><strong>一次性处理</strong>：驾驶人可以一次性处理同一辆机动车的多起交通违法行为记录，这些违法行为的记分将会累加计算。</p>
</li>
<li><p><strong>记分周期</strong>：记分周期为12个月，满分为12分。如果在一个记分周期内累积记分未满12分，那么在周期届满时，该周期内的记分将被清除。但如果有罚款逾期未缴纳，那么未缴纳罚款的违法行为的记分将转入下一记分周期。</p>
</li>
</ol>
<p>这样的规定是为了加强对驾驶人遵守交通规则的约束，通过累积记分制度来增加违法成本，促使驾驶人提高交通安全意识，减少违法行为，从而预防和减少交通事故的发生。</p>
<ol start="38">
<li>《机动车驾驶证申领和使用规定》：初次领证的驾驶人在12个月的实习期内驾驶机动车上高速公路行驶，必须有<strong>三年以上驾龄的司机</strong>陪同，否则将处以计分罚款，并由交警带离高速公路。</li>
<li>《机动车驾驶证申领和使用规定》第十四条：申请城市公交车、中型客车、大型货车、轻型牵引挂车、无轨电车或者有轨电车准驾车型的，在20周岁以上，60周岁以下。（大客 重牵挂22-60 ；中客 大货20-60）</li>
<li>《中华人民共和国道路交通安全法》第十一条：驾驶机动车上道路行驶，应当悬挂机动车号牌，放置检验合格标志、保险标志，并随车携带机动车行驶证。</li>
<li>机动车驾驶证申领和使用规定》第四十七条 ：在学习驾驶证明有效期内，科目二和科目三道路驾驶技能考试预约考试的次数分别不得超过五次第五次考试仍不合格的，已考试合格的其他科目成绩作废。（3年内必须考完）</li>
<li>《机动车驾驶证申领和使用规定》第六十四条：机动车驾驶人户籍迁出原车辆管理所管辖区的，应当向迁入地车辆管理所申请换证。（去哪找哪）</li>
<li>《机动车驾驶证申领和使用规定》第七十二条：机动车驾驶人按照本规定第六十三条、第六十四条换领机动车驾驶证时，应当接受公安机关交通管理部门的审验。（有效期满，户籍迁出要接受审验）</li>
<li>《机动车驾驶证申领和使用规定》第七十五条：机动车驾驶人因服兵役、出国（境）等原因，无法在规定时间内办理驾驶证期满换证、审验、提交身体条件证明的，可以在驾驶证有效期内或者有效期届满一年内向机动车驾驶证核发地车辆管理所申请延期办理。申请时应当确认申请信息，并提交机动车驾驶人的身份证明。延期期限最长不超过<strong>三年</strong>。</li>
</ol>
</li>
</ol>
<hr>
<h1 id="科目二"><a href="#科目二" class="headerlink" title="科目二"></a>科目二</h1><p>场地驾驶技能考试科目。</p>
<h1 id="科目三"><a href="#科目三" class="headerlink" title="科目三"></a>科目三</h1><p>科目三包括道路驾驶技能和安全文明驾驶常识考试科目。其中安全文明驾驶常识考试科目俗称科目四，实际上包含在科目三中。</p>
<h1 id="科目四"><a href="#科目四" class="headerlink" title="科目四"></a>科目四</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>证件获取</category>
      </categories>
      <tags>
        <tag>证件获取</tag>
      </tags>
  </entry>
  <entry>
    <title>Base64 编码</title>
    <url>//blog/note/code/AutoXjs/base64.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a><a href="http://doc.autoxjs.com/#/base64?id=base64%e7%bc%96%e7%a0%81">Base64编码</a></h2><p>提供基本的 Base64 转换函数。</p>
<h2 id="base64-encode-str-encoding-‘utf-8’"><a href="#base64-encode-str-encoding-‘utf-8’" class="headerlink" title="$base64.encode(str[, encoding &#x3D; ‘utf-8’)"></a><a href="http://doc.autoxjs.com/#/base64?id=base64encodestr-encoding-39utf-839">$base64.encode(str[, encoding &#x3D; ‘utf-8’)</a></h2><ul>
<li><code>str</code> {string} 要编码的字符串</li>
<li><code>encoding</code> {string} 可选，字符编码</li>
</ul>
<p>将字符串str <code>autox.js</code> 使用Base64编码并返回编码后的字符串。</p>
<pre><code>log($base64.encode(&quot;autox.js&quot;));
// 日志输出 YXV0b3gunM=
</code></pre>
<h2 id="base64-decode-str-encoding-‘utf-8’"><a href="#base64-decode-str-encoding-‘utf-8’" class="headerlink" title="$base64.decode(str[, encoding &#x3D; ‘utf-8’])"></a><a href="http://doc.autoxjs.com/#/base64?id=base64decodestr-encoding-39utf-839">$base64.decode(str[, encoding &#x3D; ‘utf-8’])</a></h2><ul>
<li><code>str</code> {string} 要解码的字符串</li>
<li><code>encoding</code> {string} 可选，字符编码</li>
</ul>
<p>将字符串st <code>YXV0b3gunM=</code> r使用Base64解码并返回解码后的字符串。</p>
<pre><code>log($base64.decode(&quot;YXV0b3gunM&quot;));
// 日志输出 autox.js
</code></pre>
<p>[</p>
<p>上一页</p>
<p>事件与监听 - Events</p>
<p>高级</p>
<p>](<a href="http://doc.autoxjs.com/#/events">http://doc.autoxjs.com/#/events</a>)</p>
<p>[</p>
<p>下一页</p>
<p>消息处理(加密、摘要) - Crypto</p>
<p>高级</p>
<p>](<a href="http://doc.autoxjs.com/#/crypto">http://doc.autoxjs.com/#/crypto</a>)</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>webview 与 HTML</title>
    <url>//blog/note/code/AutoXjs/webview-html.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="WebView-与-HTML"><a href="#WebView-与-HTML" class="headerlink" title="WebView 与 HTML"></a><a href="http://doc.autoxjs.com/#/webViewAndHtml?id=webview-%e4%b8%8e-html">WebView 与 HTML</a></h1><h2 id="WebView-与-HTML-1"><a href="#WebView-与-HTML-1" class="headerlink" title="WebView 与 HTML"></a><a href="http://doc.autoxjs.com/#/webViewAndHtml?id=webview-%e4%b8%8e-html">WebView 与 HTML</a></h2><h2 id="JsBridge"><a href="#JsBridge" class="headerlink" title="*JsBridge"></a><a href="http://doc.autoxjs.com/#/webViewAndHtml?id=jsbridge">*JsBridge</a></h2><p>v6.3.9新增<br>html&gt;&gt;</p>
<pre><code>&lt;html&gt;
  &lt;body style=&quot;font: size 2em&quot;&gt;
    &lt;div style=&quot;font-size: 100px&quot;&gt;原内容&lt;/div&gt;
    &lt;!-- 导入依赖包，也可以不加，不过需要监听AutoxJsBridgeReady事件后才能使用$autox --&gt;
    &lt;script src=&quot;autox://sdk.v1.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
      function addText(text) &#123;
        const div = document.createElement(&quot;div&quot;);
        div.innerHTML = text;
        document.body.appendChild(div);
      &#125;
      //注册一个监听函数
      $autox.registerHandler(&quot;jsTest&quot;, (data, callBack) =&gt; &#123;
        addText(`来自安卓调用，data=$&#123;data&#125;`);
        setTimeout(() =&gt; &#123;
          //回调安卓
          callBack(&quot;web回调数据&quot;);
        &#125;, 1000);
      &#125;);
      //调用安卓端
      $autox.callHandler(&quot;test&quot;, &quot;web调用数据&quot;, (data) =&gt; &#123;
        addText(&quot;安卓回调, data:&quot; + data);
      &#125;);

      document.addEventListener(&quot;AutoxJsBridgeReady&quot;, () =&gt; &#123;
        //$autox.
      &#125;);
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>js代码</p>
<pre><code>&quot;ui&quot;;

ui.layout(`
    &lt;vertical&gt;
        &lt;webview id=&quot;web&quot; h=&quot;*&quot;/&gt;
    &lt;/vertical&gt;`)

ui.web.loadUrl(&quot;file://&quot; + files.path(&quot;./网页.html&quot;))
/*
    注意：在web与安卓端传递的数据只能是字符串，其他数据需自行使用JSON序列化
    在调用callHandler时传入了回调函数，但web端没有调用则会造成内存泄露。
    jsBridge自动注入依赖于webViewClient，如设置了自定义webViewClient则需要在合适的时机（页面加载完成后）调用webview.injectionJsBridge()手动注入
*/
//注册一个监听函数
ui.web.jsBridge.registerHandler(&quot;test&quot;, (data, callBack) =&gt; &#123;
    toastLog(&quot;web调用安卓,data:&quot; + data)
    setTimeout(() =&gt; &#123;
        //回调web
        callBack(&quot;1155&quot;)
    &#125;, 2000)
&#125;)
//定时器中等待web加载完成
setTimeout(() =&gt; &#123;
    ui.web.jsBridge.callHandler(&#39;jsTest&#39;, &#39;数据&#39;, (data) =&gt; &#123;
        toastLog(&#39;web回调,data:&#39; + data)
    &#125;)
&#125;, 1000)
</code></pre>
<h2 id="纯js实现"><a href="#纯js实现" class="headerlink" title="纯js实现"></a><a href="http://doc.autoxjs.com/#/webViewAndHtml?id=%e7%ba%afjs%e5%ae%9e%e7%8e%b0">纯js实现</a></h2><pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical&gt;
        &lt;horizontal bg=&quot;#c7edcc&quot; gravity=&quot;center&quot; h=&quot;auto&quot;&gt;
            &lt;button text=&quot;网络冲浪&quot; id=&quot;surfInternetBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt;
            &lt;button text=&quot;记忆翻牌&quot; id=&quot;loadLocalHtmlBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt;
            &lt;button text=&quot;控制台&quot; id=&quot;consoleBtn&quot; style=&quot;Widget.AppCompat.Button.Colored&quot; w=&quot;auto&quot; /&gt;
        &lt;/horizontal&gt;
        &lt;vertical h=&quot;*&quot; w=&quot;*&quot;&gt;
            &lt;webview id=&quot;webView&quot; layout_below=&quot;title&quot; w=&quot;*&quot; h=&quot;*&quot; /&gt;
        &lt;/vertical&gt;
    &lt;/vertical&gt;
);

function callJavaScript(webViewWidget, script, callback) &#123;
    try &#123;
        console.assert(webViewWidget != null, &quot;webView控件为空&quot;);
        //console.log(script.toString())
        webViewWidget.evaluateJavascript(&quot;javascript:&quot; + script, new JavaAdapter(android.webkit.ValueCallback, &#123;
            onReceiveValue: (val) =&gt; &#123;
                if (callback) &#123;
                    callback(val);
                &#125;
            &#125;
        &#125;));
    &#125; catch (e) &#123;
        console.error(&quot;执行JavaScript失败&quot;);
        console.trace(e);
    &#125;
&#125;

function AutoX() &#123;
    let getAutoXFrame = () =&gt; &#123;
        let bridgeFrame = document.getElementById(&quot;AutoXFrame&quot;);
        if (!bridgeFrame) &#123;
            bridgeFrame = document.createElement(&#39;iframe&#39;);
            bridgeFrame.id = &quot;AutoXFrame&quot;;
            bridgeFrame.style = &quot;display: none&quot;;
            document.body.append(bridgeFrame);
        &#125;
        return bridgeFrame;
    &#125;;
    const h5Callbackers = &#123;&#125;;
    let h5CallbackIndex = 1;
    let setCallback = (callback) =&gt; &#123;
        let callId = h5CallbackIndex++;
        h5Callbackers[callId] = &#123;
            &quot;callback&quot;: callback
        &#125;;
        return callId;
    &#125;;
    let getCallback = (callId) =&gt; &#123;
        let callback = h5Callbackers[callId];
        if (callback) &#123;
            delete h5Callbackers[callId];
        &#125;
        return callback;
    &#125;;

    function invoke(cmd, params, callback) &#123;
        let callId = null;
        try &#123;
            let paramsStr = JSON.stringify(params);
            let AutoXFrame = getAutoXFrame();
            callId = setCallback(callback);
            AutoXFrame.src = &quot;jsbridge://&quot; + cmd + &quot;/&quot; + callId + &quot;/&quot; + encodeURIComponent(paramsStr);
        &#125; catch (e) &#123;
            if (callId) &#123;
                getCallback(callId);
            &#125;
            console.trace(e);
        &#125;
    &#125;;
    let callback = (data) =&gt; &#123;
        let callId = data.callId;
        let params = data.params;
        let callbackFun = getCallback(callId);
        if (callbackFun) &#123;
            callbackFun.callback(params);
        &#125;
    &#125;;
    return &#123;
        invoke: invoke,
        callback: callback
    &#125;;
&#125;;
function bridgeHandler_handle(cmd, params) &#123;
    console.log(&#39;bridgeHandler处理 cmd=%s, params=%s&#39;, cmd, JSON.stringify(params));
    let fun = this[cmd];
    if (!fun) &#123;
        throw new Error(&quot;cmd= &quot; + cmd + &quot; 没有定义实现&quot;);
    &#125;
    let ret = fun(params)
    return ret;
&#125;
function mFunction(params) &#123;
    toastLog(params.toString());
    device.vibrate(120);
    return files.isDir(&#39;/storage/emulated/0/Download&#39;)//&#39;toast提示成功&#39;;
&#125;
function webViewExpand_init(webViewWidget) &#123;
    webViewWidget.webViewClient = new JavaAdapter(android.webkit.WebViewClient, &#123;
        onPageFinished: (webView, curUrl) =&gt; &#123;
            try &#123;
                // 注入 AutoX
                callJavaScript(webView, AutoX.toString() + &quot;;var auto0 = AutoX();auto0.invoke(&#39;mFunction&#39;,&#39;This is AutoX!&#39;,(data) =&gt; &#123;console.log(&#39;接收到callback1:&#39; + JSON.stringify(data));&#125;);&quot;, null);
            &#125; catch (e) &#123;
                console.trace(e)
            &#125;
        &#125;,
        shouldOverrideUrlLoading: (webView, request) =&gt; &#123;
            let url = &#39;&#39;;
            try &#123;
                url = (request.a &amp;&amp; request.a.a) || (request.url);
                if (url instanceof android.net.Uri) &#123;
                    url = url.toString();
                &#125;
                if (url.indexOf(&quot;jsbridge://&quot;) == 0) &#123;
                    let uris = url.split(&quot;/&quot;);
                    let cmd = uris[2];
                    let callId = uris[3];
                    let params = java.net.URLDecoder.decode(uris[4], &quot;UTF-8&quot;);
                    console.log(&#39;AutoX处理JavaScript调用请求: callId=%s, cmd=%s, params=%s&#39;, callId, cmd, params);
                    let result = null;
                    try &#123;
                        result = bridgeHandler_handle(cmd, JSON.parse(params));
                    &#125; catch (e) &#123;
                        console.trace(e);
                        result = &#123;
                            message: e.message
                        &#125;;
                    &#125;
                    result = result || &#123;&#125;;
                    webView.loadUrl(&quot;javascript:auto0.callback(&#123;&#39;callId&#39;:&quot; + callId + &quot;, &#39;params&#39;: &quot; + JSON.stringify(result) + &quot;&#125;);&quot;);
                &#125; else if (url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;) || url.startsWith(&quot;file://&quot;) || url.startsWith(&quot;ws://&quot;) || url.startsWith(&quot;wss://&quot;)) &#123;
                    webView.loadUrl(url);
                &#125; else &#123;
                &#125;
                return true;
            &#125; catch (e) &#123;
                if (e.javaException instanceof android.content.ActivityNotFoundException) &#123;
                    webView.loadUrl(url);
                &#125; else &#123;
                    toastLog(&#39;无法打开URL: &#39; + url);
                &#125;
                console.trace(e);
            &#125;
        &#125;,
        onReceivedError: (webView, webResourceRequest, webResourceError) =&gt; &#123;
            let url = webResourceRequest.getUrl();
            let errorCode = webResourceError.getErrorCode();
            let description = webResourceError.getDescription();
            console.trace(errorCode + &quot; &quot; + description + &quot; &quot; + url);
        &#125;
    &#125;);
    webViewWidget.webChromeClient = new JavaAdapter(android.webkit.WebChromeClient, &#123;
        onConsoleMessage: (msg) =&gt; &#123;
            console.log(&quot;[%s:%s]: %s&quot;, msg.sourceId(), msg.lineNumber(), msg.message());
        &#125;
    &#125;);
&#125;
webViewExpand_init(ui.webView)
ui.webView.loadUrl(&quot;https://wht.im&quot;);

ui.surfInternetBtn.on(&quot;click&quot;, () =&gt; &#123;
    webViewExpand_init(ui.webView);
    ui.webView.loadUrl(&quot;https://wht.im&quot;);
&#125;);
ui.consoleBtn.on(&quot;click&quot;, () =&gt; &#123;
    app.startActivity(&quot;console&quot;);
&#125;);
ui.loadLocalHtmlBtn.on(&#39;click&#39;, () =&gt; &#123;
    webViewExpand_init(ui.webView);
    let path = &quot;file:&quot; + files.path(&quot;game.html&quot;);
    ui.webView.loadUrl(path);
&#125;);
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>axios</title>
    <url>//blog/note/code/AutoXjs/axios.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a><a href="http://doc.autoxjs.com/#/axios?id=axios">axios</a></h1><h2 id="axios-1"><a href="#axios-1" class="headerlink" title="axios"></a><a href="http://doc.autoxjs.com/#/axios?id=axios">axios</a></h2><p>v6.3.9新增</p>
<blockquote>
<p>稳定性: 实验</p>
</blockquote>
<p><strong>注意</strong>: 这个模块是异步的，返回的全部都是<code>Promise</code>，如果你的程序有大量阻塞函数，请谨慎使用 这个模块不会自动加载，如需使用，请用</p>
<pre><code>const axios = require(&#39;axios&#39;);
</code></pre>
<p>模块使用方法与axios完全一致，请参阅<a href="https://www.axios-http.cn/docs/intro">官方网站</a>，以下只介绍一些在autox中特有的内容。</p>
<p>这个模块通过模拟浏览器关键对象<code>XMLHttpRequest</code>得以运行，内部使用okhttp进行网络请求，行为与浏览器中有些许差异。</p>
<p>不支持的内容:</p>
<ul>
<li><code>ArrayBuffer</code> 不支持处理和解析</li>
<li><code>XMLHttpRequest.overrideMimeType()</code></li>
<li><code>XMLHttpRequest.timeout</code> 暂不支持设置</li>
<li>上传和下载进度事件</li>
</ul>
<p>支持的<code>responseType</code>:</p>
<ul>
<li><code>text</code></li>
<li><code>json</code></li>
<li><code>blob</code></li>
<li><code>inputstream</code> java输入流</li>
<li><code>stream</code> Readable可读流 *v6.4.0新增</li>
</ul>
<p>支持的请求体数据类型:</p>
<ul>
<li><code>RequestBody</code> okhttp3.RequestBody对象</li>
<li><code>FormData</code></li>
<li><code>Blob</code></li>
<li><code>InputStream</code> java输入流</li>
<li><code>String</code></li>
<li><code>plain object</code> 会解析成json</li>
</ul>
<p>一个简单的示例</p>
<pre><code>const axios = require(&quot;axios&quot;);
const FormData = axios.browser.FormData;

/*
  下载文件
*/
axios(&#39;https://m.baidu.com&#39;, &#123;
    responseType: &#39;blob&#39;
&#125;).then((res) =&gt; &#123;
    const blob = res.data
    log(&#39;blob:&#39;, blob);
    //保存blob
    //return axios.utils.saveBlobToFile(blob, savePath)
&#125;).then(() =&gt; &#123;
    log(&#39;下载成功&#39;)
&#125;).catch(console.error)
</code></pre>
<p>​<br>​    &#x2F;*<br>​      使用表单<br>​    <em>&#x2F;<br>​    let form &#x3D; new FormData()<br>​    form.set(‘a’, ‘b’)<br>​    form.append(‘b’, ‘123’)<br>​    form.append(‘b’, ‘测试’)<br>​    axios.post(‘<a href="http://baidu.com/">http://baidu.com</a>‘, form).then(function (res) {<br>​        log(‘请求成功1’);<br>​    }).catch(console.error)<br>​<br>    &#x2F;</em><br>      使用表单上传文件<br>    *&#x2F;<br>    let blob &#x3D; axios.utils.openFile(‘.&#x2F;使用axios.js’)</p>
<pre><code>form.enctype = &#39;multipart/form-data&#39;
form.set(&#39;file&#39;, blob)
axios.post(&#39;http://baidu.com&#39;, form).then(function (res) &#123;
    log(&#39;请求成功2&#39;);
&#125;).catch(console.error)

/*
  也可以使用直接传输
*/
axios.post(&#39;http://baidu.com&#39;, blob).then(function (res) &#123;
    log(&#39;请求成功3&#39;);
&#125;).catch(console.error)
</code></pre>
<h2 id="axios-browser"><a href="#axios-browser" class="headerlink" title="axios.browser"></a><a href="http://doc.autoxjs.com/#/axios?id=axiosbrowser">axios.browser</a></h2><p>用于模拟浏览器环境的对象，包含<code>XMLHttpRequest</code>、<code>FormData</code>等，除了<code>FormData</code>，其他对象都不建议使用。</p>
<h2 id="axios-utils"><a href="#axios-utils" class="headerlink" title="axios.utils"></a><a href="http://doc.autoxjs.com/#/axios?id=axiosutils">axios.utils</a></h2><p>包含一些操作blob对象方法</p>
<h3 id="utils-saveBlobToFile-blob-path"><a href="#utils-saveBlobToFile-blob-path" class="headerlink" title="utils.saveBlobToFile(blob, path)"></a><a href="http://doc.autoxjs.com/#/axios?id=utilssaveblobtofileblob-path">utils.saveBlobToFile(blob, path)</a></h3><ul>
<li><code>blob</code> {Blob} 要保存的对象</li>
<li><code>path</code> {String} 保存路径</li>
</ul>
<p>保存blob对象到指定路径，返回一个<code>Promise</code>。</p>
<h3 id="utils-openFile-path"><a href="#utils-openFile-path" class="headerlink" title="utils.openFile(path)"></a><a href="http://doc.autoxjs.com/#/axios?id=utilsopenfilepath">utils.openFile(path)</a></h3><ul>
<li><code>path</code> {String} 要打开的文件路径</li>
</ul>
<p>打开一个文件，返回一个blob对象</p>
<h3 id="utils-copyInputStream-inputstream-outputstream"><a href="#utils-copyInputStream-inputstream-outputstream" class="headerlink" title="utils.copyInputStream(inputstream, outputstream)"></a><a href="http://doc.autoxjs.com/#/axios?id=utilscopyinputstreaminputstream-outputstream">utils.copyInputStream(inputstream, outputstream)</a></h3><ul>
<li><code>inputstream</code>java输入流</li>
<li><code>outputstream</code> java输出流</li>
</ul>
<p>拷贝输入流到输出流，这个函数是阻塞的，且不会自动关闭流。</p>
<h3 id="utils-ThreadPool"><a href="#utils-ThreadPool" class="headerlink" title="utils.ThreadPool"></a><a href="http://doc.autoxjs.com/#/axios?id=utilsthreadpool">utils.ThreadPool</a></h3><p>此对象用于将一个同步函数转成异步方法运行，返回一个<code>Promise</code>，例如</p>
<pre><code>let promise = ThreadPool.run(()&gt;&#123;
  //同步代码，返回值就是Promise的返回值
&#125;)
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>模块 moudle</title>
    <url>//blog/note/code/AutoXjs/moudle.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="module-模块"><a href="#module-模块" class="headerlink" title="module (模块)"></a><a href="http://doc.autoxjs.com/#/modules?id=module-%e6%a8%a1%e5%9d%97">module (模块)</a></h1><h2 id="module-模块-1"><a href="#module-模块-1" class="headerlink" title="module (模块)"></a><a href="http://doc.autoxjs.com/#/modules?id=module-%e6%a8%a1%e5%9d%97">module (模块)</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>Auto.js 有一个简单的模块加载系统。 在 Auto.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。</p>
<p>例子，假设有一个名为 foo.js 的文件：</p>
<pre><code>var circle = require(&#39;./circle.js&#39;);
console.log(&quot;半径为 4 的圆的面积是 %d&quot;, circle.area(4));
</code></pre>
<p>在第一行中，foo.js 加载了同一目录下的 circle.js 模块。</p>
<p>circle.js 文件的内容为：</p>
<pre><code>const PI = Math.PI;

exports.area = function (r) &#123;
  return PI * r * r;
&#125;;

exports.circumference = (r) =&gt; 2 * PI * r;
</code></pre>
<p>circle.js 模块导出了 area() 和 circumference() 两个函数。 通过在特殊的 exports 对象上指定额外的属性，函数和对象可以被添加到模块的根部。</p>
<p>模块内的本地变量是私有的。 在这个例子中，变量 PI 是 circle.js 私有的，不会影响到加载他的脚本的变量环境。</p>
<p>module.exports属性可以被赋予一个新的值（例如函数或对象）。</p>
<p>如下，bar.js 会用到 square 模块，square 导出一个构造函数：</p>
<pre><code>const square = require(&#39;./square.js&#39;);
const mySquare = square(2);
console.log(&quot;正方形的面积是 %d&quot;, mySquare.area());
</code></pre>
<p>square 模块定义在 square.js 中：</p>
<pre><code>// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`
module.exports = function(width) &#123;
  return &#123;
    area: () =&gt; width ** 2
  &#125;;
&#125;;
</code></pre>
<h3 id="require函数"><a href="#require函数" class="headerlink" title="require函数"></a><a href="http://doc.autoxjs.com/#/modules?id=require%e5%87%bd%e6%95%b0"><code>require</code>函数</a></h3><p><code>require</code>函数用于加载模块，返回模块中<code>module.exports</code>的值。</p>
<p>该函数有一个参数用于查找模块位置，可以是相对路径(以’.&#x2F;‘或’..&#x2F;‘开头)，也可以是绝对路径(以’&#x2F;‘开头)， 还可以是以’http:&#x2F;&#x2F;‘或’https:&#x2F;&#x2F;‘开头的uri地址，用于加载网络模块，出于安全和加载速度考虑，此方式不建议使用。</p>
<p>当没有以这些开头时，将会视为内置模块，从内置模块目录依次查找，由于历史原因，在脚本主文件中仍然会先尝试解析成相对路径解析，若解析成功则会忽略内置模块直接加载，强烈不建议使用此方式加载相对路径的模块，该方式在模块中不可用并且被弃用，在未来版本可能会被移除。</p>
<p>和nodejs类似，当传入的是一个目录，则会尝试加载该目录下的index.js文件，若存在package.json文件则会先解析该文件中的main字段，若main字段指向一个有效的模块将直接加载该模块。</p>
<h3 id="模块变量"><a href="#模块变量" class="headerlink" title="模块变量"></a><a href="http://doc.autoxjs.com/#/modules?id=%e6%a8%a1%e5%9d%97%e5%8f%98%e9%87%8f">模块变量</a></h3><p>这些变量只存在于模块中，并非全局变量</p>
<ul>
<li><p><code>module</code> 储存当前模块一些信息的对象，其中最重要的是<code>module.exports</code>表示该模块导出的对象</p>
</li>
<li><p><code>exports</code> 相当于预先运行了<code>var exports = module.exports</code></p>
</li>
<li><p><code>__dirname</code> 当前模块的目录名</p>
</li>
<li><p><code>__filename</code> 当前模块的文件名。 这是当前模块文件的已解析符号链接的绝对路径。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>传感器 sensors</title>
    <url>//blog/note/code/AutoXjs/sensors.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Sensors"><a href="#Sensors" class="headerlink" title="Sensors"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensors">Sensors</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>sensors 模块提供了获取手机上的传感器的信息的支持，这些传感器包括距离传感器、光线光感器、重力传感器、方向传感器等。需要指出的是，脚本只能获取传感器的数据，<strong>不能模拟或伪造传感器的数据和事件</strong>，因此诸如模拟摇一摇的功能是无法实现的。</p>
<p>要监听一个传感器时，需要使用<code>sensors.register()</code>注册监听器，之后才能开始监听；不需要监听时则调用<code>sensors.unregister()</code>注销监听器。在脚本结束时会自动注销所有的监听器。同时，这种监听会使脚本保持运行状态，如果不注销监听器，脚本会一直保持运行状态。</p>
<p>例如，监听光线传感器的代码为：</p>
<pre><code>//光线传感器监听
sensors.register(&quot;light&quot;).on(&quot;change&quot;, (event, light)=&gt;&#123;
    log(&quot;当前光强度为&quot;, light);
&#125;);
</code></pre>
<p>要注意的是，每个传感器的数据并不相同，所以对他们调用<code>on()</code>监听事件时的回调函数参数也不是相同，例如光线传感器参数为<code>(event, light)</code>，加速度传感器参数为<code>(event, ax, ay, az)</code>。甚至在某些设备上的传感器参数有所增加，例如华为手机的距离传感器为三个参数，一般手机只有一个参数。</p>
<p>常用的传感器及其事件参数如下表：</p>
<ul>
<li><p><code>accelerometer</code> 加速度传感器，参数<code>(event, ax, ay, az)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>ax</code> {number} x 轴上的加速度，单位 m&#x2F;s^2</li>
<li><code>ay</code> {number} y 轴上的加速度，单位 m&#x2F;s^2</li>
<li><code>az</code> {number} z 轴上的加速度，单位 m&#x2F;s^2 这里的 x 轴，y 轴，z 轴所属的坐标系统如下图(其中 z 轴垂直于设备屏幕表面):</li>
</ul>
<p>!<img src="http://doc.autoxjs.com/axis_device.png" alt="axis_device"></p>
</li>
<li><p><code>orientation</code> 方向传感器，参数<code>(event, azimuth, pitch, roll)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>azimuth</code> {number} 方位角，从地磁指北方向线起，依顺时针方向到 y 轴之间的水平夹角，单位角度，范围 0~359</li>
<li><code>pitch</code> {number} 绕 x 轴旋转的角度，当设备水平放置时该值为 0，当设备顶部翘起时该值为正数，当设备尾部翘起时该值为负数，单位角度，范围-180~180</li>
<li><code>roll</code> {number} 绕 y 轴顺时针旋转的角度，单位角度，范围-90~90</li>
</ul>
</li>
<li><p><code>gyroscope</code> 陀螺仪传感器，参数<code>(event, wx, wy, wz)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>wx</code> {number} 绕 x 轴的角速度，单位弧度&#x2F;s</li>
<li><code>wy</code> {number} 绕 y 轴的角速度，单位弧度&#x2F;s</li>
<li><code>wz</code> {number} 绕 z 轴的角速度，单位弧度&#x2F;s</li>
</ul>
</li>
<li><p><code>magnetic_field</code> 磁场传感器，参数<code>(event, bx, by, bz)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>bx</code> {number} x 轴上的磁场强度，单位 uT</li>
<li><code>by</code> {number} y 轴上的磁场强度，单位 uT</li>
<li><code>bz</code> {number} z 轴上的磁场强度，单位 uT</li>
</ul>
</li>
<li><p><code>gravity</code> 重力传感器，参数<code>(event, gx, gy, gz)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>gx</code> {number} x 轴上的重力加速度，单位 m&#x2F;s^2</li>
<li><code>gy</code> {number} y 轴上的重力加速度，单位 m&#x2F;s^2</li>
<li><code>gz</code> {number} z 轴上的重力加速度，单位 m&#x2F;s^2</li>
</ul>
</li>
<li><p><code>linear_acceleration</code> 线性加速度传感器，参数<code>(event, ax, ay, az)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>ax</code> {number} x 轴上的线性加速度，单位 m&#x2F;s^2</li>
<li><code>ay</code> {number} y 轴上的线性加速度，单位 m&#x2F;s^2</li>
<li><code>az</code> {number} z 轴上的线性加速度，单位 m&#x2F;s^2</li>
</ul>
</li>
<li><p><code>ambient_temperature</code> 环境温度传感器，大部分设备并不支持，参数<code>(event, t)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>t</code> {number} 环境温度，单位摄氏度。</li>
</ul>
</li>
<li><p><code>light</code> 光线传感器，参数<code>(event, light)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>light</code> {number} 环境光强度，单位 lux</li>
</ul>
</li>
<li><p><code>pressure</code> 压力传感器，参数<code>(event, p)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>p</code> {number} 大气压，单位 hPa</li>
</ul>
</li>
<li><p><code>proximity</code> 距离传感器，参数<code>(event, distance)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>distance</code> {number} 一般指设备前置摄像头旁边的距离传感器到前方障碍物的距离，并且很多设备上这个值只有两种情况：当障碍物较近时该值为 0，当障碍物较远或在范围内没有障碍物时该值为 5</li>
</ul>
</li>
<li><p><code>relative_humidity</code> 湿度传感器，大部分设备并不支持，参数<code>(event, rh)</code>:</p>
<ul>
<li><code>event</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensorevent">SensorEvent</a> 传感器事件，用于获取传感器数据变化时的所有信息</li>
<li><code>rh</code> {number} 相对湿度，范围为 0~100（百分比）</li>
</ul>
</li>
</ul>
<h2 id="sensors-register-sensorName-delay"><a href="#sensors-register-sensorName-delay" class="headerlink" title="sensors.register(sensorName[, delay])"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensorsregistersensorname-delay">sensors.register(sensorName[, delay])</a></h2><ul>
<li><code>sensorName</code> {string} 传感器名称，常用的传感器名称如上面所述</li>
<li><code>delay</code> {number} 传感器数据更新频率，可选，默认为<code>sensors.delay.normal</code>。可用的值如下：<ul>
<li><code>sensors.delay.normal</code> 正常频率</li>
<li><code>sensors.delay.ui</code> 适合于用户界面的更新频率</li>
<li><code>sensors.delay.game</code> 适合于游戏的更新频率</li>
<li><code>sensors.delay.fastest</code> 最快的更新频率】</li>
</ul>
</li>
<li>返回 <a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmiiter</a></li>
</ul>
<p>注册一个传感器监听并返回<a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmitter</a>。</p>
<p>例如:</p>
<pre><code>console.show();
//注册传感器监听
var sensor = sensors.register(&quot;gravity&quot;);
if(sensor == null)&#123;
    toast(&quot;不支持重力传感器&quot;);
    exit();
&#125;
//监听数据
sensor.on(&quot;change&quot;, (gx, gy, gz)=&gt;&#123;
    log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz);
&#125;);
</code></pre>
<p>可以通过 delay 参数来指定传感器数据的更新频率，例如：</p>
<pre><code>var sensor = sensors.register(&quot;gravity&quot;, sensors.delay.game);
</code></pre>
<p>另外，如果不支持<code>sensorName</code>所指定的传感器，那么该函数将返回<code>null</code>；但如果<code>sensors.ignoresUnsupportedSensor</code>的值被设置为<code>true</code>, 则该函数会返回一个不会分发任何传感器事件的<a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmitter</a>。</p>
<p>例如:</p>
<pre><code>sensors.ignoresUnsupportedSensor = true;
//无需null判断
sensors.register(&quot;gravity&quot;).on(&quot;change&quot;, (gx, gy, gz)=&gt;&#123;
    log(&quot;重力加速度: %d, %d, %d&quot;, gx, gy, gz);
&#125;);
</code></pre>
<p>更多信息，参见<a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmitter</a>和<a href="http://doc.autoxjs.com/#/sensors?id=ignoresunsupportedsensor">sensors.ignoresUnsupportedSensor</a>。</p>
<h2 id="sensors-unregister-emitter"><a href="#sensors-unregister-emitter" class="headerlink" title="sensors.unregister(emitter)"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensorsunregisteremitter">sensors.unregister(emitter)</a></h2><ul>
<li><code>emiiter</code> <a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmitter</a></li>
</ul>
<p>注销该传感器监听器。被注销的监听器将不再能监听传感器数据。</p>
<pre><code>//注册一个传感器监听器
var sensor = sensors.register(&quot;gravity&quot;);
if(sensor == null)&#123;
    exit();
&#125;
//2秒后注销该监听器
setTimeout(()=&gt; &#123;
    sensors.unregister(sensor);
&#125;, 2000);
</code></pre>
<h2 id="sensors-unregisterAll"><a href="#sensors-unregisterAll" class="headerlink" title="sensors.unregisterAll()"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensorsunregisterall">sensors.unregisterAll()</a></h2><p>注销所有传感器监听器。</p>
<h2 id="sensors-ignoresUnsupportedSensor"><a href="#sensors-ignoresUnsupportedSensor" class="headerlink" title="sensors.ignoresUnsupportedSensor"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensorsignoresunsupportedsensor">sensors.ignoresUnsupportedSensor</a></h2><ul>
<li>{boolean}</li>
</ul>
<p>表示是否忽略不支持的传感器。如果该值被设置为<code>true</code>，则函数<code>sensors.register()</code>即使对不支持的传感器也会返回一个无任何数据的虚拟传感器监听，也就是<code>sensors.register()</code>不会返回<code>null</code>从而避免非空判断，并且此时会触发<code>sensors</code>的”unsupported_sensor”事件。</p>
<pre><code>//忽略不支持的传感器
sensors.ignoresUnsupportedSensor = true;
//监听有不支持的传感器时的事件
sensors.on(&quot;unsupported_sensor&quot;, function(sensorName)&#123;
    toastLog(&quot;不支持的传感器: &quot; + sensorName);
&#125;);
//随便注册一个不存在的传感器。
log(sensors.register(&quot;aaabbb&quot;));
</code></pre>
<h2 id="事件-‘unsupported-sensor’"><a href="#事件-‘unsupported-sensor’" class="headerlink" title="事件: ‘unsupported_sensor’"></a><a href="http://doc.autoxjs.com/#/sensors?id=%e4%ba%8b%e4%bb%b6-39unsupported_sensor39">事件: ‘unsupported_sensor’</a></h2><ul>
<li><code>sensorName</code> {string} 不支持的传感器名称</li>
</ul>
<p>当<code>sensors.ignoresUnsupportedSensor</code>被设置为<code>true</code>并且有不支持的传感器被注册时触发该事件。事件参数的传感器名称。</p>
<h2 id="SensorEventEmitter"><a href="#SensorEventEmitter" class="headerlink" title="SensorEventEmitter"></a><a href="http://doc.autoxjs.com/#/sensors?id=sensoreventemitter">SensorEventEmitter</a></h2><p>注册传感器返回的对象，其本身是一个 EventEmmiter，用于监听传感器事件。</p>
<h2 id="事件-‘change’"><a href="#事件-‘change’" class="headerlink" title="事件: ‘change’"></a><a href="http://doc.autoxjs.com/#/sensors?id=%e4%ba%8b%e4%bb%b6-39change39">事件: ‘change’</a></h2><ul>
<li><code>..args</code> {Any} 传感器参数</li>
</ul>
<p>当传感器数据改变时触发该事件；该事件触发的最高频繁由<code>sensors.register()</code>指定的 delay 参数决定。</p>
<p>事件参数根据传感器类型不同而不同，具体参见本章最前面的列表。</p>
<p>一个监听光线传感器和加速度传感器并且每 0.5 秒获取一个数据并最终写入一个 csv 表格文件的例子如下：</p>
<pre><code>//csv文件路径
cosnt csvPath = &quot;/sdcard/data.csv&quot;;
//记录光线传感器的数据
var light = 0;
//记录加速度传感器的数据
var ax = 0;
var ay = 0;
var az = 0;
//监听光线传感器
sensors.register(&quot;light&quot;, sensors.delay.fastest)
    .on(&quot;change&quot;, l =&gt; &#123;
        light = l;
    &#125;);
//监听加速度传感器
sensors.register(&quot;accelerometer&quot;, sensors.delay.fastest)
    .on(&quot;change&quot;, (ax0, ay0, az0) =&gt; &#123;
        ax = ax0;
        ay = ay0;
        az = az0;
    &#125;);

var file = open(csvPath, &quot;w&quot;);
//写csv表格头
file.writeline(&quot;light,ax,ay,az&quot;)
//每0.5秒获取一次数据并写入文件
setInterval(()=&gt;&#123;
    file.writeline(util.format(&quot;%d,%d,%d,%d&quot;, light, ax, ay, az));
&#125;, 500);
//10秒后退出并打开文件
setTimeout(()=&gt;&#123;
    file.close();
    sensors.unregsiterAll();
    app.viewFile(csvPath);
&#125;, 10 * 1000);
</code></pre>
<h2 id="事件-‘accuracy-change’"><a href="#事件-‘accuracy-change’" class="headerlink" title="事件: ‘accuracy_change’"></a><a href="http://doc.autoxjs.com/#/sensors?id=%e4%ba%8b%e4%bb%b6-39accuracy_change39">事件: ‘accuracy_change’</a></h2><ul>
<li><code>accuracy</code> {number} 表示传感器精度。为以下值之一:<ul>
<li>-1 传感器未连接</li>
<li>0 传感器不可读</li>
<li>1 低精度</li>
<li>2 中精度</li>
<li>3 高精度</li>
</ul>
</li>
</ul>
<p>当传感器精度改变时会触发的事件。比较少用。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>多媒体 media</title>
    <url>//blog/note/code/AutoXjs/UiSelect.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Media"><a href="#Media" class="headerlink" title="Media"></a><a href="http://doc.autoxjs.com/#/media?id=media">Media</a></h1><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>media模块提供多媒体编程的支持。目前仅支持音乐播放和媒体文件扫描。后续会结合UI加入视频播放等功能。</p>
<p>需要注意是，使用该模块播放音乐时是在后台异步播放的，在脚本结束后会自动结束播放，因此可能需要插入诸如<code>sleep()</code>的语句来使脚本保持运行。例如：</p>
<pre><code>//播放音乐
media.playMusic(&quot;/sdcard/1.mp3&quot;);
//让音乐播放完
sleep(media.getMusicDuration());
</code></pre>
<ul>
<li><code>path</code> {string} 媒体文件路径</li>
</ul>
<p>扫描路径path的媒体文件，将它加入媒体库中；或者如果该文件以及被删除，则通知媒体库移除该文件。</p>
<p>媒体库包括相册、音乐库等，因此该函数可以用于把某个图片文件加入相册。</p>
<pre><code>//请求截图
requestScreenCapture(false);
//截图
var im = captureScreen();
var path = &quot;/sdcard/screenshot.png&quot;;
//保存图片
im.saveTo(path);
//把图片加入相册
media.scanFile(path);
</code></pre>
<ul>
<li><code>path</code> {string} 音乐文件路径</li>
<li><code>volume</code> {number} 播放音量，为0~1的浮点数，默认为1</li>
<li><code>looping</code> {boolean} 是否循环播放，如果looping为<code>true</code>则循环播放，默认为<code>false</code></li>
</ul>
<p>播放音乐文件path。该函数不会显示任何音乐播放界面。如果文件不存在或者文件不是受支持的音乐格式，则抛出<code>UncheckedIOException</code>异常。</p>
<pre><code>//播放音乐
media.playMusic(&quot;/sdcard/1.mp3&quot;);
//让音乐播放完
sleep(media.getMusicDuration());
</code></pre>
<p>如果要循环播放音乐，则使用looping参数：</p>
<pre><code>```js
//传递第三个参数为true以循环播放音乐
media.playMusic(&quot;/sdcard/1.mp3&quot;, 1, true);
//等待三次播放的时间
sleep(media.getMusicDuration() * 3);
</code></pre>
<p>如果要使用音乐播放器播放音乐，调用<code>app.viewFile(path)</code>函数。</p>
<ul>
<li><code>msec</code> {number} 毫秒数，表示音乐进度</li>
</ul>
<p>把当前播放进度调整到时间msec的位置。如果当前没有在播放音乐，则调用函数没有任何效果。</p>
<p>例如，要把音乐调到1分钟的位置，为<code>media.musicSeekTo(60 * 1000)</code>。</p>
<pre><code>//播放音乐
media.playMusic(&quot;/sdcard/1.mp3&quot;);
//调整到30秒的位置
media.musicSeekTo(30 * 1000);
//等待音乐播放完成
sleep(media.getMusicDuration() - 30 * 1000);
</code></pre>
<p>暂停音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。</p>
<p>继续音乐播放。如果当前没有播放过音乐，则调用该函数没有任何效果。</p>
<p>停止音乐播放。如果当前没有在播放音乐，则调用函数没有任何效果。</p>
<ul>
<li>返回 {boolean}</li>
</ul>
<p>返回当前是否正在播放音乐。</p>
<ul>
<li>返回 {number}</li>
</ul>
<p>返回当前音乐的时长。单位毫秒。</p>
<ul>
<li>返回 {number}</li>
</ul>
<p>返回当前音乐的播放进度(已经播放的时间)，单位毫秒。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>对话框 dialogs</title>
    <url>//blog/note/code/AutoXjs/dialogs.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Dialogs"><a href="#Dialogs" class="headerlink" title="Dialogs"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogs">Dialogs</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>dialogs 模块提供了简单的对话框支持，可以通过对话框和用户进行交互。最简单的例子如下：</p>
<pre><code>alert(&quot;您好&quot;);
</code></pre>
<p>这段代码会弹出一个消息提示框显示”您好”，并在用户点击”确定”后继续运行。稍微复杂一点的例子如下：</p>
<pre><code>var clear = confirm(&quot;要清除所有缓存吗?&quot;);
if(clear)&#123;
    alert(&quot;清除成功!&quot;);
&#125;
</code></pre>
<p><code>confirm()</code>会弹出一个对话框并让用户选择”是”或”否”，如果选择”是”则返回true。</p>
<p>需要特别注意的是，对话框在ui模式下不能像通常那样使用，应该使用回调函数或者<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>的形式。理解这一点可能稍有困难。举个例子:</p>
<pre><code>&quot;ui&quot;;
//回调形式
 confirm(&quot;要清除所有缓存吗?&quot;, function(clear)&#123;
     if(clear)&#123;
          alert(&quot;清除成功!&quot;);
     &#125;
 &#125;);
//Promise形式
confirm(&quot;要清除所有缓存吗?&quot;)
    .then(clear =&gt; &#123;
        if(clear)&#123;
          alert(&quot;清除成功!&quot;);
        &#125;
    &#125;);
</code></pre>
<h2 id="dialogs-alert-title-content-callback"><a href="#dialogs-alert-title-content-callback" class="headerlink" title="dialogs.alert(title[, content, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsalerttitle-content-callback">dialogs.alert(title[, content, callback])</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>content</code> {string} 可选，对话框的内容。默认为空。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个只包含“确定”按钮的提示对话框。直至用户点击确定脚本才继续运行。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>alert(&quot;出现错误~&quot;, &quot;出现未知错误，请联系脚本作者”);
</code></pre>
<p>在ui模式下该函数返回一个<code>Promise</code>。例如:</p>
<pre><code>&quot;ui&quot;;
alert(&quot;嘿嘿嘿&quot;).then(()=&gt;&#123;
    //当点击确定后会执行这里
&#125;);
</code></pre>
<h2 id="dialogs-confirm-title-content-callback"><a href="#dialogs-confirm-title-content-callback" class="headerlink" title="dialogs.confirm(title[, content, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsconfirmtitle-content-callback">dialogs.confirm(title[, content, callback])</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>content</code> {string} 可选，对话框的内容。默认为空。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个包含“确定”和“取消”按钮的提示对话框。如果用户点击“确定”则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p>该函数也可以作为全局函数使用。</p>
<p>在ui模式下该函数返回一个<code>Promise</code>。例如:</p>
<pre><code>&quot;ui&quot;;
confirm(&quot;确定吗&quot;).then(value=&gt;&#123;
    //当点击确定后会执行这里, value为true或false, 表示点击&quot;确定&quot;或&quot;取消&quot;
&#125;);
</code></pre>
<h2 id="dialogs-rawInput-title-prefill-callback"><a href="#dialogs-rawInput-title-prefill-callback" class="headerlink" title="dialogs.rawInput(title[, prefill, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsrawinputtitle-prefill-callback">dialogs.rawInput(title[, prefill, callback])</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>prefill</code> {string} 输入框的初始内容，可选，默认为空。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个包含输入框的对话框，等待用户输入内容，并在用户点击确定时将输入的字符串返回。如果用户取消了输入，返回null。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>var name = rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;);
alert(&quot;您的名字是&quot; + name);
</code></pre>
<p>在ui模式下该函数返回一个<code>Promise</code>。例如:</p>
<pre><code>&quot;ui&quot;;
rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;).then(name =&gt; &#123;
    alert(&quot;您的名字是&quot; + name);
&#125;);
</code></pre>
<p>当然也可以使用回调函数，例如:</p>
<pre><code>rawInput(&quot;请输入您的名字&quot;, &quot;小明&quot;, name =&gt; &#123;
     alert(&quot;您的名字是&quot; + name);
&#125;);
</code></pre>
<h2 id="dialogs-input-title-prefill-callback"><a href="#dialogs-input-title-prefill-callback" class="headerlink" title="dialogs.input(title[, prefill, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsinputtitle-prefill-callback">dialogs.input(title[, prefill, callback])</a></h2><p>等效于 <code>eval(dialogs.rawInput(title, prefill, callback))</code>, 该函数和rawInput的区别在于，会把输入的字符串用eval计算一遍再返回，返回的可能不是字符串。</p>
<p>可以用该函数输入数字、数组等。例如：</p>
<pre><code>var age = dialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;);
// new Date().getYear() + 1900 可获取当前年份
var year = new Date().getYear() + 1900 - age;
alert(&quot;您的出生年份是&quot; + year);
</code></pre>
<p>在ui模式下该函数返回一个<code>Promise</code>。例如:</p>
<pre><code>&quot;ui&quot;;
dialogs.input(&quot;请输入您的年龄&quot;, &quot;18&quot;).then(age =&gt; &#123;
    var year = new Date().getYear() + 1900 - age;
    alert(&quot;您的出生年份是&quot; + year);
&#125;);
</code></pre>
<h2 id="dialogs-prompt-title-prefill-callback"><a href="#dialogs-prompt-title-prefill-callback" class="headerlink" title="dialogs.prompt(title[, prefill, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsprompttitle-prefill-callback">dialogs.prompt(title[, prefill, callback])</a></h2><p>相当于 <code>dialogs.rawInput()</code>;</p>
<h2 id="dialogs-select-title-items-callback"><a href="#dialogs-select-title-items-callback" class="headerlink" title="dialogs.select(title, items, callback)"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsselecttitle-items-callback">dialogs.select(title, items, callback)</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>items</code> {Array} 对话框的选项列表，是一个字符串数组。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个带有选项列表的对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。</p>
<pre><code>var options = [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;]
var i = dialogs.select(&quot;请选择一个选项&quot;, options);
if(i &gt;= 0)&#123;
    toast(&quot;您选择的是&quot; + options[i]);
&#125;else&#123;
    toast(&quot;您取消了选择&quot;);
&#125;
</code></pre>
<p>在ui模式下该函数返回一个<code>Promise</code>。例如:</p>
<pre><code>&quot;ui&quot;;
dialogs.select(&quot;请选择一个选项&quot;, [&quot;选项A&quot;, &quot;选项B&quot;, &quot;选项C&quot;, &quot;选项D&quot;])
    .then(i =&gt; &#123;
        toast(i);
    &#125;);
</code></pre>
<h2 id="dialogs-singleChoice-title-items-index-callback"><a href="#dialogs-singleChoice-title-items-index-callback" class="headerlink" title="dialogs.singleChoice(title, items[, index, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogssinglechoicetitle-items-index-callback">dialogs.singleChoice(title, items[, index, callback])</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>items</code> {Array} 对话框的选项列表，是一个字符串数组。</li>
<li><code>index</code> {number} 对话框的初始选项的位置，默认为0。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个单选列表对话框，等待用户选择，返回用户选择的选项索引(0 ~ item.length - 1)。如果用户取消了选择，返回-1。</p>
<p>在ui模式下该函数返回一个<code>Promise</code>。</p>
<h2 id="dialogs-multiChoice-title-items-indices-callback"><a href="#dialogs-multiChoice-title-items-indices-callback" class="headerlink" title="dialogs.multiChoice(title, items[, indices, callback])"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsmultichoicetitle-items-indices-callback">dialogs.multiChoice(title, items[, indices, callback])</a></h2><ul>
<li><code>title</code> {string} 对话框的标题。</li>
<li><code>items</code> {Array} 对话框的选项列表，是一个字符串数组。</li>
<li><code>indices</code> {Array} 选项列表中初始选中的项目索引的数组，默认为空数组。</li>
<li><code>callback</code> {Function} 回调函数，可选。当用户点击确定时被调用,一般用于ui模式。</li>
</ul>
<p>显示一个多选列表对话框，等待用户选择，返回用户选择的选项索引的数组。如果用户取消了选择，返回<code>[]</code>。</p>
<p>在ui模式下该函数返回一个<code>Promise</code>。</p>
<h2 id="dialogs-build-properties"><a href="#dialogs-build-properties" class="headerlink" title="dialogs.build(properties)"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialogsbuildproperties">dialogs.build(properties)</a></h2><ul>
<li><code>properties</code> {Object} 对话框属性，用于配置对话框。</li>
<li>返回 {Dialog}</li>
</ul>
<p>创建一个可自定义的对话框，例如：</p>
<pre><code>dialogs.build(&#123;
    //对话框标题
    title: &quot;发现新版本&quot;,
    //对话框内容
    content: &quot;更新日志: 新增了若干了BUG&quot;,
    //确定键内容
    positive: &quot;下载&quot;,
    //取消键内容
    negative: &quot;取消&quot;,
    //中性键内容
    neutral: &quot;到浏览器下载&quot;,
    //勾选框内容
    checkBoxPrompt: &quot;不再提示&quot;
&#125;).on(&quot;positive&quot;, ()=&gt;&#123;
    //监听确定键
    toast(&quot;开始下载....&quot;);
&#125;).on(&quot;neutral&quot;, ()=&gt;&#123;
    //监听中性键
    app.openUrl(&quot;https://www.autojs.org&quot;);
&#125;).on(&quot;check&quot;, (checked)=&gt;&#123;
    //监听勾选框
    log(checked);
&#125;).show();
</code></pre>
<p>选项properties可供配置的项目为:</p>
<ul>
<li><code>title</code> {string} 对话框标题</li>
<li><code>titleColor</code> {string} | {number} 对话框标题的颜色</li>
<li><code>buttonRippleColor</code> {string} | {number} 对话框按钮的波纹效果颜色</li>
<li><code>icon</code> {string} | {Image} 对话框的图标，是一个URL或者图片对象</li>
<li><code>content</code> {string} 对话框文字内容</li>
<li><code>contentColor</code>{string} | {number} 对话框文字内容的颜色</li>
<li><code>contentLineSpacing</code>{number} 对话框文字内容的行高倍数，1.0为一倍行高</li>
<li><code>items</code> {Array} 对话框列表的选项</li>
<li><code>itemsColor</code> {string} | {number} 对话框列表的选项的文字颜色</li>
<li><code>itemsSelectMode</code> {string} 对话框列表的选项选择模式，可以为:<ul>
<li><code>select</code> 普通选择模式</li>
<li><code>single</code> 单选模式</li>
<li><code>multi</code> 多选模式</li>
</ul>
</li>
<li><code>itemsSelectedIndex</code> {number} | {Array} 对话框列表中预先选中的项目索引，如果是单选模式为一个索引；多选模式则为数组</li>
<li><code>positive</code> {string} 对话框确定按钮的文字内容(最右边按钮)</li>
<li><code>positiveColor</code> {string} | {number} 对话框确定按钮的文字颜色(最右边按钮)</li>
<li><code>neutral</code> {string} 对话框中立按钮的文字内容(最左边按钮)</li>
<li><code>neutralColor</code> {string} | {number} 对话框中立按钮的文字颜色(最左边按钮)</li>
<li><code>negative</code> {string} 对话框取消按钮的文字内容(确定按钮左边的按钮)</li>
<li><code>negativeColor</code> {string} | {number} 对话框取消按钮的文字颜色(确定按钮左边的按钮)</li>
<li><code>checkBoxPrompt</code> {string} 勾选框文字内容</li>
<li><code>checkBoxChecked</code> {boolean} 勾选框是否勾选</li>
<li><code>progress</code> {Object} 配置对话框进度条的对象：<ul>
<li><code>max</code> {number} 进度条的最大值，如果为-1则为无限循环的进度条</li>
<li><code>horizontal</code> {boolean} 如果为true, 则对话框无限循环的进度条为水平进度条</li>
<li><code>showMinMax</code> {boolean} 是否显示进度条的最大值和最小值</li>
</ul>
</li>
<li><code>cancelable</code> {boolean} 对话框是否可取消，如果为false，则对话框只能用代码手动取消</li>
<li><code>canceledOnTouchOutside</code> {boolean} 对话框是否在点击对话框以外区域时自动取消，默认为true</li>
<li><code>inputHint</code> {string} 对话框的输入框的输入提示</li>
<li><code>inputPrefill</code> {string} 对话框输入框的默认输入内容</li>
</ul>
<p>通过这些选项可以自定义一个对话框，并通过监听返回的Dialog对象的按键、输入事件来实现交互。下面是一些例子。</p>
<p>模拟alert对话框：</p>
<pre><code>dialogs.build(&#123;
    title: &quot;你好&quot;,
    content: &quot;今天也要元气满满哦&quot;,
    positive: &quot;好的&quot;
&#125;).show();
</code></pre>
<p>模拟confirm对话框:</p>
<pre><code>dialogs.build(&#123;
    title: &quot;你好&quot;,
    content: &quot;请问你是笨蛋吗?&quot;,
    positive: &quot;是的&quot;,
    negative: &quot;我是大笨蛋&quot;
&#125;).on(&quot;positive&quot;, ()=&gt;&#123;
    alert(&quot;哈哈哈笨蛋&quot;);
&#125;).on(&quot;negative&quot;, ()=&gt;&#123;
    alert(&quot;哈哈哈大笨蛋&quot;);
&#125;).show();
</code></pre>
<p>模拟单选框:</p>
<pre><code>dialogs.build(&#123;
    title: &quot;单选&quot;,
    items: [&quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot;, &quot;选项4&quot;],
    itemsSelectMode: &quot;single&quot;,
    itemsSelectedIndex: 3
&#125;).on(&quot;single_choice&quot;, (index, item)=&gt;&#123;
    toast(&quot;您选择的是&quot; + item);
&#125;).show();
</code></pre>
<p>“处理中”对话框:</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;下载中...&quot;,
    progress: &#123;
        max: -1
    &#125;,
    cancelable: false
&#125;).show();

setTimeout(()=&gt;&#123;
    d.dismiss();
&#125;, 3000);
</code></pre>
<p>输入对话框:</p>
<pre><code>dialogs.build(&#123;
    title: &quot;请输入您的年龄&quot;,
    inputPrefill: &quot;18&quot;
&#125;).on(&quot;input&quot;, (input)=&gt;&#123;
    var age = parseInt(input);
    toastLog(age);
&#125;).show();
</code></pre>
<p>使用这个函数来构造对话框，一个明显的不同是需要使用回调函数而不能像dialogs其他函数一样同步地返回结果；但也可以通过threads模块的方法来实现。例如显示一个输入框并获取输入结果为：</p>
<pre><code>var input = threads.disposable();
dialogas.build(&#123;
    title: &quot;请输入您的年龄&quot;,
    inputPrefill: &quot;18&quot;
&#125;).on(&quot;input&quot;, text =&gt; &#123;
    input.setAndNotify(text);
&#125;).show();
var age = parseInt(input.blockedGet());
tosatLog(age);
</code></pre>
<h2 id="Dialog"><a href="#Dialog" class="headerlink" title="Dialog"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialog">Dialog</a></h2><p><code>dialogs.build()</code>返回的对话框对象，内置一些事件用于响应用户的交互，也可以获取对话框的状态和信息。</p>
<h2 id="事件-show"><a href="#事件-show" class="headerlink" title="事件: show"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-show">事件: <code>show</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框显示时会触发的事件。例如：</p>
<pre><code>dialogs.build(&#123;
    title: &quot;标题&quot;
&#125;).on(&quot;show&quot;, (dialog)=&gt;&#123;
    toast(&quot;对话框显示了&quot;);
&#125;).show();
</code></pre>
<h2 id="事件-cancel"><a href="#事件-cancel" class="headerlink" title="事件: cancel"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-cancel">事件: <code>cancel</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框被取消时会触发的事件。一个对话框可能按取消按钮、返回键取消或者点击对话框以外区域取消。例如：</p>
<pre><code>dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;
&#125;).on(&quot;cancel&quot;, (dialog)=&gt;&#123;
    toast(&quot;对话框取消了&quot;);
&#125;).show();
</code></pre>
<h2 id="事件-dismiss"><a href="#事件-dismiss" class="headerlink" title="事件: dismiss"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-dismiss">事件: <code>dismiss</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框消失时会触发的事件。对话框被取消或者手动调用<code>dialog.dismiss()</code>函数都会触发该事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;
&#125;).on(&quot;dismiss&quot;, (dialog)=&gt;&#123;
    toast(&quot;对话框消失了&quot;);
&#125;).show();

setTimeout(()=&gt;&#123;
    d.dismiss();
&#125;, 5000);
</code></pre>
<h2 id="事件-positive"><a href="#事件-positive" class="headerlink" title="事件: positive"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-positive">事件: <code>positive</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>确定按钮按下时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;
&#125;).on(&quot;positive&quot;, (dialog)=&gt;&#123;
    toast(&quot;你点击了确定&quot;);
&#125;).show();
</code></pre>
<h2 id="事件-negative"><a href="#事件-negative" class="headerlink" title="事件: negative"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-negative">事件: <code>negative</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>取消按钮按下时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;
&#125;).on(&quot;negative&quot;, (dialog)=&gt;&#123;
    toast(&quot;你点击了取消&quot;);
&#125;).show();
</code></pre>
<h2 id="事件-neutral"><a href="#事件-neutral" class="headerlink" title="事件: neutral"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-neutral">事件: <code>neutral</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>中性按钮按下时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    neutral: &quot;稍后提示&quot;
&#125;).on(&quot;positive&quot;, (dialog)=&gt;&#123;
    toast(&quot;你点击了稍后提示&quot;);
&#125;).show();
</code></pre>
<h2 id="事件-any"><a href="#事件-any" class="headerlink" title="事件: any"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-any">事件: <code>any</code></a></h2><ul>
<li><code>dialog</code> {Dialog} 对话框</li>
<li><code>action</code> {string} 被点击的按钮，可能的值为:<ul>
<li><code>positive</code> 确定按钮</li>
<li><code>negative</code> 取消按钮</li>
<li><code>neutral</code> 中性按钮</li>
</ul>
</li>
</ul>
<p>任意按钮按下时触发的事件。例如:</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;标题&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    neutral: &quot;稍后提示&quot;
&#125;).on(&quot;any&quot;, (action, dialog)=&gt;&#123;
    if(action == &quot;positive&quot;)&#123;
        toast(&quot;你点击了确定&quot;);
    &#125;else if(action == &quot;negative&quot;)&#123;
        toast(&quot;你点击了取消&quot;);
    &#125;
&#125;).show();
</code></pre>
<h2 id="事件-item-select"><a href="#事件-item-select" class="headerlink" title="事件: item_select"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-item_select">事件: <code>item_select</code></a></h2><ul>
<li><code>index</code> {number} 被选中的项目索引，从0开始</li>
<li><code>item</code> {Object} 被选中的项目</li>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框列表(itemsSelectMode为”select”)的项目被点击选中时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;请选择&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],
    itemsSelectMode: &quot;select&quot;
&#125;).on(&quot;item_select&quot;, (index, item, dialog)=&gt;&#123;
    toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item);
&#125;).show();
</code></pre>
<h2 id="事件-single-choice"><a href="#事件-single-choice" class="headerlink" title="事件: single_choice"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-single_choice">事件: <code>single_choice</code></a></h2><ul>
<li><code>index</code> {number} 被选中的项目索引，从0开始</li>
<li><code>item</code> {Object} 被选中的项目</li>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框单选列表(itemsSelectMode为”singleChoice”)的项目被选中并点击确定时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;请选择&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],
    itemsSelectMode: &quot;singleChoice&quot;
&#125;).on(&quot;item_select&quot;, (index, item, dialog)=&gt;&#123;
    toast(&quot;您选择的是第&quot; + (index + 1) + &quot;项, 选项为&quot; + item);
&#125;).show();
</code></pre>
<h2 id="事件-multi-choice"><a href="#事件-multi-choice" class="headerlink" title="事件: multi_choice"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-multi_choice">事件: <code>multi_choice</code></a></h2><ul>
<li><code>indices</code> {Array} 被选中的项目的索引的数组</li>
<li><code>items</code> {Array} 被选中的项目的数组</li>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框多选列表(itemsSelectMode为”multiChoice”)的项目被选中并点击确定时触发的事件。例如：</p>
<pre><code>var d = dialogs.build(&#123;
    title: &quot;请选择&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    items: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;],
    itemsSelectMode: &quot;multiChoice&quot;
&#125;).on(&quot;item_select&quot;, (indices, items, dialog)=&gt;&#123;
    toast(util.format(&quot;您选择的项目为%o, 选项为%o&quot;, indices, items);
&#125;).show();
</code></pre>
<h2 id="事件-input"><a href="#事件-input" class="headerlink" title="事件: input"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-input">事件: <code>input</code></a></h2><ul>
<li><code>text</code> {string} 输入框的内容</li>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>带有输入框的对话框当点击确定时会触发的事件。例如：</p>
<pre><code>dialogs.build(&#123;
    title: &quot;请输入&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    inputPrefill: &quot;&quot;
&#125;).on(&quot;input&quot;, (text, dialog)=&gt;&#123;
    toast(&quot;你输入的是&quot; + text);
&#125;).show();
</code></pre>
<h2 id="事件-input-change"><a href="#事件-input-change" class="headerlink" title="事件: input_change"></a><a href="http://doc.autoxjs.com/#/dialogs?id=%e4%ba%8b%e4%bb%b6-input_change">事件: <code>input_change</code></a></h2><ul>
<li><code>text</code> {string} 输入框的内容</li>
<li><code>dialog</code> {Dialog} 对话框</li>
</ul>
<p>对话框的输入框的文本发生变化时会触发的事件。例如：</p>
<pre><code>dialogs.build(&#123;
    title: &quot;请输入&quot;,
    positive: &quot;确定&quot;,
    negative: &quot;取消&quot;,
    inputPrefill: &quot;&quot;
&#125;).on(&quot;input_change&quot;, (text, dialog)=&gt;&#123;
    toast(&quot;你输入的是&quot; + text);
&#125;).show();
</code></pre>
<h2 id="dialog-getProgress"><a href="#dialog-getProgress" class="headerlink" title="dialog.getProgress()"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialoggetprogress">dialog.getProgress()</a></h2><ul>
<li>返回 {number}</li>
</ul>
<p>获取当前进度条的进度值，是一个整数</p>
<h2 id="dialog-getMaxProgress"><a href="#dialog-getMaxProgress" class="headerlink" title="dialog.getMaxProgress()"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialoggetmaxprogress">dialog.getMaxProgress()</a></h2><ul>
<li>返回 {number}</li>
</ul>
<p>获取当前进度条的最大进度值，是一个整数</p>
<h2 id="dialog-getActionButton-action"><a href="#dialog-getActionButton-action" class="headerlink" title="dialog.getActionButton(action)"></a><a href="http://doc.autoxjs.com/#/dialogs?id=dialoggetactionbuttonaction">dialog.getActionButton(action)</a></h2><ul>
<li><code>action</code> {string} 动作，包括:<ul>
<li><code>positive</code></li>
<li><code>negative</code></li>
<li><code>neutral</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>常见问题</title>
    <url>//blog/note/code/AutoXjs/Q&amp;A.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q &amp; A"></a><a href="http://doc.autoxjs.com/#/qa?id=q-amp-a">Q &amp; A</a></h1><h2 id="Q-A-1"><a href="#Q-A-1" class="headerlink" title="Q &amp; A"></a><a href="http://doc.autoxjs.com/#/qa?id=q-amp-a">Q &amp; A</a></h2><h2 id="如何定时运行脚本"><a href="#如何定时运行脚本" class="headerlink" title="如何定时运行脚本"></a><a href="http://doc.autoxjs.com/#/qa?id=%e5%a6%82%e4%bd%95%e5%ae%9a%e6%97%b6%e8%bf%90%e8%a1%8c%e8%84%9a%e6%9c%ac">如何定时运行脚本</a></h2><p>点击脚本右边的菜单按钮-&gt;更多-&gt;定时任务即可定时运行脚本，但是必须保持Auto.js后台运行(自启动白名单、电源管理白名单等)。同时，可以在脚本的开头使用<code>device.wakeUp()</code>来唤醒屏幕；但是，Auto.js没有解锁屏幕的功能，因此难以在有锁屏密码的设备上达到效果。</p>
<h2 id="定时任务如何获取外部参数"><a href="#定时任务如何获取外部参数" class="headerlink" title="定时任务如何获取外部参数"></a><a href="http://doc.autoxjs.com/#/qa?id=%e5%ae%9a%e6%97%b6%e4%bb%bb%e5%8a%a1%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e5%a4%96%e9%83%a8%e5%8f%82%e6%95%b0">定时任务如何获取外部参数</a></h2><p>如果一个脚本是用intent”启动”的，比如定时任务中的特定事件（网络状态变化等）触发而启动的，则可以通过<code>engines.myEngine().execArgv.intent</code>获取启动的intent，从而获取外部参数。</p>
<h2 id="如何把图片和脚本一起打包，或者打包多个脚本"><a href="#如何把图片和脚本一起打包，或者打包多个脚本" class="headerlink" title="如何把图片和脚本一起打包，或者打包多个脚本"></a><a href="http://doc.autoxjs.com/#/qa?id=%e5%a6%82%e4%bd%95%e6%8a%8a%e5%9b%be%e7%89%87%e5%92%8c%e8%84%9a%e6%9c%ac%e4%b8%80%e8%b5%b7%e6%89%93%e5%8c%85%ef%bc%8c%e6%88%96%e8%80%85%e6%89%93%e5%8c%85%e5%a4%9a%e4%b8%aa%e8%84%9a%e6%9c%ac">如何把图片和脚本一起打包，或者打包多个脚本</a></h2><p>如果除了单脚本以外还有其他脚本、图片、音乐等资源一起打包，则需要使用项目功能。</p>
<p>点击Auto.js的”+”号，选择项目，填写项目名称、包名等信息以后，点击”√”即可新建一个项目。可以在项目中放多个脚本、模块、资源文件，点击项目工具栏的apk打包图标即可打包一个项目，点击工具栏可以重新配置项目。</p>
<p>例如，主脚本要读取同一文件夹下的图片1.png，再执行找图，则可以通过<code>images.read(&quot;./1.png&quot;)</code>来读取，其中”.&#x2F;1.png”表示同一目录1.png图片；ui中的图片控件要引用同一文件夹的2.png图片则为<code>&lt;img src=&quot;file://2.png&quot;/&gt;</code>。Auto.js内置的函数和模块都支持相对路径，但是，其他情况则需要使用<code>files.path()</code>函数来把相对路径转换为绝对路径。</p>
<h2 id="如何使打包的应用不显示主界面"><a href="#如何使打包的应用不显示主界面" class="headerlink" title="如何使打包的应用不显示主界面"></a><a href="http://doc.autoxjs.com/#/qa?id=%e5%a6%82%e4%bd%95%e4%bd%bf%e6%89%93%e5%8c%85%e7%9a%84%e5%ba%94%e7%94%a8%e4%b8%8d%e6%98%be%e7%a4%ba%e4%b8%bb%e7%95%8c%e9%9d%a2">如何使打包的应用不显示主界面</a></h2><p>需要使用项目功能。新建项目后，修改项目下的<code>project.json</code>文件，增加以下条目：</p>
<pre><code>&quot;launchConfig&quot;: &#123;
    &quot;hideLogs&quot;: true
&#125;
</code></pre>
<p>例如：</p>
<pre><code>&#123;
  &quot;name&quot;: &quot;项目名称&quot;,
  &quot;versionName&quot;: &quot;1.0.0&quot;,
  &quot;versionCode&quot;: 1,
  &quot;packageName&quot;: &quot;org.autojs.example&quot;,
  &quot;main&quot;: &quot;main.js&quot;,
  &quot;launchConfig&quot;: &#123;
      &quot;hideLogs&quot;: true
  &#125;
&#125;
</code></pre>
<p>“launchConfig”表示启动配置，”hideLogs”表示隐藏日志。</p>
<p>参见项目与项目配置。</p>
<h2 id="Auto-js自带的模块和函数中没有的功能如何实现"><a href="#Auto-js自带的模块和函数中没有的功能如何实现" class="headerlink" title="Auto.js自带的模块和函数中没有的功能如何实现"></a><a href="http://doc.autoxjs.com/#/qa?id=autojs%e8%87%aa%e5%b8%a6%e7%9a%84%e6%a8%a1%e5%9d%97%e5%92%8c%e5%87%bd%e6%95%b0%e4%b8%ad%e6%b2%a1%e6%9c%89%e7%9a%84%e5%8a%9f%e8%83%bd%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0">Auto.js自带的模块和函数中没有的功能如何实现</a></h2><p>由于Auto.js支持直接调用Android的API，对于Auto.js没有内置的函数，可以直接通过修改Android代码为JavaScript代码实现。例如旋转图片的Android代码为：</p>
<pre><code>import android.graphics.Bitmap;
import android.graphics.Matrix;

public static Bitmap rotate(final Bitmap src,
                            final int degrees,
                            final float px,
                            final float py) &#123;
    if (degrees == 0) return src;
    Matrix matrix = new Matrix();
    matrix.setRotate(degrees, px, py);
    Bitmap ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);
    return ret;
&#125;
</code></pre>
<p>转换为JavaScript的代码后为：</p>
<pre><code>importClass(android.graphics.Bitmap);
importClass(android.graphics.Matrix);

function rotate(src, degrees, px, py)&#123;
    if (degrees == 0) return src;
    var matrix = new Matrix();
    matrix.setRotate(degrees, px, py);
    var ret = Bitmap.createBitmap(src, 0, 0, src.getWidth(), src.getHeight(), matrix, true);
    return ret;
&#125;
</code></pre>
<p>有关调用 Android 和 Java 的 API 的更多信息，参见 <a href="http://doc.autoxjs.com/#/workWithJava">Work with Java</a>。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/undefined</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>shell 即 Unix Shell，在类 Unix 系统提供与操作系统交互的一系列命令。</p>
<p>很多程序可以用来执行 shell 命令，例如终端模拟器。</p>
<p>在 Auto.js 大致等同于用 adb 执行命令 “adb shell”。</p>
<p>其实现包括两种方式：</p>
<ul>
<li>通过<code>java.lang.Runtime.exec</code>执行(shell, Tap, Home等函数)</li>
<li>通过内嵌终端模拟器执行(RootAutomator, Shell等对象)</li>
</ul>
<h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a><a href="http://doc.autoxjs.com/#/shell?id=shell%e5%87%bd%e6%95%b0">shell函数</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<h2 id="shell-cmd-root"><a href="#shell-cmd-root" class="headerlink" title="shell(cmd[, root])"></a><a href="http://doc.autoxjs.com/#/shell?id=shellcmd-root">shell(cmd[, root])</a></h2><ul>
<li>cmd {string} 要执行的命令</li>
<li>root {Boolean} 是否以root权限运行，默认为false。</li>
</ul>
<p>一次性执行命令cmd, 并返回命令的执行结果。返回对象的其属性如下:</p>
<ul>
<li>code {number} 返回码。执行成功时为0，失败时为非0的数字。</li>
<li>result {string} 运行结果(stdout输出结果)</li>
<li>error {string} 运行的错误信息(stderr输出结果)。例如执行需要root权限的命令但没有授予root权限会返回错误信息”Permission denied”。</li>
</ul>
<p>示例（强制停止微信）：</p>
<pre><code>var result = shell(&quot;am force-stop com.tencent.mm&quot;, true);
log(result);

console.show();

if(result.code == 0)&#123;
  toast(&quot;执行成功&quot;);
&#125;else&#123;
  toast(&quot;执行失败！请到控制台查看错误信息&quot;);
&#125;
</code></pre>
<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a><a href="http://doc.autoxjs.com/#/shell?id=shell">Shell</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>shell函数通过用来一次性执行单条命令并获取结果。如果有多条命令需要执行，用Shell对象的效率更高。这是因为，每次运行shell函数都会打开一个单独的shell进程并在运行结束后关闭他，这个过程需要一定的时间；而Shell对象自始至终使用同一个shell进程。</p>
<h2 id="new-Shell-root"><a href="#new-Shell-root" class="headerlink" title="new Shell(root)"></a><a href="http://doc.autoxjs.com/#/shell?id=new-shellroot">new Shell(root)</a></h2><ul>
<li>root {Boolean} 是否以root权限运行一个shell进程，默认为false。这将会影响其后使用该Shell对象执行的命令的权限</li>
</ul>
<p>Shell对象的”构造函数”。</p>
<pre><code>var sh = new Shell(true);
//强制停止微信
sh.exec(&quot;am force-stop com.tencent.mm&quot;);
sh.exit();
</code></pre>
<h2 id="Shell-exec-cmd"><a href="#Shell-exec-cmd" class="headerlink" title="Shell.exec(cmd)"></a><a href="http://doc.autoxjs.com/#/shell?id=shellexeccmd">Shell.exec(cmd)</a></h2><ul>
<li><code>cmd</code> {string} 要执行的命令</li>
</ul>
<p>执行命令cmd。该函数不会返回任何值。</p>
<p>注意，命令执行是”异步”的、非阻塞的。也就是不会等待命令完成后才继续向下执行。</p>
<p>尽管这样的设计使用起来有很多不便之处，但受限于终端模拟器，暂时没有解决方式；如果后续能找到解决方案，则将提供<code>Shell.execAndWaitFor</code>函数。</p>
<h2 id="Shell-exit"><a href="#Shell-exit" class="headerlink" title="Shell.exit()"></a><a href="http://doc.autoxjs.com/#/shell?id=shellexit">Shell.exit()</a></h2><p>直接退出shell。正在执行的命令会被强制退出。</p>
<h2 id="Shell-exitAndWaitFor"><a href="#Shell-exitAndWaitFor" class="headerlink" title="Shell.exitAndWaitFor()"></a><a href="http://doc.autoxjs.com/#/shell?id=shellexitandwaitfor">Shell.exitAndWaitFor()</a></h2><p>执行”exit”命令并等待执行命令执行完成、退出shell。</p>
<p>此函数会执行exit命令来正常退出shell。</p>
<h2 id="Shell-setCallback-callback"><a href="#Shell-setCallback-callback" class="headerlink" title="Shell.setCallback(callback)"></a><a href="http://doc.autoxjs.com/#/shell?id=shellsetcallbackcallback">Shell.setCallback(callback)</a></h2><ul>
<li>callback {Object} 回调函数</li>
</ul>
<p>设置该Shell的回调函数，以便监听Shell的输出。可以包括以下属性：</p>
<ul>
<li>onOutput {Function} 每当shell有新的输出时便会调用该函数。其参数是一个字符串。</li>
<li>onNewLine {Function} 每当shell有新的一行输出时便会调用该函数。其参数是一个字符串(不包括最后的换行符)。</li>
</ul>
<p>例如:</p>
<pre><code>var sh = new Shell();
sh.setCallback(&#123;
    onNewLine: function(line)&#123;
        //有新的一行输出时打印到控制台
        log(line);
    &#125;
&#125;)
while(true)&#123;
    //循环输入命令
    var cmd = dialogs.rawInput(&quot;请输入要执行的命令，输入exit退出&quot;);
    if(cmd == &quot;exit&quot;)&#123;
        break;
    &#125;
    //执行命令
    sh.exec(cmd);
&#125;
sh.exit();
</code></pre>
<h2 id="附录-shell命令简介"><a href="#附录-shell命令简介" class="headerlink" title="附录: shell命令简介"></a><a href="http://doc.autoxjs.com/#/shell?id=%e9%99%84%e5%bd%95-shell%e5%91%bd%e4%bb%a4%e7%ae%80%e4%bb%8b">附录: shell命令简介</a></h2><p>以下关于shell命令的资料来自<a href="https://developer.android.com/studio/command-line/adb.html#shellcommands">AndroidStudio用户指南：Shell命令</a>。</p>
<h2 id="am命令"><a href="#am命令" class="headerlink" title="am命令"></a><a href="http://doc.autoxjs.com/#/shell?id=am%e5%91%bd%e4%bb%a4">am命令</a></h2><p>am命令即Activity Manager命令，用于管理应用程序活动、服务等。</p>
<p><strong>以下命令均以”am “开头，例如<code>shell(&#39;am start -p com.tencent.mm&#39;);</code>(启动微信)</strong></p>
<h3 id="start-options-intent"><a href="#start-options-intent" class="headerlink" title="start [options] intent"></a><a href="http://doc.autoxjs.com/#/shell?id=start-options-intent">start [options] intent</a></h3><p>启动 intent 指定的 Activity(应用程序活动)。<br>请参阅 <a href="http://doc.autoxjs.com/#/shell?id=shell_intent">intent 参数的规范</a>。</p>
<p>选项包括：</p>
<ul>
<li>-D：启用调试。</li>
<li>-W：等待启动完成。</li>
<li>--start-profiler file：启动分析器并将结果发送到 file。</li>
<li>-P file：类似于 –start-profiler，但当应用进入空闲状态时分析停止。</li>
<li>-R count：重复 Activity 启动 count 次数。在每次重复前，将完成顶部 Activity。</li>
<li>-S：启动 Activity 前强行停止目标应用。</li>
<li>--opengl-trace：启用 OpenGL 函数的跟踪。</li>
<li>--user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。</li>
</ul>
<h3 id="startservice-options-intent"><a href="#startservice-options-intent" class="headerlink" title="startservice [options] intent"></a><a href="http://doc.autoxjs.com/#/shell?id=startservice-options-intent">startservice [options] intent</a></h3><p>启动 intent 指定的 Service(服务)。<br>请参阅 <a href="http://doc.autoxjs.com/#/shell?id=shell_intent">intent 参数的规范</a>。<br>选项包括：</p>
<ul>
<li>--user user_id | current：指定要作为哪个用户运行；如果未指定，则作为当前用户运行。</li>
</ul>
<h3 id="force-stop-package"><a href="#force-stop-package" class="headerlink" title="force-stop package"></a><a href="http://doc.autoxjs.com/#/shell?id=force-stop-package">force-stop package</a></h3><p>强行停止与 package（<a href="http://doc.autoxjs.com/#/shell?id=%e5%ba%94%e7%94%a8%e5%8c%85%e5%90%8d">应用包名</a>）关联的所有应用。</p>
<h3 id="kill-options-package"><a href="#kill-options-package" class="headerlink" title="kill [options] package"></a><a href="http://doc.autoxjs.com/#/shell?id=kill-options-package">kill [options] package</a></h3><p>终止与 package（<a href="http://doc.autoxjs.com/#/shell?id=%e5%ba%94%e7%94%a8%e5%8c%85%e5%90%8d">应用包名</a>）关联的所有进程。此命令仅终止可安全终止且不会影响用户体验的进程。<br>选项包括：</p>
<ul>
<li>--user user_id | all | current：指定将终止其进程的用户；如果未指定，则终止所有用户的进程。</li>
</ul>
<h3 id="kill-all"><a href="#kill-all" class="headerlink" title="kill-all"></a><a href="http://doc.autoxjs.com/#/shell?id=kill-all">kill-all</a></h3><p>终止所有后台进程。</p>
<h3 id="broadcast-options-intent"><a href="#broadcast-options-intent" class="headerlink" title="broadcast [options] intent"></a><a href="http://doc.autoxjs.com/#/shell?id=broadcast-options-intent">broadcast [options] intent</a></h3><p>发出广播 intent。 请参阅 <a href="http://doc.autoxjs.com/#/shell?id=shell_intent">intent 参数的规范</a>。</p>
<p>选项包括：</p>
<ul>
<li>[–user user_id | all | current]：指定要发送到的用户；如果未指定，则发送到所有用户。</li>
</ul>
<h3 id="instrument-options-component"><a href="#instrument-options-component" class="headerlink" title="instrument [options] component"></a><a href="http://doc.autoxjs.com/#/shell?id=instrument-options-component">instrument [options] component</a></h3><p>使用 Instrumentation 实例启动监控。通常，目标 component 是表单 test_package&#x2F;runner_class。<br>选项包括：</p>
<ul>
<li>-r：输出原始结果（否则对 report_key_streamresult 进行解码）。与 [-e perf true] 结合使用以生成性能测量的原始输出。</li>
<li>-e name value：将参数 name 设为 value。对于测试运行器，通用表单为 -e testrunner_flag value[,value…]。</li>
<li>-p file：将分析数据写入 file。</li>
<li>-w：先等待仪器完成，然后再返回。测试运行器需要使用此选项。</li>
<li>--no-window-animation：运行时关闭窗口动画。</li>
<li>--user user_id | current：指定仪器在哪个用户中运行；如果未指定，则在当前用户中运行。</li>
<li>profile start process file 启动 process 的分析器，将结果写入 file。</li>
<li>profile stop process 停止 process 的分析器。</li>
</ul>
<h3 id="dumpheap-options-process-file"><a href="#dumpheap-options-process-file" class="headerlink" title="dumpheap [options] process file"></a><a href="http://doc.autoxjs.com/#/shell?id=dumpheap-options-process-file">dumpheap [options] process file</a></h3><p>转储 process 的堆，写入 file。</p>
<p>选项包括：</p>
<ul>
<li>--user [user_id|current]：提供进程名称时，指定要转储的进程用户；如果未指定，则使用当前用户。</li>
<li>-n：转储原生堆，而非托管堆。</li>
<li>set-debug-app [options] package 将应用 package 设为调试。</li>
</ul>
<p>选项包括：</p>
<ul>
<li>-w：应用启动时等待调试程序。</li>
<li>--persistent：保留此值。</li>
<li>clear-debug-app 使用 set-debug-app 清除以前针对调试用途设置的软件包。</li>
</ul>
<h3 id="monitor-options-启动对崩溃或-ANR-的监控。"><a href="#monitor-options-启动对崩溃或-ANR-的监控。" class="headerlink" title="monitor [options] 启动对崩溃或 ANR 的监控。"></a><a href="http://doc.autoxjs.com/#/shell?id=monitor-options-%e5%90%af%e5%8a%a8%e5%af%b9%e5%b4%a9%e6%ba%83%e6%88%96-anr-%e7%9a%84%e7%9b%91%e6%8e%a7%e3%80%82">monitor [options] 启动对崩溃或 ANR 的监控。</a></h3><p>选项包括：</p>
<ul>
<li><p>--gdb：在崩溃&#x2F;ANR 时在给定端口上启动 gdbserv。</p>
<h3 id="screen-compat-on-off-package"><a href="#screen-compat-on-off-package" class="headerlink" title="screen-compat {on|off} package"></a><a href="http://doc.autoxjs.com/#/shell?id=screen-compat-onoff-package">screen-compat {on|off} package</a></h3><p>控制 package 的屏幕兼容性模式。</p>
</li>
</ul>
<h3 id="display-size-reset-widthxheight"><a href="#display-size-reset-widthxheight" class="headerlink" title="display-size [reset|widthxheight]"></a><a href="http://doc.autoxjs.com/#/shell?id=display-size-resetwidthxheight">display-size [reset|widthxheight]</a></h3><p>替换模拟器&#x2F;设备显示尺寸。此命令对于在不同尺寸的屏幕上测试您的应用非常有用，它支持使用大屏设备模仿小屏幕分辨率（反之亦然）。<br>示例：</p>
<pre><code>shell(&quot;am display-size 1280x800&quot;, true);
</code></pre>
<h3 id="display-density-dpi"><a href="#display-density-dpi" class="headerlink" title="display-density dpi"></a><a href="http://doc.autoxjs.com/#/shell?id=display-density-dpi">display-density dpi</a></h3><p>替换模拟器&#x2F;设备显示密度。此命令对于在不同密度的屏幕上测试您的应用非常有用，它支持使用低密度屏幕在高密度环境环境上进行测试（反之亦然）。<br>示例：</p>
<pre><code>shell(&quot;am display-density 480&quot;, true);
</code></pre>
<h3 id="to-uri-intent"><a href="#to-uri-intent" class="headerlink" title="to-uri intent"></a><a href="http://doc.autoxjs.com/#/shell?id=to-uri-intent">to-uri intent</a></h3><p>将给定的 intent 规范以 URI 的形式输出。 请参阅 <a href="http://doc.autoxjs.com/#/shell?id=shell_intent">intent 参数的规范</a>。</p>
<h3 id="to-intent-uri-intent"><a href="#to-intent-uri-intent" class="headerlink" title="to-intent-uri intent"></a><a href="http://doc.autoxjs.com/#/shell?id=to-intent-uri-intent">to-intent-uri intent</a></h3><p>将给定的 intent 规范以 intent:URI 的形式输出。 请参阅 intent 参数的规范。</p>
<h3 id="intent参数的规范"><a href="#intent参数的规范" class="headerlink" title="intent参数的规范"></a><a href="http://doc.autoxjs.com/#/shell?id=intent%e5%8f%82%e6%95%b0%e7%9a%84%e8%a7%84%e8%8c%83">intent参数的规范</a></h3><p>对于采用 intent 参数的 am 命令，您可以使用以下选项指定 intent：</p>
<ul>
<li><p>-a action<br>指定 intent 操作，如“android.intent.action.VIEW”。此指定只能声明一次。</p>
</li>
<li><p>-d data_uri<br>指定 intent 数据 URI，如“content:&#x2F;&#x2F;contacts&#x2F;people&#x2F;1”。此指定只能声明一次。</p>
</li>
<li><p>-t mime_type<br>指定 intent MIME 类型，如“image&#x2F;png”。此指定只能声明一次。</p>
</li>
<li><p>-c category<br>指定 intent 类别，如“android.intent.category.APP_CONTACTS”。</p>
</li>
<li><p>-n component<br>指定带有软件包名称前缀的组件名称以创建显式 intent，如“com.example.app&#x2F;.ExampleActivity”。</p>
</li>
<li><p>-f flags<br>将标志添加到 setFlags() 支持的 intent。</p>
</li>
<li><p>--esn extra_key<br>添加一个 null extra。URI intent 不支持此选项。</p>
</li>
<li><p>-e|–es extra_key extra_string_value<br>添加字符串数据作为键值对。</p>
</li>
<li><p>--ez extra_key extra_boolean_value<br>添加布尔型数据作为键值对。</p>
</li>
<li><p>--ei extra_key extra_int_value<br>添加整数型数据作为键值对。</p>
</li>
<li><p>--el extra_key extra_long_value<br>添加长整型数据作为键值对。</p>
</li>
<li><p>--ef extra_key extra_float_value<br>添加浮点型数据作为键值对。</p>
</li>
<li><p>--eu extra_key extra_uri_value<br>添加 URI 数据作为键值对。</p>
</li>
<li><p>--ecn extra_key extra_component_name_value<br>添加组件名称，将其作为 ComponentName 对象进行转换和传递。</p>
</li>
<li><p>--eia extra_key extra_int_value[,extra_int_value…]<br>添加整数数组。</p>
</li>
<li><p>--ela extra_key extra_long_value[,extra_long_value…]<br>添加长整型数组。</p>
</li>
<li><p>--efa extra_key extra_float_value[,extra_float_value…]<br>添加浮点型数组。</p>
</li>
<li><p>--grant-read-uri-permission<br>包含标志 FLAG_GRANT_READ_URI_PERMISSION。</p>
</li>
<li><p>--grant-write-uri-permission<br>包含标志 FLAG_GRANT_WRITE_URI_PERMISSION。</p>
</li>
<li><p>--debug-log-resolution<br>包含标志 FLAG_DEBUG_LOG_RESOLUTION。</p>
</li>
<li><p>--exclude-stopped-packages<br>包含标志 FLAG_EXCLUDE_STOPPED_PACKAGES。</p>
</li>
<li><p>--include-stopped-packages<br>包含标志 FLAG_INCLUDE_STOPPED_PACKAGES。</p>
</li>
<li><p>--activity-brought-to-front<br>包含标志 FLAG_ACTIVITY_BROUGHT_TO_FRONT。</p>
</li>
<li><p>--activity-clear-top<br>包含标志 FLAG_ACTIVITY_CLEAR_TOP。</p>
</li>
<li><p>--activity-clear-when-task-reset<br>包含标志 FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET。</p>
</li>
<li><p>--activity-exclude-from-recents<br>包含标志 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS。</p>
</li>
<li><p>--activity-launched-from-history<br>包含标志 FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY。</p>
</li>
<li><p>--activity-multiple-task<br>包含标志 FLAG_ACTIVITY_MULTIPLE_TASK。</p>
</li>
<li><p>--activity-no-animation<br>包含标志 FLAG_ACTIVITY_NO_ANIMATION。</p>
</li>
<li><p>--activity-no-history<br>包含标志 FLAG_ACTIVITY_NO_HISTORY。</p>
</li>
<li><p>--activity-no-user-action<br>包含标志 FLAG_ACTIVITY_NO_USER_ACTION。</p>
</li>
<li><p>--activity-previous-is-top<br>包含标志 FLAG_ACTIVITY_PREVIOUS_IS_TOP。</p>
</li>
<li><p>--activity-reorder-to-front<br>包含标志 FLAG_ACTIVITY_REORDER_TO_FRONT。</p>
</li>
<li><p>--activity-reset-task-if-needed<br>包含标志 FLAG_ACTIVITY_RESET_TASK_IF_NEEDED。</p>
</li>
<li><p>--activity-single-top<br>包含标志 FLAG_ACTIVITY_SINGLE_TOP。</p>
</li>
<li><p>--activity-clear-task<br>包含标志 FLAG_ACTIVITY_CLEAR_TASK。</p>
</li>
<li><p>--activity-task-on-home<br>包含标志 FLAG_ACTIVITY_TASK_ON_HOME。</p>
</li>
<li><p>--receiver-registered-only<br>包含标志 FLAG_RECEIVER_REGISTERED_ONLY。</p>
</li>
<li><p>--receiver-replace-pending<br>包含标志 FLAG_RECEIVER_REPLACE_PENDING。</p>
</li>
<li><p>--selector<br>需要使用 -d 和 -t 选项以设置 intent 数据和类型。</p>
<h4 id="URI-component-package"><a href="#URI-component-package" class="headerlink" title="URI component package"></a><a href="http://doc.autoxjs.com/#/shell?id=uri-component-package">URI component package</a></h4><p>如果不受上述某一选项的限制，您可以直接指定 URI、软件包名称和组件名称。当参数不受限制时，如果参数包含一个“:”（冒号），则此工具假定参数是一个 URI；如果参数包含一个“&#x2F;”（正斜杠），则此工具假定参数是一个组件名称；否则，此工具假定参数是一个软件包名称。</p>
</li>
</ul>
<h2 id="应用包名"><a href="#应用包名" class="headerlink" title="应用包名"></a><a href="http://doc.autoxjs.com/#/shell?id=%e5%ba%94%e7%94%a8%e5%8c%85%e5%90%8d">应用包名</a></h2><p>所谓应用包名，是唯一确定应用的标识。例如微信的包名是”com.tencent.mm”, QQ的包名是”com.tencent.mobileqq”。<br>要获取一个应用的包名，可以通过函数<code>getPackageName(appName)</code>获取。参见帮助-&gt;其他一般函数。</p>
<h2 id="pm命令"><a href="#pm命令" class="headerlink" title="pm命令"></a><a href="http://doc.autoxjs.com/#/shell?id=pm%e5%91%bd%e4%bb%a4">pm命令</a></h2><p>pm命令用于管理应用程序，例如卸载应用、冻结应用等。<br><strong>以下命令均以”pm “开头，例如”shell(“pm disable com.tencent.mm”);”(冻结微信)</strong></p>
<h3 id="list-packages-options-filter"><a href="#list-packages-options-filter" class="headerlink" title="list packages [options] filter"></a><a href="http://doc.autoxjs.com/#/shell?id=list-packages-options-filter">list packages [options] filter</a></h3><p>输出所有软件包，或者，仅输出包名称包含 filter 中的文本的软件包。<br>选项：</p>
<ul>
<li>-f：查看它们的关联文件。</li>
<li>-d：进行过滤以仅显示已停用的软件包。</li>
<li>-e：进行过滤以仅显示已启用的软件包。</li>
<li>-s：进行过滤以仅显示系统软件包。</li>
<li>-3：进行过滤以仅显示第三方软件包。</li>
<li>-i：查看软件包的安装程序。</li>
<li>-u：也包括卸载的软件包。</li>
<li>--user user_id：要查询的用户空间。</li>
</ul>
<h3 id="list-permission-groups"><a href="#list-permission-groups" class="headerlink" title="list permission-groups"></a><a href="http://doc.autoxjs.com/#/shell?id=list-permission-groups">list permission-groups</a></h3><p>输出所有已知的权限组。</p>
<h3 id="list-permissions-options-group"><a href="#list-permissions-options-group" class="headerlink" title="list permissions [options] group"></a><a href="http://doc.autoxjs.com/#/shell?id=list-permissions-options-group">list permissions [options] group</a></h3><p>输出所有已知权限，或者，仅输出 group 中的权限。<br>选项：</p>
<ul>
<li>-g：按组加以组织。</li>
<li>-f：输出所有信息。</li>
<li>-s：简短摘要。</li>
<li>-d：仅列出危险权限。</li>
<li>-u：仅列出用户将看到的权限。</li>
</ul>
<h3 id="list-instrumentation-options"><a href="#list-instrumentation-options" class="headerlink" title="list instrumentation [options]"></a><a href="http://doc.autoxjs.com/#/shell?id=list-instrumentation-options">list instrumentation [options]</a></h3><p>列出所有测试软件包。<br>选项：</p>
<ul>
<li>-f：列出用于测试软件包的 APK 文件。</li>
<li>target_package：列出仅用于此应用的测试软件包。</li>
</ul>
<h3 id="list-features"><a href="#list-features" class="headerlink" title="list features"></a><a href="http://doc.autoxjs.com/#/shell?id=list-features">list features</a></h3><p>输出系统的所有功能。</p>
<h3 id="list-libraries"><a href="#list-libraries" class="headerlink" title="list libraries"></a><a href="http://doc.autoxjs.com/#/shell?id=list-libraries">list libraries</a></h3><p>输出当前设备支持的所有库。</p>
<h3 id="list-users"><a href="#list-users" class="headerlink" title="list users"></a><a href="http://doc.autoxjs.com/#/shell?id=list-users">list users</a></h3><p>输出系统上的所有用户。</p>
<h3 id="path-package"><a href="#path-package" class="headerlink" title="path package"></a><a href="http://doc.autoxjs.com/#/shell?id=path-package">path package</a></h3><p>输出给定 package 的 APK 的路径。</p>
<h3 id="install-options-path"><a href="#install-options-path" class="headerlink" title="install [options] path"></a><a href="http://doc.autoxjs.com/#/shell?id=install-options-path">install [options] path</a></h3><p>将软件包（通过 path 指定）安装到系统。<br>选项：</p>
<ul>
<li>-l：安装具有转发锁定功能的软件包。</li>
<li>-r：重新安装现有应用，保留其数据。</li>
<li>-t：允许安装测试 APK。</li>
<li>-i installer_package_name：指定安装程序软件包名称。</li>
<li>-s：在共享的大容量存储（如 sdcard）上安装软件包。</li>
<li>-f：在内部系统内存上安装软件包。</li>
<li>-d：允许版本代码降级。</li>
<li>-g：授予应用清单文件中列出的所有权限。</li>
</ul>
<h3 id="uninstall-options-package"><a href="#uninstall-options-package" class="headerlink" title="uninstall [options] package"></a><a href="http://doc.autoxjs.com/#/shell?id=uninstall-options-package">uninstall [options] package</a></h3><p>从系统中卸载软件包。<br>选项：</p>
<ul>
<li><p>-k：移除软件包后保留数据和缓存目录。</p>
<h3 id="clear-package"><a href="#clear-package" class="headerlink" title="clear package"></a><a href="http://doc.autoxjs.com/#/shell?id=clear-package">clear package</a></h3><p>删除与软件包关联的所有数据。</p>
</li>
</ul>
<h3 id="enable-package-or-component"><a href="#enable-package-or-component" class="headerlink" title="enable package_or_component"></a><a href="http://doc.autoxjs.com/#/shell?id=enable-package_or_component">enable package_or_component</a></h3><p>启用给定软件包或组件（作为“package&#x2F;class”写入）。</p>
<h3 id="disable-package-or-component"><a href="#disable-package-or-component" class="headerlink" title="disable package_or_component"></a><a href="http://doc.autoxjs.com/#/shell?id=disable-package_or_component">disable package_or_component</a></h3><p>停用给定软件包或组件（作为“package&#x2F;class”写入）。</p>
<h3 id="disable-user-options-package-or-component"><a href="#disable-user-options-package-or-component" class="headerlink" title="disable-user [options] package_or_component"></a><a href="http://doc.autoxjs.com/#/shell?id=disable-user-options-package_or_component">disable-user [options] package_or_component</a></h3><p>选项：</p>
<ul>
<li><p>--user user_id：要停用的用户。</p>
<h3 id="grant-package-name-permission"><a href="#grant-package-name-permission" class="headerlink" title="grant package_name permission"></a><a href="http://doc.autoxjs.com/#/shell?id=grant-package_name-permission">grant package_name permission</a></h3><p>向应用授予权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。</p>
</li>
</ul>
<h3 id="revoke-package-name-permission"><a href="#revoke-package-name-permission" class="headerlink" title="revoke package_name permission"></a><a href="http://doc.autoxjs.com/#/shell?id=revoke-package_name-permission">revoke package_name permission</a></h3><p>从应用中撤销权限。在运行 Android 6.0（API 级别 23）及更高版本的设备上，可以是应用清单中声明的任何权限。在运行 Android 5.1（API 级别 22）和更低版本的设备上，必须是应用定义的可选权限。</p>
<h3 id="set-install-location-location"><a href="#set-install-location-location" class="headerlink" title="set-install-location location"></a><a href="http://doc.autoxjs.com/#/shell?id=set-install-location-location">set-install-location location</a></h3><p>更改默认安装位置。位置值：</p>
<ul>
<li>0：自动—让系统决定最佳位置。</li>
<li>1：内部—安装在内部设备存储上。</li>
<li>2：外部—安装在外部介质上。</li>
</ul>
<blockquote>
<p>注：此命令仅用于调试目的；使用此命令会导致应用中断和其他意外行为。</p>
</blockquote>
<h3 id="get-install-location"><a href="#get-install-location" class="headerlink" title="get-install-location"></a><a href="http://doc.autoxjs.com/#/shell?id=get-install-location">get-install-location</a></h3><p>返回当前安装位置。返回值：</p>
<ul>
<li>0 [auto]：让系统决定最佳位置。</li>
<li>1 [internal]：安装在内部设备存储上</li>
<li>2 [external]：安装在外部介质上</li>
</ul>
<h3 id="set-permission-enforced-permission-true-false"><a href="#set-permission-enforced-permission-true-false" class="headerlink" title="set-permission-enforced permission [true|false]"></a><a href="http://doc.autoxjs.com/#/shell?id=set-permission-enforced-permission-truefalse">set-permission-enforced permission [true|false]</a></h3><p>指定是否应强制执行给定的权限。</p>
<h3 id="trim-caches-desired-free-space"><a href="#trim-caches-desired-free-space" class="headerlink" title="trim-caches desired_free_space"></a><a href="http://doc.autoxjs.com/#/shell?id=trim-caches-desired_free_space">trim-caches desired_free_space</a></h3><p>减少缓存文件以达到给定的可用空间。</p>
<h3 id="create-user-user-name"><a href="#create-user-user-name" class="headerlink" title="create-user user_name"></a><a href="http://doc.autoxjs.com/#/shell?id=create-user-user_name">create-user user_name</a></h3><p>使用给定的 user_name 创建新用户，输出新用户的标识符。</p>
<h3 id="remove-user-user-id"><a href="#remove-user-user-id" class="headerlink" title="remove-user user_id"></a><a href="http://doc.autoxjs.com/#/shell?id=remove-user-user_id">remove-user user_id</a></h3><p>移除具有给定的 user_id 的用户，删除与该用户关联的所有数据。</p>
<h3 id="get-max-users"><a href="#get-max-users" class="headerlink" title="get-max-users"></a><a href="http://doc.autoxjs.com/#/shell?id=get-max-users">get-max-users</a></h3><p>输出设备支持的最大用户数。</p>
<h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a><a href="http://doc.autoxjs.com/#/shell?id=%e5%85%b6%e4%bb%96%e5%91%bd%e4%bb%a4">其他命令</a></h2><h3 id="进行屏幕截图"><a href="#进行屏幕截图" class="headerlink" title="进行屏幕截图"></a><a href="http://doc.autoxjs.com/#/shell?id=%e8%bf%9b%e8%a1%8c%e5%b1%8f%e5%b9%95%e6%88%aa%e5%9b%be">进行屏幕截图</a></h3><p>screencap 命令是一个用于对设备显示屏进行屏幕截图的 shell 实用程序。在 shell 中，此语法为：</p>
<pre><code>screencap filename
</code></pre>
<p>例如：</p>
<pre><code>shell(&quot;screencap /sdcard/screen.png&quot;);
</code></pre>
<h3 id="列表文件"><a href="#列表文件" class="headerlink" title="列表文件"></a><a href="http://doc.autoxjs.com/#/shell?id=%e5%88%97%e8%a1%a8%e6%96%87%e4%bb%b6">列表文件</a></h3><pre><code>ls filepath
</code></pre>
<p>例如:</p>
<pre><code>log(shell(&quot;ls /system/bin&quot;).result);
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>HTTP请求笔记</title>
    <url>//blog/note/code/HTTP-axios.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.axios-http.cn/docs/intro">axios的官网</a></p>
<h1 id="axios的post默认用法（异步）"><a href="#axios的post默认用法（异步）" class="headerlink" title="axios的post默认用法（异步）"></a>axios的post默认用法（异步）</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>); <span class="comment">//引入 &quot;axios&quot; 模块 ，终端中执行： npm install axios</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置请求头</span></span><br><span class="line"><span class="keyword">let</span> headers = &#123;</span><br><span class="line">      <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;gw-xeasy.xsdsd.cn&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;sec-ch-ua&#x27;</span>: <span class="string">&#x27;&quot;Not)A;Brand&quot;;v=&quot;99&quot;, &quot;Google Chrome&quot;;v=&quot;127&quot;, &quot;Chromium&quot;;v=&quot;127&quot;&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;application/json, text/plain, */*&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Cookie&#x27;</span>: <span class="title class_">User</span>.<span class="property">Cookie</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置网址 url 和请求的数据 data</span></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">&#x27;https://gw-xeasy.com/page&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="string">&quot;businessType&quot;</span>: <span class="number">3</span>, <span class="string">&quot;pageSize&quot;</span>: <span class="number">10</span>, <span class="string">&quot;pageNum&quot;</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> 发送请求()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//开始发送请求post</span></span><br><span class="line">axios.<span class="title function_">post</span>(url, data, &#123; <span class="attr">headers</span>: headers &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查询的结果：&#x27;</span>, response.<span class="property">data</span>); <span class="comment">//直接展示结果</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查询的结果：&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(response.<span class="property">data</span>, <span class="literal">null</span>, <span class="number">2</span>));<span class="comment">//将结果转化为 JSON 数据</span></span><br><span class="line">      <span class="keyword">return</span> response.<span class="property">data</span>; <span class="comment">//请注意！return 的数据不会传递到外部，因为 axios.post 是异步操作。</span></span><br><span class="line">    <span class="comment">//要想得到返回值，可以使用 Promise 或 async/await</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;发生错误:&#x27;</span>, error.<span class="property">response</span> ? error.<span class="property">response</span>.<span class="property">data</span> : error.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="axios的post-“同步”请求"><a href="#axios的post-“同步”请求" class="headerlink" title="axios的post “同步”请求"></a>axios的post “同步”请求</h1><h2 id="方法一-使用async与await-【推荐使用】"><a href="#方法一-使用async与await-【推荐使用】" class="headerlink" title="方法一 使用async与await 【推荐使用】"></a>方法一 使用async与await 【推荐使用】</h2><p>关于 <code>async</code> 的详细使用方法，见后面的章节《异步函数 async》。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span>   headers = &#123;</span><br><span class="line">      <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;gw-xeasy.xasdasd.cn&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> idList = <span class="keyword">await</span> <span class="title function_">getPaperAnalyze</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;idList:&#x27;</span>, idList);</span><br><span class="line"><span class="comment">//getPaperAnalyze 使用 async/await 来返回数据。</span></span><br><span class="line"><span class="comment">//将 getPaperAnalyze 修改为 async 函数并使用 await 获取结果，从而能直接在主流程中得到 idList：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getPaperAnalyze</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">&#x27;https://gw-xeasy.asdasd.cn/analyze/task/query/page&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="string">&quot;businessType&quot;</span>: <span class="number">3</span>, <span class="string">&quot;pageSize&quot;</span>: <span class="number">10</span>, <span class="string">&quot;pageNum&quot;</span>: <span class="number">1</span>,&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">post</span>(url, data, &#123; <span class="attr">headers</span>: headers &#125;);<span class="comment">//开始发送post请求</span></span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>.<span class="property">data</span>.<span class="property">resultList</span>; <span class="comment">// 返回 ID 列表</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;发生错误:&#x27;</span>, error.<span class="property">response</span> ? error.<span class="property">response</span>.<span class="property">data</span> : error.<span class="property">message</span>);</span><br><span class="line">    <span class="keyword">throw</span> error; <span class="comment">// 重新抛出错误，方便调用处捕获</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="方法二-使用promise与-then"><a href="#方法二-使用promise与-then" class="headerlink" title="方法二 使用promise与.then"></a>方法二 使用promise与.then</h2><p><code>axios.post</code> 方法返回一个 <code>Promise</code> 对象。这意味着 <code>axios.post</code> 调用是异步执行的，它立即返回一个 <code>Promise</code>，而不是等待HTTP请求完成。</p>
<p>可以使用 <code>.then()</code> 方法来添加一个处理函数，这个函数会在 <code>Promise</code> 被成功解决（即HTTP请求成功返回）时被调用。如果请求失败，则会调用 <code>.catch()</code> 方法中定义的错误处理函数。</p>
<p>下面这个例子中，<code>queryPaper</code>函数会返回一个<code>paperList</code>的数组对象回来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 queryPaper 函数并处理返回的 Promise</span></span><br><span class="line"><span class="title function_">queryPaper</span>().<span class="title function_">then</span>(<span class="function"><span class="params">paperList</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;查询到&#x27;</span> + paperList.<span class="property">length</span> + <span class="string">&#x27;份试卷，请选择要分发的试卷：&#x27;</span>);</span><br><span class="line">  <span class="comment">// 这里可以继续处理 paperList</span></span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里是试卷查询，最后会返回一个数组对象，每个对象中有试卷的id与title</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryPaper</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;正在查询试卷，请稍等...&#x27;</span>);</span><br><span class="line">  <span class="comment">// 定义请求体</span></span><br><span class="line">  <span class="keyword">let</span> data = &#123;<span class="string">&quot;year&quot;</span>: <span class="string">&quot;2024&quot;</span>,  <span class="string">&quot;grade&quot;</span>: <span class="string">&quot;166&quot;</span>,  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送 POST 请求</span></span><br><span class="line">  <span class="keyword">return</span> axios.<span class="title function_">post</span>(<span class="string">&#x27;https://gw-xeasy.xsdsd.cn/xeasy-srv-item/paper/search&#x27;</span>, data, &#123; <span class="attr">headers</span>: headers &#125;)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> paperList = response.<span class="property">data</span>.<span class="property">data</span>.<span class="property">records</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(paperList, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;paperId&#x27;</span>], <span class="number">4</span>));</span><br><span class="line">      <span class="keyword">return</span> paperList;</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error.<span class="property">response</span> ? error.<span class="property">response</span>.<span class="property">data</span> : error.<span class="property">message</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="请求头的注意事项"><a href="#请求头的注意事项" class="headerlink" title="请求头的注意事项"></a>请求头的注意事项</h1><h2 id="数据长度-Content-Length"><a href="#数据长度-Content-Length" class="headerlink" title="数据长度 Content-Length"></a>数据长度 Content-Length</h2><p>有时候数据长度不对会导致请求失败。可以使用下面的语句在<code>data</code>数据准备完成之后，进行动态计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">headers[<span class="string">&#x27;Content-Length&#x27;</span>] = <span class="title class_">Buffer</span>.<span class="title function_">byteLength</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data)); <span class="comment">// 动态计算</span></span><br></pre></td></tr></table></figure>









<hr>
<h1 id="响应结果"><a href="#响应结果" class="headerlink" title="响应结果"></a>响应结果</h1><h2 id="将响应结果进行JSON格式化输出"><a href="#将响应结果进行JSON格式化输出" class="headerlink" title="将响应结果进行JSON格式化输出"></a>将响应结果进行JSON格式化输出</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(response.<span class="property">data</span>, 过滤方法, 缩进的空格数)); <span class="comment">//response.data 是响应的结果</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">stringify</span>(response.<span class="property">data</span>, <span class="literal">null</span>, <span class="number">4</span>)); <span class="comment">//格式化 response.data ，不用过滤方法，使用4个空格进行缩进。</span></span><br></pre></td></tr></table></figure>

<p>过滤方法——使用举例</p>
<p>这个过滤方法，可以是一个函数，也可以是一个数组。</p>
<p>下面给出使用数组作为过滤方法，提取对象中的某些属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;王多鱼&quot;</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;蔡徐坤&quot;</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">28</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;马保国&quot;</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;male&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">58</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义过滤方法，过滤出的结果只包含“name”、“age”</span></span><br><span class="line"><span class="keyword">let</span> replace =[<span class="string">&quot;name&quot;</span>,<span class="string">&quot;age&quot;</span>];  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a,replace,<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;王多鱼&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;蔡徐坤&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">28</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;马保国&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">58</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>





<hr>
<h1 id="JS-异步编程和事件循环"><a href="#JS-异步编程和事件循环" class="headerlink" title="JS 异步编程和事件循环"></a>JS 异步编程和事件循环</h1><p>JavaScript是一种单线程语言，它使用事件循环来处理异步操作。这意味着JavaScript可以在不阻塞主线程的情况下执行异步任务，例如网络请求、定时器等。</p>
<h3 id="异步操作的两种主要方式"><a href="#异步操作的两种主要方式" class="headerlink" title="异步操作的两种主要方式"></a>异步操作的两种主要方式</h3><ol>
<li><p><strong>Promise 和 <code>.then()</code>&#x2F;<code>.catch()</code></strong></p>
<ul>
<li><code>Promise</code> 是一种用于异步编程的对象，它代表了一个未来将要完成或失败的操作。</li>
<li>使用 <code>.then()</code> 和 <code>.catch()</code> 方法来处理 <code>Promise</code> 的成功和失败状态。</li>
</ul>
</li>
<li><p><strong><code>async</code>&#x2F;<code>await</code></strong></p>
<ul>
<li><code>async</code> 关键字用于声明一个函数是异步的，这意味着该函数会返回一个 <code>Promise</code>。</li>
<li><code>await</code> 关键字用于等待一个 <code>Promise</code> 解决，它只能在 <code>async</code> 函数内部使用。</li>
</ul>
</li>
</ol>
<h2 id="async-await-与异步行为"><a href="#async-await-与异步行为" class="headerlink" title="async&#x2F;await 与异步行为"></a><code>async</code>&#x2F;<code>await</code> 与异步行为</h2><p>尽管 <code>async</code>&#x2F;<code>await</code> 使得异步代码看起来像同步代码，但它实际上是异步执行的。以下是一些关键点来帮助理解这一点：</p>
<ol>
<li><p><strong>非阻塞执行：</strong></p>
<ul>
<li>当你在 <code>async</code> 函数中使用 <code>await</code> 时，JavaScript会挂起该函数的执行，直到等待的 <code>Promise</code> 解决。在这个过程中，JavaScript运行时会继续执行其他任务，如事件处理、其他异步操作等。</li>
</ul>
</li>
<li><p><strong>事件循环：</strong></p>
<ul>
<li><code>await</code> 并不会阻塞JavaScript的事件循环。相反，它允许事件循环在等待期间继续运行其他任务。</li>
</ul>
</li>
<li><p><strong>同步的写法，异步的执行：</strong></p>
<ul>
<li><code>async</code>&#x2F;<code>await</code> 提供了一种写异步代码的方式，使其看起来像同步代码。然而，这些代码仍然是异步执行的，因为它们不会阻塞主线程。</li>
</ul>
</li>
</ol>
<h3 id="示例：理解-async-await-的异步行为"><a href="#示例：理解-async-await-的异步行为" class="headerlink" title="示例：理解 async&#x2F;await 的异步行为"></a>示例：理解 <code>async</code>&#x2F;<code>await</code> 的异步行为</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始执行异步函数&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>); <span class="comment">// 假设这是一个返回 Promise 的异步 sleep 函数</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步函数执行完毕&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncExample</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即使 asyncExample 函数中的 await 暂停了函数的执行，控制台仍然会立即打印以下内容</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;异步函数执行后立即打印&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始执行异步函数</span><br><span class="line">异步函数执行后立即打印</span><br><span class="line">异步函数执行完毕</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>asyncExample</code> 函数中的 <code>await sleep(3000)</code> 暂停了函数的执行，但并没有阻塞主线程。</p>
<p>因此，控制台会立即打印 <code>&quot;异步函数执行后立即打印&quot;</code>，然后才打印 <code>&quot;异步函数执行完毕&quot;</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>async</code>&#x2F;<code>await</code> 的代码仍然是异步执行的，因为它们不会阻塞JavaScript的事件循环。</p>
<p><code>async</code>&#x2F;<code>await</code> 提供了一种写异步代码的方式，使其看起来像同步代码，但它们实际上仍然是异步执行的。</p>
<p>这种方式使得异步代码更易于编写、阅读和维护。</p>
<hr>
<h1 id="异步函数-async"><a href="#异步函数-async" class="headerlink" title="异步函数 async"></a>异步函数 async</h1><p><code>async</code> 是一个关键字，用来声明一个函数是异步的。当你在一个函数前面加上 <code>async</code>，这个函数就会成为一个异步函数。异步函数可以运行 <code>await</code> 表达式，<code>await</code> 可以用来等待一个 <code>Promise</code> 解决（resolve）。</p>
<h2 id="声明异步函数"><a href="#声明异步函数" class="headerlink" title="声明异步函数"></a>声明异步函数</h2><p>当你在函数前加上 <code>async</code> 关键字时，这个函数会返回一个 <code>Promise</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用-await"><a href="#使用-await" class="headerlink" title="使用 await"></a>使用 <code>await</code></h2><p>在异步函数内部，你可以使用 <code>await</code> 关键字来等待一个 <code>Promise</code>。<br><code>await</code> 会暂停函数的执行，直到等待的 <code>Promise</code> 被解决（resolve）或拒绝（reject）。<br>如果 <code>Promise</code> 被解决，<code>await</code> 表达式的值就是 <code>Promise</code> 的值；如果 <code>Promise</code> 被拒绝，会抛出一个错误。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">somePromise</span>(); <span class="comment">// 等待 somePromise 解决</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// somePromise 解决后的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="**错误处理"></a>**错误处理</h2><p>如果 <code>await</code> 的 <code>Promise</code> 被拒绝，会抛出一个错误。<br>你可以使用 <code>try...catch</code> 语句来捕获这个错误。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">try</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">somePromise</span>(); <span class="comment">// 等待 somePromise 解决</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (error) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;发生错误:&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>async</code> 函数总是返回一个 <code>Promise</code>。<br>如果函数正常结束，<code>Promise</code> 会以函数的返回值解决；如果函数抛出错误，<code>Promise</code> 会以这个错误拒绝。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myAsyncFunction</span>().<span class="title function_">then</span>(<span class="function"><span class="params">greeting</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(greeting); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="链式-Promise"><a href="#链式-Promise" class="headerlink" title="链式 Promise"></a>链式 <code>Promise</code></h2><p>由于 <code>async</code> 函数返回 <code>Promise</code>，你可以链式调用多个 <code>async</code> 函数。</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction1</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">myAsyncFunction2</span>(<span class="params">greeting</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;greeting&#125;</span>, World!`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myAsyncFunction1</span>().<span class="title function_">then</span>(<span class="function"><span class="params">greeting</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">myAsyncFunction2</span>(greeting);</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">&#125;); <span class="comment">//很明显这种“then等待promise”解决的代码看起来很累</span></span><br></pre></td></tr></table></figure>

<p>   使用 <code>async</code>&#x2F;<code>await</code>，上述链式调用可以更简洁地写成：</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">chainAsyncFunctions</span>(<span class="params"></span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> greeting = <span class="keyword">await</span> <span class="title function_">myAsyncFunction1</span>();</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="title function_">myAsyncFunction2</span>(greeting);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>async</code>&#x2F;<code>await</code> 的好处是它让异步代码的写法更接近同步代码，使得代码更易于阅读和维护。</p>
<h2 id="建立-sleep-函数"><a href="#建立-sleep-函数" class="headerlink" title="建立 sleep 函数"></a>建立 <code>sleep</code> 函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异步 sleep 函数，等待指定的毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">ms</span> - 要等待的毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> &#123;<span class="type">Promise</span>&#125; - 解决后的Promise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">sleep</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 sleep 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doSomething</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;开始等待&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>); <span class="comment">// 等待3秒</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;等待结束&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 doSomething 函数</span></span><br><span class="line"><span class="title function_">doSomething</span>();</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>无标签</tag>
      </tags>
  </entry>
  <entry>
    <title>Trpora的使用说明</title>
    <url>//blog/note/software-use/Trpora.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h1><p>网络上教的自定义<code>Typora</code>的主题，都是新建CSS文件，方法没错，但是请注意了：</p>
<blockquote>
<p>文件名不能有大写字母，否则软件内不会显示该主题。</p>
</blockquote>
<hr>
<h1 id="页面内快捷跳转"><a href="#页面内快捷跳转" class="headerlink" title="页面内快捷跳转"></a>页面内快捷跳转</h1><p>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[显示的文字](#要跳转的标题文字)</span><br><span class="line"></span><br><span class="line">例如，在本页面内跳转去【脚注】这一章。</span><br><span class="line">[点我去脚注](#脚注)</span><br><span class="line"></span><br><span class="line">（脚注必须是章节名称才行，即前面存在#号，使【脚注】二字成为了大纲文本。普通文字是无法实现快捷跳转的）</span><br><span class="line">注意，若页面中存在两个名称为【脚注】的章节，它会自动去第一个符合要求的，不信你可以自己动手试试。</span><br><span class="line">这一点无法避免，因此若喜欢使用自定义跳转，只能命名章节时避免重名。</span><br></pre></td></tr></table></figure>

<p><a href="#%E8%84%9A%E6%B3%A8">点我去脚注</a></p>
<hr>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>软件使用教程</category>
      </categories>
      <tags>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>观影/追番记录</title>
    <url>//blog/liferecord/essay/zhuifan.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><table>
<thead>
<tr>
<th>名称</th>
<th align="left">日期  +  进度</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>仙逆⭐⭐⭐⭐⭐</td>
<td align="left">2025年3月12日   看完第 79 集</td>
<td></td>
</tr>
<tr>
<td>凡人修仙传⭐⭐⭐⭐⭐</td>
<td align="left">2025年3月12日   看完第132集</td>
<td></td>
</tr>
<tr>
<td>遮天<br />⭐⭐⭐⭐⭐<br /></td>
<td align="left">2024年11月18日  看完第83集</td>
<td>叶凡。</td>
</tr>
<tr>
<td>完美世界<br />⭐⭐⭐⭐⭐<br /></td>
<td align="left">2024年10月15日  看完第184集</td>
<td>石昊ko仙殿继承人。</td>
</tr>
<tr>
<td>永生第四季 海噬仙灵<br />⭐⭐⭐⭐⭐<br /></td>
<td align="left">2024年10月21日   看完第13集（第53集）</td>
<td>（周五更新）到达海市</td>
</tr>
<tr>
<td>剑来   <br />⭐⭐⭐<br /></td>
<td align="left">2024年9月20日   看完第8集</td>
<td>陈平安的小镇要崩溃了。</td>
</tr>
<tr>
<td>师兄啊师兄⭐⭐⭐⭐</td>
<td align="left">2024年11月18日 看完第59集</td>
<td>目前更新到了第63集</td>
</tr>
<tr>
<td>牧神记⭐⭐⭐⭐</td>
<td align="left">2024年12月4日 看完第7集</td>
<td>秦牧刚刚破壁成功。</td>
</tr>
<tr>
<td>大道朝天⭐⭐⭐</td>
<td align="left">2025年1月21日 看完第1季（共16集）</td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
<tr>
<td></td>
<td align="left"></td>
<td></td>
</tr>
</tbody></table>
<hr>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>追番</tag>
      </tags>
  </entry>
  <entry>
    <title>高中工作台助手</title>
    <url>//blog/note/software-use/test-paper-analyzer.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="【高中工作台助手】"><a href="#【高中工作台助手】" class="headerlink" title="【高中工作台助手】"></a>【高中工作台助手】</h1><p>一次设置，长期（30天）有效。</p>
<p>支持所有学科！</p>
<p><code>一键全自动：[试卷分析]、[布置课后作业]、[删除试卷分析]、[查看数据排行榜]、[企业微信刷消息]</code></p>
<p><a href="https://chinese.lanzout.com/b030os2pyd">点我去下载地址</a>       </p>
<p><code>密码:sjfx</code></p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hwqfdf17frj30os0lk0x2.jpg"  style="zoom:50%;" />

<h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><p>使用过程中遇到异常，请【截图+描述】反馈。</p>
<h2 id="2024年12月19日"><a href="#2024年12月19日" class="headerlink" title="2024年12月19日"></a>2024年12月19日</h2><p>2.6版本</p>
<ul>
<li>[新增功能] 删除课后作业打卡记录（测试中，不知道是否生效）</li>
<li>[新增功能] 企业微信刷消息功能</li>
</ul>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hwqfdf17frj30os0lk0x2.jpg "  style="zoom:50%;" />




<hr>
<h2 id="2024年11月15日"><a href="#2024年11月15日" class="headerlink" title="2024年11月15日"></a>2024年11月15日</h2><p>2.5版本新增功能</p>
<ul>
<li>支持<code>扫码登录</code></li>
<li>支持<code>所有学科</code></li>
<li>支持<code>查看数据排行榜</code></li>
<li>主页显示个人头像、数据</li>
<li>支持退出登录</li>
<li>支持<code>试卷分析自定义图片</code></li>
</ul>
<img src=" //dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvn4lzn60bj30o60l8gpm.jpg "  style="zoom:50%;" />





<hr>
<h2 id="2024年11月8日"><a href="#2024年11月8日" class="headerlink" title="2024年11月8日"></a>2024年11月8日</h2><p>【由于作者<code>只有化学账号</code>，无法测试其他科目，目前<code>仅支持化学</code>。愿意尝试的朋友，可以联系我，开拓其他学科】</p>
<p>2.3版本新增功能</p>
<ul>
<li><p>新增【批量删除试卷分析】。</p>
</li>
<li><p>新增【全自动布置课后作业】用于服务打卡。（完美替代<a href="https://aboucide.github.io/blog/note/software-use/DFX-GZT.html">小太阳</a>，它可以下线了）</p>
</li>
<li><p>由于高中工作台网页版更新，重新制作了【全自动发布试卷分析】，支持随机上传【化学】试卷图片。</p>
<img src=" //dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvf2jpqecwj30zb0ktq79.jpg "  style="zoom:50%;" /></li>
</ul>
<hr>
<h2 id="2024年10月21日"><a href="#2024年10月21日" class="headerlink" title="2024年10月21日"></a>2024年10月21日</h2><p>1.0版本</p>
<ul>
<li>全自动发布【化学】试卷分析。</li>
</ul>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvn6hnyzrgj30l90chdhb.jpg "  style="zoom:50%;" />





<hr>
<h1 id="2-6版本使用教程"><a href="#2-6版本使用教程" class="headerlink" title="2.6版本使用教程"></a>2.6版本使用教程</h1><p>启动软件后，扫码登录即可开始运行。扫码登录信息30天有效，</p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hwqfdf17frj30os0lk0x2.jpg"  style="zoom:50%;" />

<h2 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h2><h3 id="【查看排名】"><a href="#【查看排名】" class="headerlink" title="【查看排名】"></a><code>【查看排名】</code></h3><p>可以看到您在“高中工作台”的数据排名。默认显示当前月份的排名，数据截至</p>
<p>前一天晚上23：59：59。</p>
<h3 id="【更多功能】"><a href="#【更多功能】" class="headerlink" title="【更多功能】"></a><code>【更多功能】</code></h3><p>目前加入了【企业微信刷消息】。</p>
<p>速度：<strong>仅需30秒即可发出400条消息</strong>。</p>
<p>支持自定义参数，如下图所示</p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hwqg1ihewdj30g9047mxm.jpg"  style="zoom:50%;" />

<h3 id="【试卷分析】"><a href="#【试卷分析】" class="headerlink" title="【试卷分析】"></a><code>【试卷分析】</code></h3><p><strong>一键启动，全自动发布</strong>。</p>
<p>软件自带的“默认随机图片”就是<strong>化学学科</strong>的试卷图片，其他学科需要参考本教程中 <strong>“如何自定义试卷分析图片教程”</strong> 进行设置使用专属于你的试卷分析图库。</p>
<p>可用于<code>每周服务打卡</code>任务。</p>
<p>启动软件后，随机从<code>图库</code>中抽取 2~7 张<code>试卷图片</code>进行错题分析。</p>
<p>随机从<code>【开课中】</code>的学员中抽取一位，作为发布对象。</p>
<p>全自动完成！</p>
<h3 id="【课后作业】"><a href="#【课后作业】" class="headerlink" title="【课后作业】"></a><code>【课后作业】</code></h3><p>随机从试卷库中挑选一份试卷当成课后作业发布出去，可以完成要求的打卡任务。</p>
<p>启动后，<strong>仅需2秒即可完成一份作业发布</strong>。</p>
<p>可用于<code>每周服务打卡</code>。</p>
<p>随机从<code>2021~2024年的试卷库</code>中抽取一份  <code>试卷</code>作为<code>课后作业</code>发布给的<code>【开课中】</code>的全部学生。</p>
<p><code>试卷</code>的<code>省份</code>也是随机的~</p>
<p>完美！</p>
<p>【注意】“排行榜”统计的题集创建，是要求用户自己创建的题集才行，使用本程序发布的课后作业不是自己创建的题集，而是随机挑选一份试卷当作课后作业发布。虽然不进入排行榜的统计数据，但是仍然算在“每月使用工作台发布作业的次数”，请放心使用。</p>
<h3 id="【删除试卷分析】"><a href="#【删除试卷分析】" class="headerlink" title="【删除试卷分析】"></a><code>【删除试卷分析】</code></h3><p>可以一键删除指定数量的试卷分析。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hwqg71dindj31hk0u07af.jpg "  style="zoom:30%;" />



<h3 id="【删除课后作业】"><a href="#【删除课后作业】" class="headerlink" title="【删除课后作业】"></a><code>【删除课后作业】</code></h3><p>删除课后作业打卡记录（测试中，不知道是否生效）。</p>
<h2 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h2><p>&#x3D;&#x3D;【选项参数说明】&#x3D;&#x3D;</p>
<p><code>试卷图片</code>：这里是用于选择用于试卷分析的图片。<code>默认随机</code>是自带的化学试卷，如果<strong>您不是化学</strong>科目，请使用&#x3D;&#x3D;自定义&#x3D;&#x3D;。</p>
<p>关于&#x3D;&#x3D;自定义&#x3D;&#x3D;的链接设置，请参考下一节“如何自定义试卷分析图片”。</p>
<p><code>试卷分析的次数</code>：你想生成几份试卷分析，这个参数就设置多少。</p>
<p><code>试卷分析的间隔</code>：顾名思义，生成两份试卷分析之间停顿的时间。稍微慢一点，试卷分析的系统要扛不住啦！</p>
<p><code>布置作业次数</code>：用于每周<code>服务打卡</code>。布置作业的次数×【开课中】学员数 &#x3D; 本次运行的有效打卡次数</p>
<hr>
<h2 id="如何自定义试卷分析图片"><a href="#如何自定义试卷分析图片" class="headerlink" title="如何自定义试卷分析图片"></a>如何自定义试卷分析图片</h2><h3 id="【1】获取工作台已经上传的图片地址"><a href="#【1】获取工作台已经上传的图片地址" class="headerlink" title="【1】获取工作台已经上传的图片地址"></a>【1】获取工作台已经上传的图片地址</h3><p>你可以随便上传一份你学科的试卷，然后进入到<code>选择题目</code>的这个页面，例如下图。</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvn52l2gvjj30xb0u0q67.jpg "  style="zoom:30%;" />

<h3 id="【2】获取生成的试卷图片网址"><a href="#【2】获取生成的试卷图片网址" class="headerlink" title="【2】获取生成的试卷图片网址"></a>【2】获取生成的试卷图片网址</h3><p>像下图所示的操作那样，依次复制每张图片的网址（复制图片地址）。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hvn55s0muej30xr0u0424.jpg "  style="zoom:30%;" />



<h3 id="【3】将你复制的图片网址保存到“自定义链接”"><a href="#【3】将你复制的图片网址保存到“自定义链接”" class="headerlink" title="【3】将你复制的图片网址保存到“自定义链接”"></a>【3】将你复制的图片网址保存到“自定义链接”</h3><p>下面这个链接是一个“在线文本数据库”，可以帮你在网络上保存一段文本。</p>
<p><a href="https://www.textdb.online/">https://www.textdb.online/</a></p>
<p>打开该网站后，可以先点击<code>随机生成</code>，帮助你获得一个<code>自定义链接</code>。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hvn5af0xc3j31jv0u077u.jpg "  style="zoom:20%;" />

<p>然后你就可以往里面保存<code>刚刚复制的试卷图片网址</code>，每保存一份链接，输入一次回车（换行）。参考下图所示。</p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hvn5e2wkwwj31jv0u0gqk.jpg "  style="zoom:30%;" />

<p>&#x3D;&#x3D;至少储存10张图片的链接&#x3D;&#x3D;，点击<code>更新数据</code>，此时已将刚刚保存的文本上传到云端。</p>
<img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hvn5pinz9ej31jv0u0497.jpg "  style="zoom:30%;" />

<p>点击<code>复制链接</code>所得到的网址，就是你在软件中所<code>自定义图片</code>的网址了。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hvn5ra5dg1j31jv0u07ex.jpg "  style="zoom:30%;" />

<p>本篇教程中，点击<code>复制链接</code>后获得到的网址为</p>
<p><a href="https://textdb.online/WgD2nBeONJldwIMNKEs9IiBT">https://textdb.online/WgD2nBeONJldwIMNKEs9IiBT</a></p>
<h3 id="【4】将这个网址复制到软件的自定义编辑框中。"><a href="#【4】将这个网址复制到软件的自定义编辑框中。" class="headerlink" title="【4】将这个网址复制到软件的自定义编辑框中。"></a>【4】将这个网址复制到软件的<code>自定义</code>编辑框中。</h3><img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvn5vujmzej30nw0lftcs.jpg "  style="zoom:50%;" />

<h3 id="【5】后续如何更新自己的自定义图片库呢？"><a href="#【5】后续如何更新自己的自定义图片库呢？" class="headerlink" title="【5】后续如何更新自己的自定义图片库呢？"></a>【5】后续如何更新自己的<code>自定义</code>图片库呢？</h3><p>细心的朋友应该已经观察到了，刚刚<code>随机生成</code>的一串<code>WgD2nBeONJldwIMNKEs9IiBT</code>其实就是你的这段文本的<code>密码</code>。</p>
<p>因此务必要保存好这串文本。</p>
<p>每次打开 <code>https://www.textdb.online/</code> 你会发现它的首页下图所示。</p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hvn60bkx5bj31cy0u0wi2.jpg "  style="zoom:30%;" />

<p>此时我们把保存的密码（本篇示例的密码为：<code>WgD2nBeONJldwIMNKEs9IiBT</code> ）粘贴进去，再点击<code>读取数据</code>。</p>
<p>然后就可以重复上面的【1~4】步，扩充你的试卷分析图片库。</p>
<p>&#x3D;&#x3D;每次记得先读取数据，然后再修改数据，再进行更新数据&#x3D;&#x3D;。</p>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hvn64117u8j31jv0u0423.jpg "  style="zoom:30%;" />



]]></content>
      <categories>
        <category>笔记</category>
        <category>软件使用教程</category>
      </categories>
      <tags>
        <tag>DIY</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT</title>
    <url>//blog/note/code/AutoXjs/MQTT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a><a href="http://doc.autoxjs.com/#/mqtt?id=mqtt">MQTT</a></h1><h2 id="MQTT-1"><a href="#MQTT-1" class="headerlink" title="MQTT"></a><a href="http://doc.autoxjs.com/#/mqtt?id=mqtt">MQTT</a></h2><p><code>6.5.9 新增</code></p>
<blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>MQTT 模块，采用<a href="https://github.com/eclipse/paho.mqtt.java">org.eclipse.paho.client.mqttv3</a>实现</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><a href="http://doc.autoxjs.com/#/mqtt?id=%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b">代码示例</a></h2><blockquote>
<p>主题订阅、发布、QOS、遗嘱消息</p>
</blockquote>
<pre><code>importPackage(Packages[&quot;org.eclipse.paho.client.mqttv3&quot;]);
importClass(&quot;org.eclipse.paho.android.service.MqttAndroidClient&quot;);

// 连接、订阅配置
const MQTT_URL = &quot;tcp://192.168.20.225:1883&quot;;
const CLIENT_ID = &quot;MOCK&quot;;
const TOPIC = &quot;ANDROID_MOCK&quot;;
const QOS = 2;
const USERNAME = &quot;device&quot;;
const PASSWORD = &quot;public&quot;;

const client = new MqttAndroidClient(context, MQTT_URL, CLIENT_ID);
const subscribeToTopic = () =&gt; &#123;
  try &#123;
    client.subscribe(
      TOPIC,
      QOS,
      null,
      new IMqttActionListener(&#123;
        onSuccess: (token) =&gt; &#123;
          toast(&quot;MQTT 订阅成功&quot;);
        &#125;,
        onFailure: (token, error) =&gt; &#123;
          toast(&quot;MQTT 订阅失败 &quot; + error);
        &#125;,
      &#125;)
    );
  &#125; catch (error) &#123;
    toast(error.message);
    alert(&#39;MQTT订阅错误\n\n&quot;&#39; + error.message);
  &#125;
&#125;;

const initMQTT = () =&gt; &#123;
  // 创建配置
  const mqttConnectOptions = new MqttConnectOptions();
  mqttConnectOptions.setAutomaticReconnect(true);
  mqttConnectOptions.setCleanSession(true);
  mqttConnectOptions.setUserName(USERNAME);
  mqttConnectOptions.setPassword(Array.from(PASSWORD));
  // 遗嘱消息 QOS = 1, retained = true
  let willMsgJavaString = new java.lang.String(&quot;i am gone&quot;);
  let willMsgJavaBytes = willMsgJavaString.getBytes(&quot;UTF-8&quot;);
  mqttConnectOptions.setWill(&quot;device-gone&quot;, willMsgJavaBytes, 1, true);

  console.log(&quot;mqttConnectOptions&quot;, mqttConnectOptions);

  const callback = new MqttCallbackExtended(&#123;
    connectComplete: (reconnect, serverUri) =&gt; &#123;
      if (reconnect) &#123;
        subscribeToTopic();
        console.log(&quot;重新连接到MQTT&quot;);
      &#125; else &#123;
        console.log(&quot;连接到MQTT&quot;);
      &#125;
    &#125;,
    connectionLost: () =&gt; &#123;
      console.log(&quot;MQTT 连接丢失&quot;);
    &#125;,
    messageArrived: (topic, message) =&gt; &#123;
      console.log(&quot;MQTT MESSAGE: &quot;, topic, message);
    &#125;,
  &#125;);
  client.setCallback(callback);

  client.connect(
    mqttConnectOptions,
    null,
    new IMqttActionListener(&#123;
      onSuccess: () =&gt; &#123;
        console.log(&quot;mqtt连接成功&quot;);
        subscribeToTopic();
      &#125;,
      onFailure: (token, error) =&gt; &#123;
        console.error(&quot;mqtt连接失败&quot;, error);
        exit();
      &#125;,
    &#125;)
  );
&#125;;

const publish = (topic, msg, qos = 1, retained = false) =&gt; &#123;
  // publish message
  try &#123;
    let javaString = new java.lang.String(msg);
    let byteArray = javaString.getBytes(&quot;UTF-8&quot;);
    client.publish(topic, byteArray, qos, retained);
  &#125; catch (error) &#123;
    console.error(&quot;MQTT 发布失败&quot;, error);
  &#125;
&#125;;

// 连接
initMQTT();
setTimeout(() =&gt; &#123;
  toast(&quot;7秒后自动关闭&quot;);
  // send message
  publish(TOPIC, &quot;hello&quot;);
&#125;, 3000);
// 断开并退出
setTimeout(() =&gt; &#123;
  client.close();
  client.disconnect();
  toast(&quot;自动关闭并退出脚本&quot;);
  exit();
&#125;, 10 * 1000);

// 防止进程退出
setInterval(() =&gt; &#123;
  //
&#125;, 1000);
</code></pre>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>app 相关</title>
    <url>//blog/note/code/AutoXjs/app.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h2><p>该模块提供一系列函数，用于使用其他应用、与其他应用交互。例如发送意图、打开文件、发送邮件等。</p>
<p>同时提供了方便的进阶函数 <code>startActivity</code> 和 <code>sendBroadcast</code> ，用他们可完成app模块没有内置的和其他应用的交互。</p>
<h2 id="app-versionCode"><a href="#app-versionCode" class="headerlink" title="app.versionCode"></a>app.versionCode</h2><ul>
<li><code>return</code> {number}</li>
</ul>
<p>当前软件版本号，整数值。例如160, 256等。</p>
<p>如果在Auto.js中运行则为Auto.js的版本号；在打包的软件中则为打包软件的版本号。</p>
<pre><code>toastLog(app.versionCode);
</code></pre>
<h2 id="app-versionName"><a href="#app-versionName" class="headerlink" title="app.versionName"></a>app.versionName</h2><ul>
<li><code>return</code> {string}</li>
</ul>
<p>当前软件的版本名称，例如”3.0.0 Beta”。</p>
<p>如果在Auto.js中运行则为Auto.js的版本名称；在打包的软件中则为打包软件的版本名称。</p>
<pre><code>toastLog(app.verionName);
</code></pre>
<h2 id="app-autojs-versionCode"><a href="#app-autojs-versionCode" class="headerlink" title="app.autojs.versionCode"></a>app.autojs.versionCode</h2><ul>
<li><code>return</code> {number}</li>
</ul>
<p>Auto.js版本号，整数值。例如160, 256等。</p>
<h2 id="app-autojs-versionName"><a href="#app-autojs-versionName" class="headerlink" title="app.autojs.versionName"></a>app.autojs.versionName</h2><ul>
<li><code>return</code> {string}</li>
</ul>
<p>Auto.js版本名称，例如”3.0.0 Beta”。</p>
<h2 id="app-launchApp-appName"><a href="#app-launchApp-appName" class="headerlink" title="app.launchApp(appName)"></a>app.launchApp(appName)</h2><ul>
<li><code>appName</code> {string} 应用名称</li>
</ul>
<p>通过应用名称启动应用。如果该名称对应的应用不存在，则返回false; 否则返回true。如果该名称对应多个应用，则只启动其中某一个。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>launchApp(&quot;Auto.js&quot;);
</code></pre>
<h2 id="app-launch-packageName"><a href="#app-launch-packageName" class="headerlink" title="app.launch(packageName)"></a>app.launch(packageName)</h2><ul>
<li><code>packageName</code> {string} 应用包名</li>
</ul>
<p>通过应用包名启动应用。如果该包名对应的应用不存在，则返回false；否则返回true。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>//启动微信
launch(&quot;com.tencent.mm&quot;);
</code></pre>
<h2 id="app-launchPackage-packageName"><a href="#app-launchPackage-packageName" class="headerlink" title="app.launchPackage(packageName)"></a>app.launchPackage(packageName)</h2><ul>
<li><code>packageName</code> {string} 应用包名</li>
</ul>
<p>相当于<code>app.launch(packageName)</code>。</p>
<h2 id="app-getPackageName-appName"><a href="#app-getPackageName-appName" class="headerlink" title="app.getPackageName(appName)"></a>app.getPackageName(appName)</h2><ul>
<li><code>appName</code> {string} 应用名称</li>
</ul>
<p>获取应用名称对应的已安装的应用的包名，如果该找不到该应用，返回 <code>null</code> 。如果该名称对应多个应用，则只返回其中某一个的包名。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>var name = getPackageName(&quot;QQ&quot;); //返回&quot;com.tencent.mobileqq&quot;
</code></pre>
<h2 id="app-getAppName-packageName"><a href="#app-getAppName-packageName" class="headerlink" title="app.getAppName(packageName)"></a>app.getAppName(packageName)</h2><ul>
<li><code>packageName</code> {string} 应用包名</li>
</ul>
<p>获取应用包名对应的已安装的应用的名称。如果该找不到该应用，返回null。</p>
<p>该函数也可以作为全局函数使用。</p>
<pre><code>var name = getAppName(&quot;com.tencent.mobileqq&quot;); //返回&quot;QQ&quot;
</code></pre>
<h2 id="app-openAppSetting-packageName"><a href="#app-openAppSetting-packageName" class="headerlink" title="app.openAppSetting(packageName)"></a>app.openAppSetting(packageName)</h2><ul>
<li><code>packageName</code> {string} 应用包名</li>
<li><code>return</code> {Boolean}</li>
</ul>
<p>打开应用的详情页(设置页)。如果找不到该应用，返回false; 否则返回true。</p>
<p>该函数也可以作为全局函数使用。</p>
<h2 id="app-viewFile-path"><a href="#app-viewFile-path" class="headerlink" title="app.viewFile(path)"></a>app.viewFile(path)</h2><ul>
<li><code>path</code> {string} 文件路径</li>
</ul>
<p>用其他应用查看文件。文件不存在的情况由查看文件的应用处理。</p>
<p>如果找不出可以查看该文件的应用，则抛出<code>ActivityNotException</code>。</p>
<pre><code>//查看文本文件
app.viewFile(&quot;/sdcard/1.txt&quot;);
</code></pre>
<h2 id="app-editFile-path"><a href="#app-editFile-path" class="headerlink" title="app.editFile(path)"></a>app.editFile(path)</h2><ul>
<li><code>path</code> {string} 文件路径</li>
</ul>
<p>用其他应用编辑文件。文件不存在的情况由编辑文件的应用处理。</p>
<p>如果找不出可以编辑该文件的应用，则抛出<code>ActivityNotException</code>。</p>
<pre><code>//编辑文本文件
app.editFile(&#39;/sdcard/1.txt/&#39;);
</code></pre>
<h2 id="app-uninstall-packageName"><a href="#app-uninstall-packageName" class="headerlink" title="app.uninstall(packageName)"></a>app.uninstall(packageName)</h2><ul>
<li><code>packageName</code> {string} 应用包名</li>
</ul>
<p>卸载应用。执行后会会弹出卸载应用的提示框。如果该包名的应用未安装，由应用卸载程序处理，可能弹出”未找到应用”的提示。</p>
<pre><code>//卸载QQ
app.uninstall(&quot;com.tencent.mobileqq&quot;);
</code></pre>
<h2 id="app-openUrl-url"><a href="#app-openUrl-url" class="headerlink" title="app.openUrl(url)"></a>app.openUrl(url)</h2><ul>
<li><code>url</code> {string} 网站的Url，如果不以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头则默认是”http:&#x2F;&#x2F;“。</li>
</ul>
<p>用浏览器打开网站url。</p>
<p>如果没有安装浏览器应用，则抛出<code>ActivityNotException</code>。</p>
<h2 id="app-sendEmail-options"><a href="#app-sendEmail-options" class="headerlink" title="app.sendEmail(options)"></a>app.sendEmail(options)</h2><ul>
<li><code>options</code> {Object} 发送邮件的参数。包括:<ul>
<li><code>email</code> {string} | {Array} 收件人的邮件地址。如果有多个收件人，则用字符串数组表示</li>
<li><code>cc</code> {string} | {Array} 抄送收件人的邮件地址。如果有多个抄送收件人，则用字符串数组表示</li>
<li><code>bcc</code> {string} | {Array} 密送收件人的邮件地址。如果有多个密送收件人，则用字符串数组表示</li>
<li><code>subject</code> {string} 邮件主题(标题)</li>
<li><code>text</code> {string} 邮件正文</li>
<li><code>attachment</code> {string} 附件的路径。</li>
</ul>
</li>
</ul>
<p>根据选项<code>options</code>调用邮箱应用发送邮件。这些选项均是可选的。</p>
<p>如果没有安装邮箱应用，则抛出<code>ActivityNotException</code>。</p>
<pre><code>//发送邮件给10086@qq.com和10001@qq.com。
app.sendEmail(&#123;
    email: [&quot;10086@qq.com&quot;, &quot;10001@qq.com&quot;],
    subject: &quot;这是一个邮件标题&quot;,
    text: &quot;这是邮件正文&quot;
&#125;);
</code></pre>
<h2 id="app-startActivity-name"><a href="#app-startActivity-name" class="headerlink" title="app.startActivity(name)"></a>app.startActivity(name)</h2><ul>
<li><code>name</code> {string} 活动名称，可选的值为:<ul>
<li><code>console</code> 日志界面</li>
<li><code>settings</code> 设置界面</li>
</ul>
</li>
</ul>
<p>启动Auto.js的特定界面。该函数在Auto.js内运行则会打开Auto.js内的界面，在打包应用中运行则会打开打包应用的相应界面。</p>
<pre><code>app.startActivity(&quot;console&quot;);
</code></pre>
<h2 id="进阶-意图Intent"><a href="#进阶-意图Intent" class="headerlink" title="进阶: 意图Intent"></a>进阶: 意图Intent</h2><p>Intent(意图) 是一个消息传递对象，您可以使用它从其他应用组件请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ul>
<li><p>启动活动(Activity)： Activity 表示应用中的一个”屏幕”。例如应用主入口都是一个Activity，应用的功能通常也以Activity的形式独立，例如微信的主界面、朋友圈、聊天窗口都是不同的Activity。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。</p>
</li>
<li><p>启动服务(Service)： Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。</p>
</li>
<li><p>传递广播： 广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。</p>
</li>
</ul>
<p>本模块提供了构建Intent的函数(<code>app.intent()</code>), 启动Activity的函数<code>app.startActivity()</code>, 发送广播的函数<code>app.sendBroadcast()</code>。</p>
<p>使用这些方法可以用来方便的调用其他应用。例如直接打开某个QQ号的个人卡片页，打开某个QQ号的聊天窗口等。</p>
<pre><code>var qq = &quot;2732014414&quot;;
app.startActivity(&#123; 
    action: &quot;android.intent.action.VIEW&quot;, 
    data:&quot;mqq://im/chat?chat_type=wpa&amp;version=1&amp;src_type=web&amp;uin=&quot; + qq, 
    packageName: &quot;com.tencent.mobileqq&quot;, 
&#125;);
</code></pre>
<h2 id="app-intent-options"><a href="#app-intent-options" class="headerlink" title="app.intent(options)"></a>app.intent(options)</h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>options</code> {Object} 选项，包括：<ul>
<li><code>action</code> {string} 意图的Action，指意图要完成的动作，是一个字符串常量，比如”android.intent.action.SEND”。当action以”android.intent.action”开头时，可以省略前缀，直接用”SEND”代替。参见<a href="https://developer.android.com/reference/android/content/Intent.html#standard-activity-actions">Actions</a>。</li>
<li><code>type</code> {string} 意图的MimeType，表示和该意图直接相关的数据的类型，表示比如”text&#x2F;plain”为纯文本类型。</li>
<li><code>data</code> {string} 意图的Data，表示和该意图直接相关的数据，是一个Uri, 可以是文件路径或者Url等。例如要打开一个文件, action为”android.intent.action.VIEW”, data为”file:&#x2F;&#x2F;&#x2F;sdcard&#x2F;1.txt”。</li>
<li><code>category</code> {Array} 意图的类别。比较少用。参见<a href="https://developer.android.com/reference/android/content/Intent.html#standard-categories">Categories</a>。</li>
<li><code>packageName</code> {string} 目标包名</li>
<li><code>className</code> {string} 目标Activity或Service等组件的名称</li>
<li><code>extras</code> {Object} 以键值对构成的这个Intent的Extras(额外信息)。提供该意图的其他信息，例如发送邮件时的邮件标题、邮件正文。参见<a href="https://developer.android.com/reference/android/content/Intent.html#standard-extra-data">Extras</a>。</li>
<li><code>flags</code> {Array} intent的标识，字符串数组，例如<code>[&quot;activity_new_task&quot;, &quot;grant_read_uri_permission&quot;]</code>。参见<a href="https://developer.android.com/reference/android/content/Intent.html#setFlags%28int%29">Flags</a>。</li>
<li><code>root</code> {Boolea} 是否以root权限启动、发送该intent。使用该参数后，不能使用`context.</li>
</ul>
</li>
</ul>
<p>根据选项，构造一个意图Intent对象。</p>
<p>例如：</p>
<pre><code>//打开应用来查看图片文件
var i = app.intent(&#123;
    action: &quot;VIEW&quot;,
    type: &quot;image/png&quot;,
    data: &quot;file:///sdcard/1.png&quot;
&#125;);
context.startActivity(i);
</code></pre>
<p>需要注意的是，除非应用专门暴露Activity出来，否则在没有root权限的情况下使用intent是无法跳转到特定Activity、应用的特定界面的。例如我们能通过Intent跳转到QQ的分享界面，是因为QQ对外暴露了分享的Activity；而在没有root权限的情况下，我们无法通过intent跳转到QQ的设置界面，因为QQ并没有暴露这个Activity。</p>
<p>但如果有root权限，则在intent的参数加上<code>&quot;root&quot;: true</code>即可。例如使用root权限跳转到Auto.js的设置界面为：</p>
<pre><code>app.startActivity(&#123;
    packageName: &quot;org.autojs.autojs&quot;,
    className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;,
    root: true
&#125;);
</code></pre>
<p>另外，关于intent的参数如何获取的问题，一些intent是意外发现并且在网络中传播的（例如跳转QQ聊天窗口是因为QQ给网页提供了跳转到客服QQ的方法），如果要自己获取活动的intent的参数，可以通过例如”intent记录”，”隐式启动”等应用拦截内部intent或者查询暴露的intent。其中拦截内部intent需要XPosed框架，或者可以通过反编译等手段获取参数。总之，没有简单直接的方法。</p>
<p>更多信息，请百度<a href="https://www.baidu.com/s?wd=android%20Intent">安卓Intent</a>或参考<a href="https://developer.android.com/guide/components/intents-filters.html#Types">Android指南: Intent</a>。</p>
<h2 id="app-startActivity-options"><a href="#app-startActivity-options" class="headerlink" title="app.startActivity(options)"></a><a href="http://doc.autoxjs.com/#/app?id=appstartactivityoptions">app.startActivity(options)</a></h2><ul>
<li><code>options</code> {Object} 选项</li>
</ul>
<p>根据选项构造一个Intent，并启动该Activity。</p>
<pre><code>app.startActivity(&#123;
    action: &quot;SEND&quot;,
    type: &quot;text/plain&quot;,
    data: &quot;file:///sdcard/1.txt&quot;
&#125;);
</code></pre>
<h2 id="app-sendBroadcast-options"><a href="#app-sendBroadcast-options" class="headerlink" title="app.sendBroadcast(options)"></a><a href="http://doc.autoxjs.com/#/app?id=appsendbroadcastoptions">app.sendBroadcast(options)</a></h2><ul>
<li><code>options</code> {Object} 选项</li>
</ul>
<p>根据选项构造一个Intent，并发送该广播。</p>
<h2 id="app-startService-options"><a href="#app-startService-options" class="headerlink" title="app.startService(options)"></a><a href="http://doc.autoxjs.com/#/app?id=appstartserviceoptions">app.startService(options)</a></h2><ul>
<li><code>options</code> {Object} 选项</li>
</ul>
<p>根据选项构造一个Intent，并启动该服务。</p>
<h2 id="app-sendBroadcast-name"><a href="#app-sendBroadcast-name" class="headerlink" title="app.sendBroadcast(name)"></a><a href="http://doc.autoxjs.com/#/app?id=appsendbroadcastname">app.sendBroadcast(name)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>name</code> {string} 特定的广播名称，包括：<ul>
<li><code>inspect_layout_hierarchy</code> 布局层次分析</li>
<li><code>inspect_layout_bounds</code> 布局范围</li>
</ul>
</li>
</ul>
<p>发送以上特定名称的广播可以触发Auto.js的布局分析，方便脚本调试。这些广播在Auto.js发送才有效，在打包的脚本上运行将没有任何效果。</p>
<pre><code>app.sendBroadcast(&quot;inspect_layout_bounds&quot;);
</code></pre>
<h2 id="app-intentToShell-options"><a href="#app-intentToShell-options" class="headerlink" title="app.intentToShell(options)"></a><a href="http://doc.autoxjs.com/#/app?id=appintenttoshelloptions">app.intentToShell(options)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>options</code> {Object} 选项</li>
</ul>
<p>根据选项构造一个Intent，转换为对应的shell的intent命令的参数。</p>
<p>例如:</p>
<pre><code>shell(&quot;am start &quot; + app.intentToShell(&#123;
    packageName: &quot;org.autojs.autojs&quot;,
    className: &quot;org.autojs.autojs.ui.settings.SettingsActivity_&quot;
&#125;), true);
</code></pre>
<p>参见<a href="https://developer.android.com/studio/command-line/adb#IntentSpec">intent参数的规范</a>。</p>
<h2 id="app-parseUri-uri"><a href="#app-parseUri-uri" class="headerlink" title="app.parseUri(uri)"></a><a href="http://doc.autoxjs.com/#/app?id=appparseuriuri">app.parseUri(uri)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>uri</code> {string} 一个代表Uri的字符串，例如”file:&#x2F;&#x2F;&#x2F;sdcard&#x2F;1.txt”, “<a href="https://www.autojs.org"/">https://www.autojs.org"</a></li>
<li><code>return</code> {Uri} 一个代表Uri的对象，参见<a href="https://developer.android.com/reference/android/net/Uri">android.net.Uri</a>。</li>
</ul>
<p>解析uri字符串并返回相应的Uri对象。即使Uri格式错误，该函数也会返回一个Uri对象，但之后如果访问该对象的scheme, path等值可能因解析失败而返回<code>null</code>。</p>
<p>需要注意的是，在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此如果uri字符串是文件<code>file://...</code>，返回的Uri会是诸如<code>content://...</code>的形式。</p>
<h2 id="app-getUriForFile-path"><a href="#app-getUriForFile-path" class="headerlink" title="app.getUriForFile(path)"></a><a href="http://doc.autoxjs.com/#/app?id=appgeturiforfilepath">app.getUriForFile(path)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>path</code> {string} 文件路径，例如”&#x2F;sdcard&#x2F;1.txt”</li>
<li><code>return</code> {Uri} 一个指向该文件的Uri的对象，参见<a href="https://developer.android.com/reference/android/net/Uri">android.net.Uri</a>。</li>
</ul>
<p>从一个文件路径创建一个uri对象。需要注意的是，在高版本Android上，由于系统限制直接在Uri暴露文件的绝对路径，因此返回的Uri会是诸如<code>content://...</code>的形式。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>//blog/note/code/AutoXjs/websocket.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://doc.autoxjs.com/#/websocket?id=websocket">websocket</a></p>
<h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a><a href="http://doc.autoxjs.com/#/websocket?id=websocket">websocket</a></h2><p><code>4.2.8 新增</code></p>
<blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>websocket模块，采用okhttp3 实现，本模块中包含了okhttp3 核心所有的类，下面讲解其基本的使用方法，更多的使用规则,可参考：(<a href="https://square.github.io/okhttp/">https://square.github.io/okhttp/)，这里涉及一些线程安全问题，请学习多线程，生命周期等内容。</a>%EF%BC%8C%E8%BF%99%E9%87%8C%E6%B6%89%E5%8F%8A%E4%B8%80%E4%BA%9B%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E8%AF%B7%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AD%89%E5%86%85%E5%AE%B9%E3%80%82)</p>
<h2 id="创建websocket客户端"><a href="#创建websocket客户端" class="headerlink" title="创建websocket客户端"></a><a href="http://doc.autoxjs.com/#/websocket?id=%e5%88%9b%e5%bb%bawebsocket%e5%ae%a2%e6%88%b7%e7%ab%af">创建websocket客户端</a></h2><ul>
<li><p>创建一个http client，可以设定client是否重连，心跳等功能</p>
</li>
<li><p>创建一个request 请求对象，采用什么协议ws 或wss 、服务器、端口都能内容</p>
</li>
<li><p>设置监听，当websocket 生命周期内的一些事情。</p>
</li>
<li><p>设置上面的操作以后，打开链接，创建webSocket 客户端。</p>
</li>
<li><p>用webSocket 客户端 发送消息 <code>webSocket.send(&quot;你好服务器&quot;)</code>;</p>
<p>importPackage(Packages[“okhttp3”]); &#x2F;&#x2F;导入包<br>var client &#x3D; new OkHttpClient.Builder().retryOnConnectionFailure(true).build();<br>var request &#x3D; new Request.Builder().url(“ws:&#x2F;&#x2F;192.168.31.164:9317”).build(); &#x2F;&#x2F;vscode  插件的ip地址，<br>client.dispatcher().cancelAll();&#x2F;&#x2F;清理一次<br>myListener &#x3D; {<br>onOpen: function (webSocket, response) {<br>    print(“onOpen”);<br>    &#x2F;&#x2F;打开链接后，想服务器端发送一条消息<br>    var json &#x3D; {};<br>    json.type&#x3D;”hello”;<br>    json.data&#x3D; {device_name:”模拟设备”,client_version:123,app_version:123,app_version_code:”233”};<br>    var hello&#x3D;JSON.stringify(json);<br>    webSocket.send(hello);<br>},<br>onMessage: function (webSocket, msg) { &#x2F;&#x2F;msg可能是字符串，也可能是byte数组，取决于服务器送的内容<br>    print(“msg”);<br>    print(msg);<br>},<br>onClosing: function (webSocket, code, response) {<br>    print(“正在关闭”);<br>},<br>onClosed: function (webSocket, code, response) {<br>    print(“已关闭”);<br>},<br>onFailure: function (webSocket, t, response) {<br>    print(“错误”);<br>    print( t);<br>}<br>}</p>
<p>var webSocket&#x3D; client.newWebSocket(request, new WebSocketListener(myListener)); &#x2F;&#x2F;创建链接</p>
<p>setInterval(() &#x3D;&gt; { &#x2F;&#x2F; 防止主线程退出</p>
<p>}, 1000);</p>
</li>
</ul>
<p>创建 websocket 服务器端，一样支持，可以参考 okhttp 官网。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>全局变量与专有函数</title>
    <url>//blog/note/code/AutoXjs/varable.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="全局变量与专有函数"><a href="#全局变量与专有函数" class="headerlink" title="全局变量与专有函数"></a><a href="http://doc.autoxjs.com/#/globals?id=%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e4%b8%8e%e5%87%bd%e6%95%b0">全局变量与专有函数</a></h1><h2 id="全局变量与函数"><a href="#全局变量与函数" class="headerlink" title="全局变量与函数"></a><a href="http://doc.autoxjs.com/#/globals?id=%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e4%b8%8e%e5%87%bd%e6%95%b0">全局变量与函数</a></h2><p>全局变量和函数在所有模块中均可使用。 但以下变量的作用域只在模块内，详见 <a href="http://doc.autoxjs.com/#/modules.html">module</a>：</p>
<ul>
<li>exports</li>
<li>module</li>
<li>require() 以下的对象是特定于 Auto.js 的。 有些内置对象是 JavaScript 语言本身的一部分，它们也是全局的。</li>
</ul>
<p>一些模块中的函数为了使用方便也可以直接全局使用，这些函数在此不再赘述。例如timers模块的setInterval, setTimeout等函数。</p>
<h2 id="sleep-n"><a href="#sleep-n" class="headerlink" title="sleep(n)"></a><a href="http://doc.autoxjs.com/#/globals?id=sleepn">sleep(n)</a></h2><ul>
<li><code>n</code> {number} 毫秒数</li>
</ul>
<p>暂停运行n<strong>毫秒</strong>的时间。1秒等于1000毫秒。</p>
<pre><code>//暂停5秒
sleep(5000);
</code></pre>
<h2 id="currentPackage"><a href="#currentPackage" class="headerlink" title="currentPackage()"></a><a href="http://doc.autoxjs.com/#/globals?id=currentpackage">currentPackage()</a></h2><ul>
<li>返回 {string}</li>
</ul>
<p>返回最近一次监测到的正在运行的应用的包名，一般可以认为就是当前正在运行的应用的包名。</p>
<p>此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。</p>
<h2 id="currentActivity"><a href="#currentActivity" class="headerlink" title="currentActivity()"></a><a href="http://doc.autoxjs.com/#/globals?id=currentactivity">currentActivity()</a></h2><ul>
<li>返回 {string}</li>
</ul>
<p>返回最近一次监测到的正在运行的Activity的名称，一般可以认为就是当前正在运行的Activity的名称。</p>
<p>此函数依赖于无障碍服务，如果服务未启动，则抛出异常并提示用户启动。</p>
<h2 id="setClip-text"><a href="#setClip-text" class="headerlink" title="setClip(text)"></a><a href="http://doc.autoxjs.com/#/globals?id=setcliptext">setClip(text)</a></h2><ul>
<li><code>text</code> {string} 文本</li>
</ul>
<p>设置剪贴板内容。此剪贴板即系统剪贴板，在一般应用的输入框中”粘贴”既可使用。</p>
<pre><code>setClip(&quot;剪贴板文本&quot;);
</code></pre>
<h2 id="getClip"><a href="#getClip" class="headerlink" title="getClip()"></a><a href="http://doc.autoxjs.com/#/globals?id=getclip">getClip()</a></h2><ul>
<li>返回 {string}</li>
</ul>
<p>返回系统剪贴板的内容。</p>
<pre><code>toast(&quot;剪贴板内容为:&quot; + getClip());
</code></pre>
<h2 id="toast-message"><a href="#toast-message" class="headerlink" title="toast(message)"></a><a href="http://doc.autoxjs.com/#/globals?id=toastmessage">toast(message)</a></h2><ul>
<li>message {string} 要显示的信息</li>
</ul>
<p>以气泡显示信息message几秒。(具体时间取决于安卓系统，一般都是2秒)</p>
<p>注意，信息的显示是”异步”执行的，并且，不会等待信息消失程序才继续执行。如果在循环中执行该命令，可能出现脚本停止运行后仍然有不断的气泡信息出现的情况。 例如:</p>
<pre><code>for(var i = 0; i &lt; 100; i++)&#123;
  toast(i);
&#125;
</code></pre>
<p>运行这段程序以后，会很快执行完成，且不断弹出消息，在任务管理中关闭所有脚本也无法停止。 要保证气泡消息才继续执行可以用：</p>
<pre><code>for(var i = 0; i &lt; 100; i++)&#123;
  toast(i);
  sleep(2000);
&#125;
</code></pre>
<p>或者修改toast函数：</p>
<pre><code>var _toast_ = toast;
toast = function(message)&#123;
  _toast_(message);
  sleep(2000);
&#125;
for(var i = 0; i &lt; 100; i++)&#123;
  toast(i);
&#125;
</code></pre>
<h2 id="toastLog-message"><a href="#toastLog-message" class="headerlink" title="toastLog(message)"></a><a href="http://doc.autoxjs.com/#/globals?id=toastlogmessage">toastLog(message)</a></h2><ul>
<li>message {string} 要显示的信息</li>
</ul>
<p>相当于<code>toast(message);log(message)</code>。显示信息message并在控制台中输出。参见console.log。</p>
<h2 id="waitForActivity-activity-period-200"><a href="#waitForActivity-activity-period-200" class="headerlink" title="waitForActivity(activity[, period &#x3D; 200])"></a><a href="http://doc.autoxjs.com/#/globals?id=waitforactivityactivity-period-200">waitForActivity(activity[, period &#x3D; 200])</a></h2><ul>
<li><code>activity</code> Activity名称</li>
<li><code>period</code> 轮询等待间隔（毫秒）</li>
</ul>
<p>等待指定的Activity出现，period为检查Activity的间隔。</p>
<h2 id="waitForPackage-package-period-200"><a href="#waitForPackage-package-period-200" class="headerlink" title="waitForPackage(package[, period &#x3D; 200])"></a><a href="http://doc.autoxjs.com/#/globals?id=waitforpackagepackage-period-200">waitForPackage(package[, period &#x3D; 200])</a></h2><ul>
<li><code>package</code> 包名</li>
<li><code>period</code> 轮询等待间隔（毫秒）</li>
</ul>
<p>等待指定的应用出现。例如<code>waitForPackage(&quot;com.tencent.mm&quot;)</code>为等待当前界面为微信。</p>
<h2 id="exit"><a href="#exit" class="headerlink" title="exit()"></a><a href="http://doc.autoxjs.com/#/globals?id=exit">exit()</a></h2><p>立即停止脚本运行。</p>
<p>立即停止是通过抛出<code>ScriptInterrupttedException</code>来实现的，因此如果用<code>try...catch</code>把exit()函数的异常捕捉，则脚本不会立即停止，仍会运行几行后再停止。</p>
<h2 id="random-min-max"><a href="#random-min-max" class="headerlink" title="random(min, max)"></a><a href="http://doc.autoxjs.com/#/globals?id=randommin-max">random(min, max)</a></h2><ul>
<li><code>min</code> {number} 随机数产生的区间下界</li>
<li><code>max</code> {number} 随机数产生的区间上界</li>
<li>返回 {number}</li>
</ul>
<p>返回一个在[min…max]之间的随机数。例如random(0, 2)可能产生0, 1, 2。</p>
<h2 id="random"><a href="#random" class="headerlink" title="random()"></a><a href="http://doc.autoxjs.com/#/globals?id=random">random()</a></h2><ul>
<li>返回 {number}</li>
</ul>
<p>返回在[0, 1)的随机浮点数。</p>
<h2 id="requiresApi-api"><a href="#requiresApi-api" class="headerlink" title="requiresApi(api)"></a><a href="http://doc.autoxjs.com/#/globals?id=requiresapiapi">requiresApi(api)</a></h2><ul>
<li><code>api</code> Android版本号</li>
</ul>
<p>表示此脚本需要Android API版本达到指定版本才能运行。例如<code>requiresApi(19)</code>表示脚本需要在Android 4.4以及以上运行。</p>
<p>调用该函数时会判断运行脚本的设备系统的版本号，如果没有达到要求则抛出异常。</p>
<p>可以参考以下Android API和版本的对照表:</p>
<p>平台版本： API级别</p>
<p>Android 7.0： 24</p>
<p>Android 6.0： 23</p>
<p>Android 5.1： 22</p>
<p>Android 5.0： 21</p>
<p>Android 4.4W： 20</p>
<p>Android 4.4： 19</p>
<p>Android 4.3： 18</p>
<h2 id="requiresAutojsVersion-version"><a href="#requiresAutojsVersion-version" class="headerlink" title="requiresAutojsVersion(version)"></a><a href="http://doc.autoxjs.com/#/globals?id=requiresautojsversionversion">requiresAutojsVersion(version)</a></h2><ul>
<li><code>version</code> {string} | {number} Auto.js的版本或版本号</li>
</ul>
<p>表示此脚本需要Auto.js版本达到指定版本才能运行。例如<code>requiresAutojsVersion(&quot;3.0.0 Beta&quot;)</code>表示脚本需要在Auto.js 3.0.0 Beta以及以上运行。</p>
<p>调用该函数时会判断运行脚本的Auto.js的版本号，如果没有达到要求则抛出异常。</p>
<p>version参数可以是整数表示版本号，例如<code>requiresAutojsVersion(250)</code>；也可以是字符串格式表示的版本，例如”3.0.0 Beta”, “3.1.0 Alpha4”, “3.2.0”等。</p>
<p>可以通过<code>app.autojs.versionCode</code>和<code>app.autojs.versionName</code>获取当前的Auto.js版本号和版本。</p>
<h2 id="runtime-requestPermissions-permissions"><a href="#runtime-requestPermissions-permissions" class="headerlink" title="runtime.requestPermissions(permissions)"></a><a href="http://doc.autoxjs.com/#/globals?id=runtimerequestpermissionspermissions">runtime.requestPermissions(permissions)</a></h2><ul>
<li><code>permissions</code> {Array} 权限的字符串数组</li>
</ul>
<p>动态申请安卓的权限。例如：</p>
<pre><code>//请求GPS权限
runtime.requestPermissions([&quot;access_fine_location&quot;]);
</code></pre>
<p>尽管安卓有很多权限，但必须写入Manifest才能动态申请，为了防止权限的滥用，目前Auto.js只能额外申请两个权限：</p>
<ul>
<li><code>access_fine_location</code> GPS权限</li>
<li><code>record_audio</code> 录音权限</li>
</ul>
<p>您可以通过APK编辑器来增加Auto.js以及Auto.js打包的应用的权限。</p>
<p>安卓所有的权限列表参见<a href="https://developer.android.com/guide/topics/permissions/overview">Permissions Overview</a>。（并没有用）</p>
<h2 id="runtime-loadJar-path"><a href="#runtime-loadJar-path" class="headerlink" title="runtime.loadJar(path)"></a><a href="http://doc.autoxjs.com/#/globals?id=runtimeloadjarpath">runtime.loadJar(path)</a></h2><ul>
<li><code>path</code> {string} jar文件路径</li>
</ul>
<p>加载目标jar文件，加载成功后将可以使用该Jar文件的类。</p>
<pre><code>// 加载jsoup.jar
runtime.loadJar(&quot;./jsoup.jar&quot;);
// 使用jsoup解析html
importClass(org.jsoup.Jsoup);
log(Jsoup.parse(files.read(&quot;./test.html&quot;)));
</code></pre>
<p>(jsoup是一个Java实现的解析Html DOM的库，可以在<a href="https://jsoup.org/download">Jsoup</a>下载)</p>
<h2 id="runtime-loadDex-path"><a href="#runtime-loadDex-path" class="headerlink" title="runtime.loadDex(path)"></a><a href="http://doc.autoxjs.com/#/globals?id=runtimeloaddexpath">runtime.loadDex(path)</a></h2><ul>
<li><code>path</code> {string} dex文件路径</li>
</ul>
<p>加载目标dex文件，加载成功后将可以使用该dex文件的类。</p>
<p>因为加载jar实际上是把jar转换为dex再加载的，因此加载dex文件会比jar文件快得多。可以使用Android SDK的build tools的dx工具把jar转换为dex。</p>
<h2 id="context"><a href="#context" class="headerlink" title="context"></a><a href="http://doc.autoxjs.com/#/globals?id=context">context</a></h2><p>全局变量。一个android.content.Context对象。</p>
<p>注意该对象为ApplicationContext，因此不能用于界面、对话框等的创建。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>基于坐标的触摸模拟</title>
    <url>//blog/note/code/AutoXjs/zuobiao.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基于坐标的触摸模拟"><a href="#基于坐标的触摸模拟" class="headerlink" title="基于坐标的触摸模拟"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=%e5%9f%ba%e4%ba%8e%e5%9d%90%e6%a0%87%e7%9a%84%e8%a7%a6%e6%91%b8%e6%a8%a1%e6%8b%9f">基于坐标的触摸模拟</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>本章节介绍了一些使用坐标进行点击、滑动的函数。这些函数有的需要安卓7.0以上，有的需要root权限。</p>
<p>要获取要点击的位置的坐标，可以在开发者选项中开启”指针位置”。</p>
<p>基于坐标的脚本通常会有分辨率的问题，这时可以通过<code>setScreenMetrics()</code>函数来进行自动坐标放缩。这个函数会影响本章节的所有点击、长按、滑动等函数。通过设定脚本设计时的分辨率，使得脚本在其他分辨率下自动放缩坐标。</p>
<p>控件和坐标也可以相互结合。一些控件是无法点击的(clickable为false), 无法通过<code>.click()</code>函数来点击，这时如果安卓版本在7.0以上或者有root权限，就可以通过以下方式来点击：</p>
<pre><code>//获取这个控件
var widget = id(&quot;xxx&quot;).findOne();
//获取其中心位置并点击
click(widget.bounds().centerX(), widget.bounds().centerY());
//如果用root权限则用Tap
</code></pre>
<h2 id="setScreenMetrics-width-height"><a href="#setScreenMetrics-width-height" class="headerlink" title="setScreenMetrics(width, height)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=setscreenmetricswidth-height">setScreenMetrics(width, height)</a></h2><ul>
<li>width {number} 屏幕宽度，单位像素</li>
<li>height {number} 屏幕高度，单位像素</li>
</ul>
<p>设置脚本坐标点击所适合的屏幕宽高。如果脚本运行时，屏幕宽度不一致会自动放缩坐标。</p>
<p>例如在1920*1080的设备中，某个操作的代码为</p>
<pre><code>setScreenMetrics(1080, 1920);
click(800, 200);
longClick(300, 500);
</code></pre>
<p>那么在其他设备上AutoJs会自动放缩坐标以便脚本仍然有效。例如在540 * 960的屏幕中<code>click(800, 200)</code>实际上会点击位置(400, 100)。</p>
<h2 id="安卓7-0以上的触摸和手势模拟"><a href="#安卓7-0以上的触摸和手势模拟" class="headerlink" title="安卓7.0以上的触摸和手势模拟"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=%e5%ae%89%e5%8d%9370%e4%bb%a5%e4%b8%8a%e7%9a%84%e8%a7%a6%e6%91%b8%e5%92%8c%e6%89%8b%e5%8a%bf%e6%a8%a1%e6%8b%9f">安卓7.0以上的触摸和手势模拟</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p><strong>注意以下命令只有Android7.0及以上才有效</strong></p>
<h2 id="click-x-y"><a href="#click-x-y" class="headerlink" title="click(x, y)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=clickx-y">click(x, y)</a></h2><ul>
<li><code>x</code> {number} 要点击的坐标的x值</li>
<li><code>y</code> {number} 要点击的坐标的y值</li>
</ul>
<p>模拟点击坐标(x, y)，并返回是否点击成功。只有在点击执行完成后脚本才继续执行。</p>
<p>一般而言，只有点击过程(大约150毫秒)中被其他事件中断(例如用户自行点击)才会点击失败。</p>
<p>使用该函数模拟连续点击时可能有点击速度过慢的问题，这时可以用<code>press()</code>函数代替。</p>
<h2 id="longClick-x-y"><a href="#longClick-x-y" class="headerlink" title="longClick(x, y)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=longclickx-y">longClick(x, y)</a></h2><ul>
<li><code>x</code> {number} 要长按的坐标的x值</li>
<li><code>y</code> {number} 要长按的坐标的y值</li>
</ul>
<p>模拟长按坐标(x, y), 并返回是否成功。只有在长按执行完成（大约600毫秒）时脚本才会继续执行。</p>
<p>一般而言，只有长按过程中被其他事件中断(例如用户自行点击)才会长按失败。</p>
<h2 id="press-x-y-duration"><a href="#press-x-y-duration" class="headerlink" title="press(x, y, duration)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=pressx-y-duration">press(x, y, duration)</a></h2><ul>
<li><code>x</code> {number} 要按住的坐标的x值</li>
<li><code>y</code> {number} 要按住的坐标的y值</li>
<li><code>duration</code> {number} 按住时长，单位毫秒</li>
</ul>
<p>模拟按住坐标(x, y), 并返回是否成功。只有按住操作执行完成时脚本才会继续执行。</p>
<p>如果按住时间过短，那么会被系统认为是点击；如果时长超过500毫秒，则认为是长按。</p>
<p>一般而言，只有按住过程中被其他事件中断才会操作失败。</p>
<p>一个连点器的例子如下：</p>
<pre><code>//循环100次
for(var i = 0; i &lt; 100; i++)&#123;
  //点击位置(500, 1000), 每次用时1毫秒
  press(500, 1000, 1);
&#125;
</code></pre>
<h2 id="swipe-x1-y1-x2-y2-duration"><a href="#swipe-x1-y1-x2-y2-duration" class="headerlink" title="swipe(x1, y1, x2, y2, duration)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=swipex1-y1-x2-y2-duration">swipe(x1, y1, x2, y2, duration)</a></h2><ul>
<li><code>x1</code> {number} 滑动的起始坐标的x值</li>
<li><code>y1</code> {number} 滑动的起始坐标的y值</li>
<li><code>x2</code> {number} 滑动的结束坐标的x值</li>
<li><code>y2</code> {number} 滑动的结束坐标的y值</li>
<li><code>duration</code> {number} 滑动时长，单位毫秒</li>
</ul>
<p>模拟从坐标(x1, y1)滑动到坐标(x2, y2)，并返回是否成功。只有滑动操作执行完成时脚本才会继续执行。</p>
<p>一般而言，只有滑动过程中被其他事件中断才会滑动失败。</p>
<h2 id="gesture-duration-x1-y1-x2-y2-…"><a href="#gesture-duration-x1-y1-x2-y2-…" class="headerlink" title="gesture(duration, [x1, y1], [x2, y2], …)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=gestureduration-x1-y1-x2-y2-">gesture(duration, [x1, y1], [x2, y2], …)</a></h2><ul>
<li><code>duration</code> {number} 手势的时长</li>
<li>[x, y] … 手势滑动路径的一系列坐标</li>
</ul>
<p>模拟手势操作。例如<code>gesture(1000, [0, 0], [500, 500], [500, 1000])</code>为模拟一个从(0, 0)到(500, 500)到(500, 100)的手势操作，时长为2秒。</p>
<h2 id="gestures-delay1-duration1-x1-y1-x2-y2-…-delay2-duration2-x3-y3-x4-y4-…-…"><a href="#gestures-delay1-duration1-x1-y1-x2-y2-…-delay2-duration2-x3-y3-x4-y4-…-…" class="headerlink" title="gestures([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=gesturesdelay1-duration1-x1-y1-x2-y2-delay2-duration2-x3-y3-x4-y4-">gestures([delay1, duration1, [x1, y1], [x2, y2], …], [delay2, duration2, [x3, y3], [x4, y4], …], …)</a></h2><p>同时模拟多个手势。每个手势的参数为[delay, duration, 坐标], delay为延迟多久(毫秒)才执行该手势；duration为手势执行时长；坐标为手势经过的点的坐标。其中delay参数可以省略，默认为0。</p>
<p>例如手指捏合：</p>
<pre><code>gestures([0, 500, [800, 300], [500, 1000]],
         [0, 500, [300, 1500], [500, 1000]]);
</code></pre>
<h2 id="RootAutomator"><a href="#RootAutomator" class="headerlink" title="RootAutomator"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomator">RootAutomator</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>RootAutomator是一个使用root权限来模拟触摸的对象，用它可以完成触摸与多点触摸，并且这些动作的执行没有延迟。</p>
<p>一个脚本中最好只存在一个RootAutomator，并且保证脚本结束退出他。可以在exit事件中退出RootAutomator，例如：</p>
<pre><code>var ra = new RootAutomator();
events.on(&#39;exit&#39;, function()&#123;
  ra.exit();
&#125;);
//执行一些点击操作
...
</code></pre>
<p><strong>注意以下命令需要root权限</strong></p>
<h2 id="RootAutomator-tap-x-y-id"><a href="#RootAutomator-tap-x-y-id" class="headerlink" title="RootAutomator.tap(x, y[, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatortapx-y-id">RootAutomator.tap(x, y[, id])</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1，可以通过setDefaultId指定。</li>
</ul>
<p>点击位置(x, y)。其中id是一个整数值，用于区分多点触摸，不同的id表示不同的”手指”，例如：</p>
<pre><code>var ra = new RootAutomator();
//让&quot;手指1&quot;点击位置(100, 100)
ra.tap(100, 100, 1);
//让&quot;手指2&quot;点击位置(200, 200);
ra.tap(200, 200, 2);
ra.exit();
</code></pre>
<p>如果不需要多点触摸，则不需要id这个参数。 多点触摸通常用于手势或游戏操作，例如模拟双指捏合、双指上滑等。</p>
<p>某些情况下可能存在tap点击无反应的情况，这时可以用<code>RootAutomator.press()</code>函数代替。</p>
<h2 id="RootAutomator-swipe-x1-x2-y1-y2-duration-id"><a href="#RootAutomator-swipe-x1-x2-y1-y2-duration-id" class="headerlink" title="RootAutomator.swipe(x1, x2, y1, y2[, duration, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatorswipex1-x2-y1-y2-duration-id">RootAutomator.swipe(x1, x2, y1, y2[, duration, id])</a></h2><ul>
<li><code>x1</code> {number} 滑动起点横坐标</li>
<li><code>y1</code> {number} 滑动起点纵坐标</li>
<li><code>x2</code> {number} 滑动终点横坐标</li>
<li><code>y2</code> {number} 滑动终点纵坐标</li>
<li><code>duration</code> {number} 滑动时长，单位毫秒，默认值为300</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟一次从(x1, y1)到(x2, y2)的时间为duration毫秒的滑动。</p>
<h2 id="RootAutomator-press-x-y-duration-id"><a href="#RootAutomator-press-x-y-duration-id" class="headerlink" title="RootAutomator.press(x, y, duration[, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatorpressx-y-duration-id">RootAutomator.press(x, y, duration[, id])</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
<li><code>duration</code> {number} 按下时长</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟按下位置(x, y)，时长为duration毫秒。</p>
<h2 id="RootAutomator-longPress-x-y-id"><a href="#RootAutomator-longPress-x-y-id" class="headerlink" title="RootAutomator.longPress(x, y[, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatorlongpressx-y-id">RootAutomator.longPress(x, y[, id])</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
<li><code>duration</code> {number} 按下时长</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟长按位置(x, y)。</p>
<p>以上为简单模拟触摸操作的函数。如果要模拟一些复杂的手势，需要更底层的函数。</p>
<h2 id="RootAutomator-touchDown-x-y-id"><a href="#RootAutomator-touchDown-x-y-id" class="headerlink" title="RootAutomator.touchDown(x, y[, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatortouchdownx-y-id">RootAutomator.touchDown(x, y[, id])</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟手指按下位置(x, y)。</p>
<h2 id="RootAutomator-touchMove-x-y-id"><a href="#RootAutomator-touchMove-x-y-id" class="headerlink" title="RootAutomator.touchMove(x, y[, id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatortouchmovex-y-id">RootAutomator.touchMove(x, y[, id])</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟移动手指到位置(x, y)。</p>
<h2 id="RootAutomator-touchUp-id"><a href="#RootAutomator-touchUp-id" class="headerlink" title="RootAutomator.touchUp([id])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=rootautomatortouchupid">RootAutomator.touchUp([id])</a></h2><ul>
<li><code>id</code> {number} 多点触摸id，可选，默认为1</li>
</ul>
<p>模拟手指弹起。</p>
<h2 id="使用root权限点击和滑动的简单命令"><a href="#使用root权限点击和滑动的简单命令" class="headerlink" title="使用root权限点击和滑动的简单命令"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=%e4%bd%bf%e7%94%a8root%e6%9d%83%e9%99%90%e7%82%b9%e5%87%bb%e5%92%8c%e6%bb%91%e5%8a%a8%e7%9a%84%e7%ae%80%e5%8d%95%e5%91%bd%e4%bb%a4">使用root权限点击和滑动的简单命令</a></h2><blockquote>
<p>稳定性: 实验</p>
</blockquote>
<p>注意：本章节的函数在后续版本很可能有改动！请勿过分依赖本章节函数的副作用。推荐使用<code>RootAutomator</code>代替本章节的触摸函数。</p>
<p>以下函数均需要root权限，可以实现任意位置的点击、滑动等。</p>
<ul>
<li>这些函数通常首字母大写以表示其特殊的权限。</li>
<li>这些函数均不返回任何值。</li>
<li>并且，这些函数的执行是异步的、非阻塞的，在不同机型上所用的时间不同。脚本不会等待动作执行完成才继续执行。因此最好在每个函数之后加上适当的sleep来达到期望的效果。</li>
</ul>
<p>例如:</p>
<pre><code>Tap(100, 100);
sleep(500);
</code></pre>
<p>注意，动作的执行可能无法被停止，例如：</p>
<pre><code>for(var i = 0; i &lt; 100; i++)&#123;
  Tap(100, 100);
&#125;
</code></pre>
<p>这段代码执行后可能会出现在任务管理中停止脚本后点击仍然继续的情况。 因此，强烈建议在每个动作后加上延时：</p>
<pre><code>for(var i = 0; i &lt; 100; i++)&#123;
  Tap(100, 100);
  sleep(500);
&#125;
</code></pre>
<h2 id="Tap-x-y"><a href="#Tap-x-y" class="headerlink" title="Tap(x, y)"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=tapx-y">Tap(x, y)</a></h2><ul>
<li>x, y {number} 要点击的坐标。</li>
</ul>
<p>点击位置(x, y), 您可以通过”开发者选项”开启指针位置来确定点击坐标。</p>
<h2 id="Swipe-x1-y1-x2-y2-duration"><a href="#Swipe-x1-y1-x2-y2-duration" class="headerlink" title="Swipe(x1, y1, x2, y2, [duration])"></a><a href="http://doc.autoxjs.com/#/coordinatesBasedAutomation?id=swipex1-y1-x2-y2-duration-1">Swipe(x1, y1, x2, y2, [duration])</a></h2><ul>
<li>x1, y1 {number} 滑动起点的坐标</li>
<li>x2, y2 {number} 滑动终点的坐标</li>
<li>duration {number} 滑动动作所用的时间</li>
</ul>
<p>滑动。从(x1, y1)位置滑动到(x2, y2)位置。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>基于控件的操作</title>
    <url>//blog/note/code/AutoXjs/UiSelect.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基于控件的操作"><a href="#基于控件的操作" class="headerlink" title="基于控件的操作"></a>基于控件的操作</h1><p>基于控件的操作指的是选择屏幕上的控件，获取其信息或对其进行操作。对于一般软件而言，基于控件的操作对不同机型有很好的兼容性；</p>
<p>但是对于游戏而言，由于游戏界面并不是由控件构成，无法采用本章节的方法，也无法使用本章节的函数。有关游戏脚本的编写，请参考《基于坐标的操作》。</p>
<p>基于控件的操作依赖于无障碍服务，因此最好在脚本开头使用<code>auto()</code>函数来确保无障碍服务已经启用。如果运行到某个需要权限的语句无障碍服务并没启动，则会抛出异常并跳转到无障碍服务界面。这样的用户体验并不好，因为需要重新运行脚本，后续会加入等待无障碍服务启动并让脚本继续运行的函数。</p>
<p>您也可以在脚本开头使用<code>&quot;auto&quot;;</code>表示这个脚本需要无障碍服务，但是不推荐这种做法，因为这个标记必须在脚本的最开头(前面不能有注释或其他语句、空格等)，我们推荐使用<code>auto()</code>函数来确保无障碍服务已启用。</p>
<h1 id="检测是否开启无障碍服务"><a href="#检测是否开启无障碍服务" class="headerlink" title="检测是否开启无障碍服务"></a>检测是否开启无障碍服务</h1><table>
<thead>
<tr>
<th>方法</th>
<th>参数选项</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>auto(mode)</td>
<td>mode的可选值有两个<code>&quot;fast&quot;</code>或者<code>&quot;normal&quot;</code>。默认值（空值）就是<code>&quot;normal&quot;</code>。一般默认就行。</td>
<td>能设置是否缓存控件，缓存控件后，执行控件的速度更快。不推荐使用。</td>
</tr>
<tr>
<td>auto.waitFor()</td>
<td>无参数设置。</td>
<td>未启用权限，则跳转到开启页面，待用户开启后继续执行。比较人性化。</td>
</tr>
<tr>
<td>auto.setMode(mode)</td>
<td>mode的可选值有两个<code>&quot;fast&quot;</code>或者<code>&quot;normal&quot;</code>。默认值（空值）就是<code>&quot;normal&quot;</code>。一般默认就行。</td>
<td>结合了前两者的特点。</td>
</tr>
</tbody></table>
<h2 id="auto-mode"><a href="#auto-mode" class="headerlink" title="auto([mode])"></a>auto([mode])</h2><ul>
<li><code>mode</code> 模式</li>
</ul>
<p>检查无障碍服务是否已经启用，如果没有启用则抛出异常并跳转到无障碍服务启用界面；同时设置无障碍模式为 mode。mode 的可选值为：</p>
<ul>
<li><code>fast</code> 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。</li>
<li><code>normal</code> 正常模式，默认。</li>
</ul>
<p>如果不加 mode 参数，则为正常模式。</p>
<p>建议使用<code>auto.waitFor()</code>和<code>auto.setMode()</code>代替该函数，因为<code>auto()</code>函数如果无障碍服务未启动会停止脚本；而<code>auto.waitFor()</code>则会在在无障碍服务启动后继续运行。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">auto</span>(<span class="string">&quot;fast&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>示例 2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">auto</span>();</span><br></pre></td></tr></table></figure>



<h2 id="auto-waitFor"><a href="#auto-waitFor" class="headerlink" title="auto.waitFor()"></a>auto.waitFor()</h2><p>检查无障碍服务是否已经启用，如果没有启用则跳转到无障碍服务启用界面，并等待无障碍服务启动；当无障碍服务启动后脚本会继续运行。</p>
<h2 id="auto-setMode-mode"><a href="#auto-setMode-mode" class="headerlink" title="auto.setMode(mode)"></a>auto.setMode(mode)</h2><ul>
<li><code>mode</code> 模式</li>
</ul>
<p>设置无障碍模式为 mode。mode 的可选值为：</p>
<ul>
<li><code>fast</code> 快速模式。该模式下会启用控件缓存，从而选择器获取屏幕控件更快。对于需要快速的控件查看和操作的脚本可以使用该模式，一般脚本则没有必要使用该函数。</li>
<li><code>normal</code> 正常模式，默认。</li>
</ul>
<hr>
<h1 id="关于控件的基础知识"><a href="#关于控件的基础知识" class="headerlink" title="关于控件的基础知识"></a>关于控件的基础知识</h1><p><code>UiSelector</code> 即选择器，用于通过各种条件选取屏幕上的控件，再对这些控件进行点击、长按等动作。这里需要先简单介绍一下控件和界面的相关知识。</p>
<p>一般软件的界面是由一个个控件构成的，例如图片部分是一个图片控件(ImageView)，文字部分是一个文字控件(TextView)；同时，通过各种布局来决定各个控件的位置，例如，线性布局(LinearLayout)里面的控件都是按水平或垂直一次叠放的，列表布局(AbsListView)则是以列表的形式显示控件。</p>
<p>控件有各种属性，包括文本(text), 描述(desc), 类名(className), id 等等。我们通常用一个控件的属性来找到这个控件，例如，想要点击 QQ 聊天窗口的”发送”按钮，我们就可以通过他的文本属性为”发送”来找到这个控件并点击他，具体代码为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sendButton = <span class="title function_">text</span>(<span class="string">&quot;发送&quot;</span>).<span class="title function_">findOne</span>();</span><br><span class="line">sendButton.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure>
<p>在这个例子中, <code>text(&quot;发送&quot;)</code>表示一个条件(文本属性为”发送”)，<code>findOne()</code>表示基于这个条件找到一个符合条件的控件，从而我们可以得到发送按钮 sendButton，再执行<code>sendButton.click()</code>即可点击”发送”按钮。</p>
<p>用文本属性来定位按钮控件、文本控件通常十分有效。但是，如果一个控件是图片控件，比如 Auto.js 主界面右上角的搜索图标，他没有文本属性，这时需要其他属性来定位他。我们如何查看他有什么属性呢？首先打开悬浮窗和无障碍服务，点击蓝色的图标(布局分析), 可以看到以下界面：</p>
<p>之后我们点击搜索图标，可以看到他有以下属性：</p>
<p>我们注意到这个图标的 desc(描述)属性为”搜索”，那么我们就可以通过 desc 属性来定位这个控件，得到点击搜索图标的代码为:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">desc</span>(<span class="string">&quot;搜索&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure>
<p>可能心细的你可能注意到了，这个控件还有很多其他的属性，例如 checked, className, clickable 等等，为什么不用这些属性来定位搜索图标呢？答案是，其他控件也有这些值相同的属性、尝试一下你就可以发现很多其他控件的 checked 属性和搜索控件一样都是<code>false</code>，如果我们用<code>checked(false)</code>作为条件，将会找到很多控件，而无法确定哪一个是搜索图标。</p>
<p>因此，要找到我们想要的那个控件，<strong>选择器的条件通常需要是可唯一确定控件的</strong>。<br>我们通常用一个独一无二的属性来定位一个控件，例如这个例子中就没有其他控件的 desc(描述)属性为”搜索”。</p>
<p>另外，对于这个搜索图标而言，id 属性也是唯一的，我们也可以用<code>id(&quot;action_search&quot;).findOne().click()</code>来点击这个控件。如果一个控件有 id 属性，那么这个属性很可能是唯一的，除了以下几种情况：</p>
<ul>
<li>QQ 的控件的 id 属性很多都是”name”，也就是在 QQ 界面难以通过 id 来定位一个控件</li>
<li>列表中的控件，比如 QQ 联系人列表，微信联系人列表等</li>
</ul>
<p>尽管 id 属性很方便，但也不总是最方便的，例如对于微信和网易云音乐，每次更新他的控件 id 都会变化，导致了相同代码对于不同版本的微信、网易云音乐并不兼容。</p>
<p>除了这些属性外，主要还有以下几种属性：</p>
<ul>
<li><code>className</code> 类名。类名表示一个控件的类型，例如文本控件为”android.widget.TextView”, 图片控件为”android.widget.ImageView”等。</li>
<li><code>packageName</code> 包名。包名表示控件所在的应用包名，例如 QQ 界面的控件的包名为”com.tencent.mobileqq”。</li>
<li><code>bounds</code> 控件在屏幕上的范围。</li>
<li><code>drawingOrder</code> 控件在父控件的绘制顺序。</li>
<li><code>indexInParent</code> 控件在父控件的位置。</li>
<li><code>clickable</code> 控件是否可点击。</li>
<li><code>longClickable</code> 控件是否可长按。</li>
<li><code>checkable</code> 控件是否可勾选。</li>
<li><code>checked</code> 控件是否可已勾选。</li>
<li><code>scrollable</code> 控件是否可滑动。</li>
<li><code>selected</code> 控件是否已选择。</li>
<li><code>editable</code> 控件是否可编辑。</li>
<li><code>visibleToUser</code> 控件是否可见。</li>
<li><code>enabled</code> 控件是否已启用。</li>
<li><code>depth</code> 控件的布局深度。</li>
</ul>
<p>有时候只靠一个属性并不能唯一确定一个控件，这时需要通过属性的组合来完成定位，例如<code>className(&quot;ImageView&quot;).depth(10).findOne().click()</code>，通过链式调用来组合条件。</p>
<p>通常用这些技巧便可以解决大部分问题，即使解决不了问题，也可以通过布局分析的”生成代码”功能来尝试生成一些选择器代码。接下来的问题便是对选取的控件进行操作，包括：</p>
<ul>
<li><code>click()</code> 点击。点击一个控件，前提是这个控件的 clickable 属性为 true</li>
<li><code>longClick()</code> 长按。长按一个控件，前提是这个控件的 longClickable 属性为 true</li>
<li><code>setText()</code> 设置文本，用于编辑框控件设置文本。</li>
<li><code>scrollForward()</code>, <code>scrollBackward()</code> 滑动。滑动一个控件(列表等), 前提是这个控件的 scrollable 属性为 true</li>
<li><code>exits()</code> 判断控件是否存在</li>
<li><code>waitFor()</code> 等待控件出现</li>
</ul>
<p>这些操作包含了绝大部分控件操作。根据这些我们可以很容易写出一个”刷屏”脚本(代码仅为示例，请不要在别人的群里测试，否则容易被踢):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="title function_">className</span>(<span class="string">&quot;EditText&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">setText</span>(<span class="string">&quot;刷屏...&quot;</span>);</span><br><span class="line">    <span class="title function_">text</span>(<span class="string">&quot;发送&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">clicK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码也可以写成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="title function_">className</span>(<span class="string">&quot;EditText&quot;</span>).<span class="title function_">setText</span>(<span class="string">&quot;刷屏...&quot;</span>);</span><br><span class="line">    <span class="title function_">text</span>(<span class="string">&quot;发送&quot;</span>).<span class="title function_">clicK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不加<code>findOne()</code>而直接进行操作，则选择器会找出<strong>所有</strong>符合条件的控件并操作。</p>
<p>另外一个比较常用的操作的滑动。滑动操作的第一步是找到需要滑动的控件，例如要滑动 QQ 消息列表则在悬浮窗布局层次分析中找到<code>AbsListView</code>，这个控件就是消息列表控件，如下图：</p>
<p>长按可查看控件信息，注意到其 scrollable 属性为 true，并找出其 id 为”recent_chat_list”，从而下滑 QQ 消息列表的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">id</span>(<span class="string">&quot;recent_chat_list&quot;</span>).<span class="title function_">className</span>(<span class="string">&quot;AbsListView&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">scrollForward</span>();</span><br></pre></td></tr></table></figure>
<p><code>scrollForward()</code>为向前滑，包括下滑和右滑。</p>
<p>选择器的入门教程暂且要这里，更多信息可以查看下面的文档和选择器进阶。</p>
<hr>
<h1 id="简单控件操作"><a href="#简单控件操作" class="headerlink" title="简单控件操作"></a>简单控件操作</h1><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>这里提供了一些模拟简单操作的函数，例如点击文字、模拟按键等。这些函数可以直接作为全局函数使用。</p>
<h2 id="点击指定文本"><a href="#点击指定文本" class="headerlink" title="点击指定文本"></a>点击指定文本</h2><blockquote>
<p>click( text [,i] )</p>
</blockquote>
<ul>
<li><code>text</code> {string} 要点击的文本</li>
<li><code>i</code> {number} 【可选参数】如果相同的文本在屏幕中出现多次，则 i 表示要点击第几个文本, i 从 0 开始计算</li>
</ul>
<p>返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。</p>
<p>该函数可以点击大部分包含文字的按钮。例如微信主界面下方的”微信”, “联系人”, “发现”, “我”的按钮。<br>通常与 while 同时使用以便点击按钮直至成功。例如:</p>
<pre><code>while(!click(&quot;扫一扫&quot;));
</code></pre>
<p>当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部点击成功。</p>
<p>i 是从 0 开始计算的, 也就是, <code>click(&quot;啦啦啦&quot;, 0)</code>表示点击屏幕上第一个”啦啦啦”, <code>click(&quot;啦啦啦&quot;, 1)</code>表示点击屏幕上第二个”啦啦啦”。</p>
<blockquote>
<p>文本所在区域指的是，从文本处向其父视图寻找，直至发现一个可点击的部件为止。</p>
</blockquote>
<h2 id="点击指定矩形大小控件"><a href="#点击指定矩形大小控件" class="headerlink" title="点击指定矩形大小控件"></a>点击指定矩形大小控件</h2><blockquote>
<p>click( left , top , bottom , right )</p>
</blockquote>
<ul>
<li><code>left</code> {number} 要点击的长方形区域左边与屏幕左边的像素距离</li>
<li><code>top</code> {number} 要点击的长方形区域上边与屏幕上边的像素距离</li>
<li><code>bottom</code> {number} 要点击的长方形区域下边与屏幕下边的像素距离</li>
<li><code>right</code> {number} 要点击的长方形区域右边与屏幕右边的像素距离</li>
</ul>
<p><strong>注意，该函数一般只用于录制的脚本中使用，在自己写的代码中使用该函数一般不要使用该函数。</strong></p>
<p>点击在指定区域的控件。当屏幕中并未包含与该区域<strong>严格匹配</strong>的区域，或者该区域不能点击时返回 false，否则返回 true。</p>
<p>有些按钮或者部件是图标而不是文字（例如发送朋友圈的照相机图标以及 QQ 下方的消息、联系人、动态图标），这时不能通过<code>click(text, i)</code>来点击，可以通过描述图标所在的区域来点击。left, bottom, top, right 描述的就是点击的区域。</p>
<p>至于要定位点击的区域，可以在悬浮窗使用布局分析工具查看控件的 bounds 属性。</p>
<p>通过无障碍服务录制脚本会生成该语句。</p>
<h2 id="长按指定文本"><a href="#长按指定文本" class="headerlink" title="长按指定文本"></a>长按指定文本</h2><blockquote>
<p>longClick( text [, i] )</p>
</blockquote>
<ul>
<li><code>text</code> {string} 要长按的文本</li>
<li><code>i</code> {number} 【可选参数】如果相同的文本在屏幕中出现多次，则 i 表示要长按第几个文本, i 从 0 开始计算</li>
</ul>
<p>返回是否点击成功。当屏幕中并未包含该文本，或者该文本所在区域不能点击时返回 false，否则返回 true。</p>
<p>当不指定参数 i 时则会尝试点击屏幕上出现的所有文字 text 并返回是否全部长按成功。</p>
<ul>
<li><code>i</code> {number} 要滑动的控件序号</li>
</ul>
<p>找到第 i+1 个可滑动控件上滑或<strong>左滑</strong>。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。</p>
<p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件上滑或左滑，例如微信消息列表等。</p>
<p>参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如<code>scrollUp(0)</code>为滑动第一个可滑动控件。</p>
<ul>
<li><code>i</code> {number} 要滑动的控件序号</li>
</ul>
<p>找到第 i+1 个可滑动控件下滑或<strong>右滑</strong>。返回是否操作成功。屏幕上没有可滑动的控件时返回 false。</p>
<p>另外不加参数时<code>scrollUp()</code>会寻找面积最大的可滑动的控件下滑或右滑。</p>
<p>参数为一个整数 i 时会找到第 i + 1 个可滑动控件滑动。例如<code>scrollUp(0)</code>为滑动第一个可滑动控件。</p>
<h2 id="设置输入框文本"><a href="#设置输入框文本" class="headerlink" title="设置输入框文本"></a>设置输入框文本</h2><blockquote>
<p>setText( [i, ] text )</p>
</blockquote>
<ul>
<li>i {number} 【可选参数】表示要输入的为第 i + 1 个输入框</li>
<li>text {string} 要输入的文本</li>
</ul>
<p>返回是否输入成功。当找不到对应的文本框时返回 false。</p>
<p>不加参数 i 则会把所有输入框的文本都置为 text。例如<code>setText(&quot;测试&quot;)</code>。</p>
<p>这里的输入文本的意思是，把输入框的文本置为 text，而不是在原来的文本上追加。</p>
<h2 id="在输入框中的文本后追加新文本"><a href="#在输入框中的文本后追加新文本" class="headerlink" title="在输入框中的文本后追加新文本"></a>在输入框中的文本后追加新文本</h2><blockquote>
<p>input( [i, ] text )</p>
</blockquote>
<ul>
<li>i {number} 【可选参数】表示要输入的为第 i + 1 个输入框</li>
<li>text {string} 要输入的文本</li>
</ul>
<p>返回是否输入成功。当找不到对应的文本框时返回 false。</p>
<p>不加参数 i 则会把所有输入框的文本追加内容 text。例如<code>input(&quot;测试&quot;)</code>。</p>
<hr>
<h1 id="控件选择器"><a href="#控件选择器" class="headerlink" title="控件选择器"></a>控件选择器</h1><h2 id="根据控件文本进行选择"><a href="#根据控件文本进行选择" class="headerlink" title="根据控件文本进行选择"></a>根据控件文本进行选择</h2><h3 id="选择指定文本的控件"><a href="#选择指定文本的控件" class="headerlink" title="选择指定文本的控件"></a>选择指定文本的控件</h3><blockquote>
<p>UiSelector.text( str )</p>
</blockquote>
<ul>
<li><code>str</code>  控件文本</li>
<li>返回选择器自身，以便链式调用</li>
</ul>
<p>为当前选择器增加：控件 “ text 等于字符串 str “ 的筛选条件。</p>
<p>控件的 <code>text (文本)</code> 属性是文本控件上的显示的文字，例如微信主界面最下方的【通讯录】控件的文本就是“通讯录”。</p>
<img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hup7qj539nj30j214k41a.jpg "  style="zoom:30%;" />






<h3 id="选择包含特定文本的控件"><a href="#选择包含特定文本的控件" class="headerlink" title="选择包含特定文本的控件"></a>选择包含特定文本的控件</h3><blockquote>
<p>UiSelector.textContains(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 要包含的字符串</li>
</ul>
<p>为当前选择器附加控件”text 需要包含字符串 str”的筛选条件。</p>
<p>这是一个比较有用的条件，例如 QQ 动态页和微博发现页上方的”大家都在搜….”的控件可以用<code>textContains(&quot;大家都在搜&quot;).findOne()</code>来获取。</p>
<h3 id="选择以特定文本开头的控件"><a href="#选择以特定文本开头的控件" class="headerlink" title="选择以特定文本开头的控件"></a>选择以特定文本开头的控件</h3><blockquote>
<p>UiSelector.textStartsWith(prefix)</p>
</blockquote>
<ul>
<li><code>prefix</code> {string} 前缀</li>
</ul>
<p>为当前选择器附加控件”text 需要以 prefix 开头”的筛选条件。</p>
<p>这也是一个比较有用的条件，例如要找出 Auto.js 脚本列表中名称以”QQ”开头的脚本的代码为<code>textStartsWith(&quot;QQ&quot;).find()</code>。</p>
<h3 id="选择以特定文本结尾的控件"><a href="#选择以特定文本结尾的控件" class="headerlink" title="选择以特定文本结尾的控件"></a>选择以特定文本结尾的控件</h3><blockquote>
<p>UiSelector.textEndsWith(suffix)</p>
</blockquote>
<ul>
<li>suffix {string} 后缀</li>
</ul>
<p>为当前选择器附加控件”text 需要以 suffix 结束”的筛选条件。</p>
<h3 id="根据正则表达式选择控件"><a href="#根据正则表达式选择控件" class="headerlink" title="根据正则表达式选择控件"></a>根据正则表达式选择控件</h3><blockquote>
<p>UiSelector.textMatches(reg)</p>
</blockquote>
<ul>
<li><code>reg</code> {string} | {Regex} 要满足的正则表达式。</li>
</ul>
<p>为当前选择器附加控件”text 需要满足正则表达式 reg”的条件。</p>
<p>有关正则表达式，可以查看<a href="http://www.runoob.com/Stringp/Stringpexample.html">正则表达式  菜鸟教程</a>。</p>
<p>需要注意的是，如果正则表达式是字符串，则需要使用<code>\\</code>来表达<code>\</code>(也即 Java 正则表达式的形式)，例如<code>textMatches(&quot;\\d+&quot;)</code>匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如<code>textMatches(/\d+/)</code>。但如果使用字符串的正则表达式则该字符串不能以”&#x2F;“同时以”&#x2F;“结束，也即不能写诸如<code>textMatches(&quot;/\\d+/&quot;)</code>的表达式，否则会被开头的”&#x2F;“和结尾的”&#x2F;“会被忽略。</p>
<h2 id="根据控件的描述（desc）进行选择"><a href="#根据控件的描述（desc）进行选择" class="headerlink" title="根据控件的描述（desc）进行选择"></a>根据控件的描述（desc）进行选择</h2><p>控件的 desc(描述，全称为 ContentDescription)属性是对一个控件的描述，例如网易云音乐右上角的放大镜图标的描述为搜索。要查看一个控件的描述，同样地可以借助悬浮窗查看。</p>
<h3 id="选择desc指定文本的控件"><a href="#选择desc指定文本的控件" class="headerlink" title="选择desc指定文本的控件"></a>选择desc指定文本的控件</h3><blockquote>
<p>UiSelector.desc(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 控件文本</li>
<li>返回 {UiSelector} 返回选择器自身以便链式调用</li>
</ul>
<p>为当前选择器附加控件”desc 等于字符串 str”的筛选条件。</p>
<p>desc 属性同样是定位控件的利器。</p>
<h3 id="选择desc包含特定文本的控件"><a href="#选择desc包含特定文本的控件" class="headerlink" title="选择desc包含特定文本的控件"></a>选择desc包含特定文本的控件</h3><blockquote>
<p>UiSelector.descContains(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 要包含的字符串</li>
</ul>
<p>为当前选择器附加控件”desc 需要包含字符串 str”的筛选条件。</p>
<h3 id="选择desc以特定文本开头的控件"><a href="#选择desc以特定文本开头的控件" class="headerlink" title="选择desc以特定文本开头的控件"></a>选择desc以特定文本开头的控件</h3><blockquote>
<p>UiSelector.descStartsWith(prefix)</p>
</blockquote>
<ul>
<li><code>prefix</code> {string} 前缀</li>
</ul>
<p>为当前选择器附加控件”desc 需要以 prefix 开头”的筛选条件。</p>
<h3 id="选择desc以特定文本结尾的控件"><a href="#选择desc以特定文本结尾的控件" class="headerlink" title="选择desc以特定文本结尾的控件"></a>选择desc以特定文本结尾的控件</h3><blockquote>
<p>UiSelector.descEndsWith(suffix)</p>
</blockquote>
<ul>
<li><code>suffix</code> {string} 后缀</li>
</ul>
<p>为当前选择器附加控件”desc 需要以 suffix 结束”的筛选条件。</p>
<h3 id="选择desc根据正则表达式选择控件"><a href="#选择desc根据正则表达式选择控件" class="headerlink" title="选择desc根据正则表达式选择控件"></a>选择desc根据正则表达式选择控件</h3><blockquote>
<p>UiSelector.descMatches(reg)</p>
</blockquote>
<ul>
<li><code>reg</code> {string} | {Regex} 要满足的正则表达式。</li>
</ul>
<p>为当前选择器附加控件”desc 需要满足正则表达式 reg”的条件。</p>
<p>有关正则表达式，可以查看<a href="http://www.runoob.com/Stringp/Stringpexample.html">正则表达式  菜鸟教程</a>。</p>
<p>需要注意的是，如果正则表达式是字符串，则需要使用<code>\\</code>来表达<code>\</code>(也即 Java 正则表达式的形式)，例如<code>textMatches(&quot;\\d+&quot;)</code>匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如<code>textMatches(/\d+/)</code>。但如果使用字符串的正则表达式则该字符串不能以”&#x2F;“同时以”&#x2F;“结束，也即不能写诸如<code>textMatches(&quot;/\\d+/&quot;)</code>的表达式，否则会被开头的”&#x2F;“和结尾的”&#x2F;“会被忽略。</p>
<hr>
<h2 id="根据控件id进行选择"><a href="#根据控件id进行选择" class="headerlink" title="根据控件id进行选择"></a>根据控件id进行选择</h2><h3 id="选择指定id的控件"><a href="#选择指定id的控件" class="headerlink" title="选择指定id的控件"></a>选择指定id的控件</h3><blockquote>
<p>UiSelector.id(resId)</p>
</blockquote>
<ul>
<li><code>resId</code> {string} 控件的 id，以”包名:id&#x2F;“开头，例如”com.tencent.mm:id&#x2F;send_btn”。<strong>也可以不指定包名</strong>，这时会以当前正在运行的应用的包名来补全 id。例如 id(“send_btn”),在 QQ 界面想当于 id(“com.tencent.mobileqq:id&#x2F;send_btn”)。</li>
</ul>
<p>为当前选择器附加”id 等于 resId”的筛选条件。</p>
<p>控件的 id 属性通常是可以用来确定控件的唯一标识，如果一个控件有 id，那么使用 id 来找到他是最好的方法。要查看屏幕上的控件的 id，可以开启悬浮窗并使用界面工具，点击相应控件即可查看。若查看到的控件 id 为 null, 表示该控件没有 id。另外，在列表中会出现多个控件的 id 相同的情况。例如微信的联系人列表，每个头像的 id 都是一样的。此时不能用 id 来唯一确定控件。</p>
<p>在 QQ 界面经常会出现多个 id 为”name”的控件，在微信上则每个版本的 id 都会变化。对于这些软件而言比较难用 id 定位控件。</p>
<h3 id="选择包含特定id的控件"><a href="#选择包含特定id的控件" class="headerlink" title="选择包含特定id的控件"></a>选择包含特定id的控件</h3><blockquote>
<p>UiSelector.idContains(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} id 要包含的字符串</li>
</ul>
<p>为当前选择器附加控件”id 包含字符串 str”的筛选条件。比较少用。</p>
<h3 id="选择以特定id开头的控件"><a href="#选择以特定id开头的控件" class="headerlink" title="选择以特定id开头的控件"></a>选择以特定id开头的控件</h3><blockquote>
<p>UiSelector.idStartsWith(prefix)</p>
</blockquote>
<ul>
<li><code>prefix</code> {string} id 前缀</li>
</ul>
<p>为当前选择器附加”id 需要以 prefix 开头”的筛选条件。比较少用。</p>
<h3 id="选择以特定id结尾的控件"><a href="#选择以特定id结尾的控件" class="headerlink" title="选择以特定id结尾的控件"></a>选择以特定id结尾的控件</h3><blockquote>
<p>UiSelector.idEndsWith(suffix)</p>
</blockquote>
<ul>
<li><code>suffix</code> {string} id 后缀</li>
</ul>
<p>为当前选择器附加”id 需要以 suffix 结束”的筛选条件。比较少用。</p>
<h3 id="根据id的正则表达式选择控件"><a href="#根据id的正则表达式选择控件" class="headerlink" title="根据id的正则表达式选择控件"></a>根据id的正则表达式选择控件</h3><blockquote>
<p>UiSelector.idMatches(reg)</p>
</blockquote>
<ul>
<li>reg {Regex} | {string} id 要满足的正则表达式</li>
</ul>
<p>附加 id 需要满足正则表达式。</p>
<p>需要注意的是，如果正则表达式是字符串，则需要使用<code>\\</code>来表达<code>\</code>(也即 Java 正则表达式的形式)，例如<code>textMatches(&quot;\\d+&quot;)</code>匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如<code>textMatches(/\d+/)</code>。但如果使用字符串的正则表达式则该字符串不能以”&#x2F;“同时以”&#x2F;“结束，也即不能写诸如<code>textMatches(&quot;/\\d+/&quot;)</code>的表达式，否则会被开头的”&#x2F;“和结尾的”&#x2F;“会被忽略。</p>
<pre><code>idMatches(&quot;[azAZ]+&quot;)
</code></pre>
<hr>
<h2 id="根据控件类名class进行选择"><a href="#根据控件类名class进行选择" class="headerlink" title="根据控件类名class进行选择"></a>根据控件类名class进行选择</h2><p>控件的 className(类名)表示一个控件的类别，例如文本控件的类名为 android.widget.TextView。<br>如果一个控件的类名以”android.widget.”开头，则可以省略这部分，例如文本控件可以直接用<code>className(&quot;TextView&quot;)</code>的选择器。</p>
<p>常见控件的类名如下：</p>
<ul>
<li><code>android.widget.TextView</code> 文本控件</li>
<li><code>android.widget.ImageView</code> 图片控件</li>
<li><code>android.widget.Button</code> 按钮控件</li>
<li><code>android.widget.EditText</code> 输入框控件</li>
<li><code>android.widget.AbsListView</code> 列表控件</li>
<li><code>android.widget.LinearLayout</code> 线性布局</li>
<li><code>android.widget.FrameLayout</code> 帧布局</li>
<li><code>android.widget.RelativeLayout</code> 相对布局</li>
<li><code>android.widget.RelativeLayout</code> 相对布局</li>
<li><code>android.support.v7.widget.RecyclerView</code> 通常也是列表控件</li>
</ul>
<h3 id="选择指定class的控件"><a href="#选择指定class的控件" class="headerlink" title="选择指定class的控件"></a>选择指定class的控件</h3><blockquote>
<p>UiSelector.className(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 控件文本</li>
<li>返回 {UiSelector} 返回选择器自身以便链式调用</li>
</ul>
<p>为当前选择器附加控件”className 等于字符串 str”的筛选条件。</p>
<h3 id="选择包含特定class文本的控件"><a href="#选择包含特定class文本的控件" class="headerlink" title="选择包含特定class文本的控件"></a>选择包含特定class文本的控件</h3><blockquote>
<p>UiSelector.classNameContains(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 要包含的字符串</li>
</ul>
<p>为当前选择器附加控件”className 需要包含字符串 str”的筛选条件。</p>
<h3 id="选择以特定class文本开头的控件"><a href="#选择以特定class文本开头的控件" class="headerlink" title="选择以特定class文本开头的控件"></a>选择以特定class文本开头的控件</h3><blockquote>
<p>UiSelector.classNameStartsWith(prefix)</p>
</blockquote>
<ul>
<li><code>prefix</code> {string} 前缀</li>
</ul>
<p>为当前选择器附加控件”className 需要以 prefix 开头”的筛选条件。</p>
<h3 id="选择以特定class文本结尾的控件"><a href="#选择以特定class文本结尾的控件" class="headerlink" title="选择以特定class文本结尾的控件"></a>选择以特定class文本结尾的控件</h3><blockquote>
<p>UiSelector.classNameEndsWith(suffix)</p>
</blockquote>
<ul>
<li><code>suffix</code> {string} 后缀</li>
</ul>
<p>为当前选择器附加控件”className 需要以 suffix 结束”的筛选条件。</p>
<h3 id="根据class正则表达式选择控件"><a href="#根据class正则表达式选择控件" class="headerlink" title="根据class正则表达式选择控件"></a>根据class正则表达式选择控件</h3><blockquote>
<p>UiSelector.classNameMatches(reg)</p>
</blockquote>
<ul>
<li><code>reg</code> {string} | {Regex} 要满足的正则表达式。</li>
</ul>
<p>为当前选择器附加控件”className 需要满足正则表达式 reg”的条件。</p>
<p>有关正则表达式，可以查看<a href="http://www.runoob.com/Stringp/Stringpexample.html">正则表达式  菜鸟教程</a>。</p>
<p>需要注意的是，如果正则表达式是字符串，则需要使用<code>\\</code>来表达<code>\</code>(也即 Java 正则表达式的形式)，例如<code>textMatches(&quot;\\d+&quot;)</code>匹配多位数字；但如果使用 JavaScript 语法的正则表达式则不需要，例如<code>textMatches(/\d+/)</code>。但如果使用字符串的正则表达式则该字符串不能以”&#x2F;“同时以”&#x2F;“结束，也即不能写诸如<code>textMatches(&quot;/\\d+/&quot;)</code>的表达式，否则会被开头的”&#x2F;“和结尾的”&#x2F;“会被忽略。</p>
<hr>
<h2 id="根据控件所属包名进行选择-不常用"><a href="#根据控件所属包名进行选择-不常用" class="headerlink" title="根据控件所属包名进行选择[不常用]"></a>根据控件所属包名进行选择[不常用]</h2><p>控件的 packageName 表示控件所属界面的应用包名。例如微信的包名为”com.tencent.mm”, 那么微信界面的控件的 packageName 为”com.tencent.mm”。</p>
<p>要查看一个应用的包名，可以用函数<code>app.getPackageName()</code>获取，例如<code>toast(app.getPackageName(&quot;微信&quot;))</code>。</p>
<h3 id="选择指定文本的控件-1"><a href="#选择指定文本的控件-1" class="headerlink" title="选择指定文本的控件"></a>选择指定文本的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorpackagenamestr">UiSelector.packageName(str)</a></p>
<ul>
<li><code>str</code> {string} 控件文本</li>
<li>返回 {UiSelector} 返回选择器自身以便链式调用</li>
</ul>
<p>为当前选择器附加控件”packageName 等于字符串 str”的筛选条件。</p>
<h3 id="选择包含特定文本的控件-1"><a href="#选择包含特定文本的控件-1" class="headerlink" title="选择包含特定文本的控件"></a>选择包含特定文本的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorpackagenamecontainsstr">UiSelector.packageNameContains(str)</a></p>
<ul>
<li><code>str</code> {string} 要包含的字符串</li>
</ul>
<p>为当前选择器附加控件”packageName 需要包含字符串 str”的筛选条件。</p>
<h3 id="选择以特定文本开头的控件-1"><a href="#选择以特定文本开头的控件-1" class="headerlink" title="选择以特定文本开头的控件"></a>选择以特定文本开头的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorpackagenamestartswithprefix">UiSelector.packageNameStartsWith(prefix)</a></p>
<ul>
<li><code>prefix</code> {string} 前缀</li>
</ul>
<p>为当前选择器附加控件”packageName 需要以 prefix 开头”的筛选条件。</p>
<h3 id="选择以特定文本结尾的控件-1"><a href="#选择以特定文本结尾的控件-1" class="headerlink" title="选择以特定文本结尾的控件"></a>选择以特定文本结尾的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorpackagenameendswithsuffix">UiSelector.packageNameEndsWith(suffix)</a></p>
<ul>
<li><code>suffix</code> {string} 后缀</li>
</ul>
<p>为当前选择器附加控件”packageName 需要以 suffix 结束”的筛选条件。</p>
<h3 id="根据正则表达式选择控件-1"><a href="#根据正则表达式选择控件-1" class="headerlink" title="根据正则表达式选择控件"></a>根据正则表达式选择控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorpackagenamematchesreg">UiSelector.packageNameMatches(reg)</a></p>
<ul>
<li><code>reg</code> {string} | {Regex} 要满足的正则表达式。</li>
</ul>
<p>为当前选择器附加控件”packageName 需要满足正则表达式 reg”的条件。</p>
<p>有关正则表达式，可以查看<a href="http://www.runoob.com/Stringp/Stringpexample.html">正则表达式  菜鸟教程</a>。</p>
<hr>
<h2 id="根据范围来查找控件"><a href="#根据范围来查找控件" class="headerlink" title="根据范围来查找控件"></a>根据范围来查找控件</h2><h3 id="查找指定矩形大小的控件"><a href="#查找指定矩形大小的控件" class="headerlink" title="查找指定矩形大小的控件"></a>查找指定矩形大小的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorboundslefttoprightbuttom">UiSelector.bounds(left, top, right, buttom)</a></p>
<ul>
<li><code>left</code> {number} 控件左边缘与屏幕左边的距离</li>
<li><code>top</code> {number} 控件上边缘与屏幕上边的距离</li>
<li><code>right</code> {number} 控件右边缘与屏幕左边的距离</li>
<li><code>bottom</code> {number} 控件下边缘与屏幕上边的距离</li>
</ul>
<p>一个控件的 bounds 属性为这个控件在屏幕上显示的范围。我们可以用这个范围来定位这个控件。尽管用这个方法定位控件对于静态页面十分准确，却无法兼容不同分辨率的设备；同时对于列表页面等动态页面无法达到效果，因此使用<strong>不推荐该选择器</strong>。</p>
<p>注意参数的这四个数字不能随意填写，必须精确的填写控件的四个边界才能找到该控件。例如，要点击 QQ 主界面的右上角加号，我们用布局分析查看该控件的属性，如下图：</p>
<p>可以看到 bounds 属性为(951, 67, 1080, 196)，此时使用代码<code>bounds(951, 67, 1080, 196).clickable().click()</code>即可点击该控件。</p>
<h3 id="在某区域内查找控件"><a href="#在某区域内查找控件" class="headerlink" title="在某区域内查找控件"></a>在某区域内查找控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorboundsinsidelefttoprightbuttom">UiSelector.boundsInside(left, top, right, buttom)</a></p>
<ul>
<li><code>left</code> {number} 范围左边缘与屏幕左边的距离</li>
<li><code>top</code> {number} 范围上边缘与屏幕上边的距离</li>
<li><code>right</code> {number} 范围右边缘与屏幕左边的距离</li>
<li><code>bottom</code> {number} 范围下边缘与屏幕上边的距离</li>
</ul>
<p>为当前选择器附加控件”bounds 需要在 left, top, right, buttom 构成的范围里面”的条件。</p>
<p>这个条件用于限制选择器在某一个区域选择控件。例如要在屏幕上半部分寻找文本控件 TextView，代码为:</p>
<pre><code>var w = className(&quot;TextView&quot;).boundsInside(0, 0, device.width, device.height / 2).findOne();
log(w.text());
</code></pre>
<p>其中我们使用了<code>device.width</code>来获取屏幕宽度，<code>device.height</code>来获取屏幕高度。</p>
<h3 id="查找包含某范围的控件"><a href="#查找包含某范围的控件" class="headerlink" title="查找包含某范围的控件"></a>查找包含某范围的控件</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorboundscontainslefttoprightbuttom">UiSelector.boundsContains(left, top, right, buttom)</a></p>
<ul>
<li><code>left</code> {number} 范围左边缘与屏幕左边的距离</li>
<li><code>top</code> {number} 范围上边缘与屏幕上边的距离</li>
<li><code>right</code> {number} 范围右边缘与屏幕左边的距离</li>
<li><code>bottom</code> {number} 范围下边缘与屏幕上边的距离</li>
</ul>
<p>为当前选择器附加控件”bounds 需要包含 left, top, right, buttom 构成的范围”的条件。</p>
<p>这个条件用于限制控件的范围必须包含所给定的范围。例如给定一个点(500, 300), 寻找在这个点上的可点击控件的代码为:</p>
<pre><code>var w = boundsContains(500, 300, device.width  500, device.height  300).clickable().findOne();
w.click();
</code></pre>
<h2 id="查找控件不常用的条件"><a href="#查找控件不常用的条件" class="headerlink" title="查找控件不常用的条件"></a>查找控件不常用的条件</h2><h3 id="绘制顺序"><a href="#绘制顺序" class="headerlink" title="绘制顺序"></a>绘制顺序</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectordrawingorderorder">UiSelector.drawingOrder(order)</a></p>
<ul>
<li>order {number} 控件在父视图中的绘制顺序</li>
</ul>
<p>为当前选择器附加控件”drawingOrder 等于 order”的条件。</p>
<p>drawingOrder 为一个控件在父控件中的绘制顺序，通常可以用于区分同一层次的控件。</p>
<p>但该属性在 Android 7.0 以上才能使用。</p>
<h3 id="控件是否可点击"><a href="#控件是否可点击" class="headerlink" title="控件是否可点击"></a>控件是否可点击</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorclickablebtrue">UiSelector.clickable([b &#x3D; true])</a></p>
<ul>
<li><code>b</code> {Boolean} 表示控件是否可点击</li>
</ul>
<p>为当前选择器附加控件是否可点击的条件。但并非所有 clickable 为 false 的控件都真的不能点击，这取决于控件的实现。对于自定义控件(例如显示类名为 android.view.View 的控件)很多的 clickable 属性都为 false 都却能点击。</p>
<p>需要注意的是，可以省略参数<code>b</code>而表示选择那些可以点击的控件，例如<code>className(&quot;ImageView&quot;).clickable()</code>表示可以点击的图片控件的条件，<code>className(&quot;ImageView&quot;).clickable(false)</code>表示不可点击的图片控件的条件。</p>
<h3 id="控件是否可长按"><a href="#控件是否可长按" class="headerlink" title="控件是否可长按"></a>控件是否可长按</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorlongclickablebtrue">UiSelector.longClickable([b &#x3D; true])</a></p>
<ul>
<li><code>b</code> {Boolean} 表示控件是否可长按</li>
</ul>
<p>为当前选择器附加控件是否可长按的条件。</p>
<h3 id="控件是否可勾选"><a href="#控件是否可勾选" class="headerlink" title="控件是否可勾选"></a>控件是否可勾选</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorcheckablebtrue">UiSelector.checkable([b &#x3D; true])</a></p>
<ul>
<li><code>b</code> {Boolean} 表示控件是否可勾选</li>
</ul>
<p>为当前选择器附加控件是否可勾选的条件。勾选通常是对于勾选框而言的，例如图片多选时左上角通常有一个勾选框。</p>
<h3 id="控件是否被选"><a href="#控件是否被选" class="headerlink" title="控件是否被选"></a>控件是否被选</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorselectedbtrue">UiSelector.selected([b &#x3D; true])</a></p>
<ul>
<li><code>b</code> {Boolean} 表示控件是否被选</li>
</ul>
<p>为当前选择器附加控件是否已选中的条件。被选中指的是，例如 QQ 聊天界面点击下方的”表情按钮”时，会出现自己收藏的表情，这时”表情按钮”便处于选中状态，其 selected 属性为 true。</p>
<h3 id="控件是否已启用"><a href="#控件是否已启用" class="headerlink" title="控件是否已启用"></a>控件是否已启用</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorenabledbtrue">UiSelector.enabled([b &#x3D; true])</a></p>
<ul>
<li><code>b</code> {Boolean} 表示控件是否已启用</li>
</ul>
<p>为当前选择器附加控件是否已启用的条件。大多数控件都是启用的状态(enabled 为 true)，处于“禁用”状态通常是灰色并且不可点击。</p>
<h3 id="控件是否可滑动"><a href="#控件是否可滑动" class="headerlink" title="控件是否可滑动"></a>控件是否可滑动</h3><blockquote>
<p>UiSelector.scrollable(<a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectorscrollableb-true">b &#x3D; true])</a></p>
</blockquote>
<ul>
<li><code>b</code> {Boolean} 表示控件是否可滑动</li>
</ul>
<p>为当前选择器附加控件是否可滑动的条件。滑动包括上下滑动和左右滑动。</p>
<p>可以用这个条件来寻找可滑动控件来滑动界面。例如滑动 Auto.js 的脚本列表的代码为:</p>
<pre><code>className(&quot;android.support.v7.widget.RecyclerView&quot;).scrollable().findOne().scrollForward();
//或者classNameEndsWith(&quot;RecyclerView&quot;).scrollable().findOne().scrollForward();
</code></pre>
<h3 id="控件是否可编辑"><a href="#控件是否可编辑" class="headerlink" title="控件是否可编辑"></a>控件是否可编辑</h3><blockquote>
<p>UiSelector.editable([b &#x3D; true])</p>
</blockquote>
<ul>
<li><code>b</code> {Boolean} 表示控件是否可编辑</li>
</ul>
<p>为当前选择器附加控件是否可编辑的条件。一般来说可编辑的控件为输入框(EditText)，但不是所有的输入框(EditText)都可编辑。</p>
<h3 id="文本或输入框控件是否是多行显示的"><a href="#文本或输入框控件是否是多行显示的" class="headerlink" title="文本或输入框控件是否是多行显示的"></a>文本或输入框控件是否是多行显示的</h3><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselectormultilinebtrue">UiSelector.multiLine([b &#x3D; true])</a></p>
<ul>
<li>b {Boolean} 表示文本或输入框控件是否是多行显示的</li>
</ul>
<p>为当前选择器附加控件是否文本或输入框控件是否是多行显示的条件。</p>
<hr>
<h1 id="控件查找的截止方式"><a href="#控件查找的截止方式" class="headerlink" title="控件查找的截止方式"></a>控件查找的截止方式</h1><h2 id="循环查找，直到出现满足条件的控件为止"><a href="#循环查找，直到出现满足条件的控件为止" class="headerlink" title="循环查找，直到出现满足条件的控件为止"></a>循环查找，直到出现满足条件的控件为止</h2><blockquote>
<p>UiSelector.findOne()</p>
</blockquote>
<ul>
<li>返回控件对象 UiObject</li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件。如果找不到控件，当屏幕内容发生变化时会重新寻找，直至找到。</p>
<p>需要注意的是，<strong>如果屏幕上一直没有出现所描述的控件，则该函数会阻塞</strong>，直至所描述的控件出现为止。因此此函数不会返回<code>null</code>。</p>
<p>如果想要只在屏幕上搜索一次而不是一直搜索，请使用<code>findOnce()</code>。</p>
<p>另外，如果屏幕上有多个满足条件的控件，<code>findOne()</code>采用深度优先搜索(DFS)，会返回该搜索算法找到的第一个控件。注意控件找到的顺序有时会起到作用。</p>
<h2 id="指定时间内，循环查找，直到出现满足条件的控件为止"><a href="#指定时间内，循环查找，直到出现满足条件的控件为止" class="headerlink" title="指定时间内，循环查找，直到出现满足条件的控件为止"></a>指定时间内，循环查找，直到出现满足条件的控件为止</h2><blockquote>
<p>UiSelector.findOne(timeout)</p>
</blockquote>
<ul>
<li><code>timeout</code> {number} 搜索的超时时间，单位毫秒</li>
<li>返回控件对象 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiobject">UiObject</a></li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到屏幕上出现满足条件的一个控件为止，并返回该控件；如果在 <code>timeout</code> 毫秒的时间内没有找到符合条件的控件，则终止搜索并返回<code>null</code>。</p>
<p>该函数类似于不加参数的<code>findOne()</code>，只不过加上了时间限制。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//启动Auto.js</span></span><br><span class="line"><span class="title function_">launchApp</span>(<span class="string">&quot;Autox.js v6&quot;</span>);</span><br><span class="line"><span class="comment">//在6秒内找出日志图标的控件</span></span><br><span class="line"><span class="keyword">var</span> w = <span class="title function_">desc</span>(<span class="string">&quot;日志&quot;</span>).<span class="title function_">findOne</span>(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//如果找到控件，弹出提示</span></span><br><span class="line"><span class="keyword">if</span>(w != <span class="literal">null</span>)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;找到日志图标&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//否则提示没有找到</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;没有找到日志图标&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="只查找一次，并返回是否找到"><a href="#只查找一次，并返回是否找到" class="headerlink" title="只查找一次，并返回是否找到"></a>只查找一次，并返回是否找到</h2><blockquote>
<p>UiSelector.findOnce()</p>
</blockquote>
<ul>
<li>返回控件对象 UiObject</li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，如果找到符合条件的控件则返回该控件；否则返回<code>null</code>。</p>
<h2 id="只查找一次，并返回是否找到及返回第i-1的控件"><a href="#只查找一次，并返回是否找到及返回第i-1的控件" class="headerlink" title="只查找一次，并返回是否找到及返回第i+1的控件"></a>只查找一次，并返回是否找到及返回第i+1的控件</h2><blockquote>
<p>UiSelector.findOnce( i )</p>
</blockquote>
<ul>
<li><code>i</code> {number} 索引</li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，并返回第 i + 1 个符合条件的控件；如果没有找到符合条件的控件，或者符合条件的控件个数 &lt; i, 则返回<code>null</code>。</p>
<p>注意这里的控件次序，是搜索算法深度优先搜索(DSF)决定的。</p>
<hr>
<h1 id="查找控件集合"><a href="#查找控件集合" class="headerlink" title="查找控件集合"></a>查找控件集合</h1><h2 id="查找一次，返回控件集合"><a href="#查找一次，返回控件集合" class="headerlink" title="查找一次，返回控件集合"></a>查找一次，返回控件集合</h2><blockquote>
<p>UiSelector.find()</p>
</blockquote>
<ul>
<li>返回控件集合 UiCollection</li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，找到所有满足条件的控件集合并返回。这个搜索只进行一次，并不保证一定会找到，因而会出现返回的控件集合为空的情况。</p>
<p>不同于<code>findOne()</code>或者<code>findOnce()</code>只找到一个控件并返回一个控件，<code>find()</code>函数会找出所有满足条件的控件并返回一个控件集合。之后可以对控件集合进行操作。</p>
<p>可以通过 <code>empty()</code>函数判断找到的是否为空。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="title function_">className</span>(<span class="string">&quot;AbsListView&quot;</span>).<span class="title function_">find</span>();</span><br><span class="line"><span class="keyword">if</span>(c.<span class="title function_">empty</span>())&#123;</span><br><span class="line">    <span class="title function_">toast</span>(<span class="string">&quot;没找到╭(╯^╰)╮&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">toast</span>(<span class="string">&quot;找到啦&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="一直查找，直到出现符合条件的控件集合"><a href="#一直查找，直到出现符合条件的控件集合" class="headerlink" title="一直查找，直到出现符合条件的控件集合"></a>一直查找，直到出现符合条件的控件集合</h2><blockquote>
<p>UiSelector.untilFind()</p>
</blockquote>
<ul>
<li>返回控件集合 UiCollection</li>
</ul>
<p>根据当前的选择器所确定的筛选条件，对屏幕上的控件进行搜索，直到找到至少一个满足条件的控件为止，并返回所有满足条件的控件集合。</p>
<p>该函数与<code>find()</code>函数的区别在于，该函数永远不会返回空集合；但是，如果屏幕上一直没有出现满足条件的控件，则该函数会保持阻塞。</p>
<hr>
<h2 id="判断控件是否存在"><a href="#判断控件是否存在" class="headerlink" title="判断控件是否存在"></a>判断控件是否存在</h2><blockquote>
<p>UiSelector.exists()</p>
</blockquote>
<ul>
<li>返回布尔值 {Boolean}</li>
</ul>
<p>判断屏幕上是否存在控件符合选择器所确定的条件。例如要判断某个文本出现就执行某个动作，可以用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="title function_">text</span>(<span class="string">&quot;某个文本&quot;</span>).<span class="title function_">exists</span>())&#123;</span><br><span class="line">    <span class="comment">//要支持的动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="一直等待屏幕上出现符合条件的控件"><a href="#一直等待屏幕上出现符合条件的控件" class="headerlink" title="一直等待屏幕上出现符合条件的控件"></a>一直等待屏幕上出现符合条件的控件</h2><blockquote>
<p>UiSelector.waitFor( )</p>
</blockquote>
<p>等待屏幕上出现符合条件的控件；在满足该条件的控件出现之前，该函数会一直保持阻塞。</p>
<p>例如要等待包含”哈哈哈”的文本控件出现的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">textContains</span>(<span class="string">&quot;哈哈哈&quot;</span>).<span class="title function_">waitFor</span>();</span><br></pre></td></tr></table></figure>





<hr>
<h2 id="自定义控件的过滤条件"><a href="#自定义控件的过滤条件" class="headerlink" title="自定义控件的过滤条件"></a>自定义控件的过滤条件</h2><blockquote>
<p>UiSelector.filter( f )</p>
</blockquote>
<ul>
<li><code>f</code> {Function} 过滤函数，参数为 UiObject，返回值为 boolean</li>
</ul>
<p>为当前选择器附加自定义的过滤条件。</p>
<p>例如，要找出屏幕上所有文本长度为 10 的文本控件的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> uc = <span class="title function_">className</span>(<span class="string">&quot;TextView&quot;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">w</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> w.<span class="title function_">text</span>().<span class="property">length</span> == <span class="number">10</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<hr>
<h1 id="操作控件"><a href="#操作控件" class="headerlink" title="操作控件"></a>操作控件</h1><blockquote>
<p>控件 UiObject</p>
</blockquote>
<p>UiObject 表示一个控件，可以通过这个对象获取到控件的属性，也可以对控件进行点击、长按等操作。</p>
<p>获取一个 UiObject 通常通过选择器的<code>findOne()</code>, <code>findOnce()</code>等函数，也可以通过 <code>UiCollection</code> 来获取，或者通过<code>UiObject.child()</code>, <code>UiObject.parent()</code>等函数来获取一个控件的子控件或父控件。</p>
<h2 id="点击控件"><a href="#点击控件" class="headerlink" title="点击控件"></a>点击控件</h2><blockquote>
<p>UiObject.click( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>点击该控件，并返回是否点击成功。</p>
<p>如果该函数返回 <code>false</code>，可能是该控件不可点击(<code>clickable</code> 为 <code>false</code> )，当前界面无法响应该点击等。</p>
<h2 id="长按控件"><a href="#长按控件" class="headerlink" title="长按控件"></a>长按控件</h2><blockquote>
<p>UiObject.longClick( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>长按该控件，并返回是否点击成功。</p>
<p>如果该函数返回 false，可能是该控件不可点击(longClickable 为 false)，当前界面无法响应该点击等。</p>
<h2 id="控件矩形"><a href="#控件矩形" class="headerlink" title="控件矩形"></a>控件矩形</h2><blockquote>
<p>Rect</p>
</blockquote>
<p><code>UiObject.bounds()</code>, <code>UiObject.boundsInParent()</code>返回的对象。表示一个长方形(范围)。</p>
<blockquote>
<p>Rect.left</p>
</blockquote>
<ul>
<li>{number}</li>
</ul>
<p>长方形左边界的 x 坐标、</p>
<blockquote>
<p>Rect.right</p>
</blockquote>
<ul>
<li>{number}</li>
</ul>
<p>长方形右边界的 x 坐标、</p>
<blockquote>
<p>Rect.top</p>
</blockquote>
<ul>
<li>{number}</li>
</ul>
<p>长方形上边界的 y 坐标、</p>
<blockquote>
<p>Rect.bottom</p>
</blockquote>
<ul>
<li>{number}</li>
</ul>
<p>长方形下边界的 y 坐标、</p>
<blockquote>
<p>Rect.centerX()</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>长方形中点 x 坐标。</p>
<blockquote>
<p>Rect.centerY()</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>长方形中点 y 坐标。</p>
<blockquote>
<p>Rect.width()</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>长方形宽度。通常可以作为控件宽度。</p>
<blockquote>
<p>Rect.height()</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>长方形高度。通常可以作为控件高度。</p>
<blockquote>
<p>Rect.contains( r )</p>
</blockquote>
<ul>
<li><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=rect">Rect</a></li>
</ul>
<p>返回是否包含另一个长方形 r。包含指的是，长方形 r 在该长方形的里面(包含边界重叠的情况)。</p>
<blockquote>
<p>Rect.intersect( r )</p>
</blockquote>
<ul>
<li>Rect</li>
</ul>
<p>返回是否和另一个长方形相交。</p>
<h2 id="设置输入框控件的文本内容"><a href="#设置输入框控件的文本内容" class="headerlink" title="设置输入框控件的文本内容"></a>设置输入框控件的文本内容</h2><blockquote>
<p>UiObject.setText( text )</p>
</blockquote>
<ul>
<li><code>text</code> {string} 文本</li>
<li>返回 {Boolean}</li>
</ul>
<p>设置输入框控件的文本内容，并返回是否设置成功。</p>
<p>该函数只对可编辑的输入框 (<code>editable</code> 为 <code>true</code> ) 有效。</p>
<h2 id="对输入框文本的选中内容进行复制"><a href="#对输入框文本的选中内容进行复制" class="headerlink" title="对输入框文本的选中内容进行复制"></a>对输入框文本的选中内容进行复制</h2><blockquote>
<p>UiObject.copy( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对输入框文本的选中内容进行复制，并返回是否操作成功。</p>
<p>该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过<code>setSelection()</code>函数来设置输入框选中的内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> et = <span class="title function_">className</span>(<span class="string">&quot;EditText&quot;</span>).<span class="title function_">findOne</span>();</span><br><span class="line"><span class="comment">//选中前两个字</span></span><br><span class="line">et.<span class="title function_">setSelection</span>(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//对选中内容进行复制</span></span><br><span class="line"><span class="keyword">if</span>(et.<span class="title function_">copy</span>())&#123;</span><br><span class="line">    <span class="title function_">toast</span>(<span class="string">&quot;复制成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_">toast</span>(<span class="string">&quot;复制失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="对输入框文本的选中内容进行剪切"><a href="#对输入框文本的选中内容进行剪切" class="headerlink" title="对输入框文本的选中内容进行剪切"></a>对输入框文本的选中内容进行剪切</h2><blockquote>
<p>UiObject.cut( )</p>
</blockquote>
<p>对输入框文本的选中内容进行剪切，并返回是否操作成功。</p>
<p>该函数只能用于输入框控件，并且当前输入框控件有选中的文本。可以通过<code>setSelection()</code>函数来设置输入框选中的内容。</p>
<h2 id="对输入框控件进行粘贴操作"><a href="#对输入框控件进行粘贴操作" class="headerlink" title="对输入框控件进行粘贴操作"></a>对输入框控件进行粘贴操作</h2><blockquote>
<p>UiObject.paste( ) </p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对输入框控件进行粘贴操作，把剪贴板内容粘贴到输入框中，并返回是否操作成功。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置剪贴板内容为“你好”</span></span><br><span class="line"><span class="title function_">setClip</span>(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> et = <span class="title function_">className</span>(<span class="string">&quot;EditText&quot;</span>).<span class="title function_">findOne</span>();</span><br><span class="line">et.<span class="title function_">paste</span>();</span><br></pre></td></tr></table></figure>





<h2 id="对输入框控件设置选中的文字内容"><a href="#对输入框控件设置选中的文字内容" class="headerlink" title="对输入框控件设置选中的文字内容"></a>对输入框控件设置选中的文字内容</h2><blockquote>
<p>UiObject.setSelection( start, end )</p>
</blockquote>
<ul>
<li><code>start</code> {number} 选中内容起始位置</li>
<li><code>end</code> {number} 选中内容结束位置( 不包括 )</li>
<li>返回 {Boolean}</li>
</ul>
<p>对输入框控件设置选中的文字内容，并返回是否操作成功。</p>
<p>索引是从 0 开始计算的；并且，选中内容不包含 end 位置的字符。例如，如果一个输入框内容为”123456789”，要选中”4567”的文字的代码为<code>et.setSelection(3, 7)</code>。</p>
<p>该函数也可以用来设置光标位置，只要参数的 end 等于 start，即可把输入框光标设置在 start 的位置。例如<code>et.setSelection(1, 1)</code>会把光标设置在第一个字符的后面。</p>
<h2 id="对控件执行向前滑动"><a href="#对控件执行向前滑动" class="headerlink" title="对控件执行向前滑动"></a>对控件执行向前滑动</h2><blockquote>
<p>UiObject.scrollForward( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对控件执行向前滑动的操作，并返回是否操作成功。</p>
<p>向前滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行<code>scrollForward()</code>的行为是未知的.</p>
<p>(这是因为 Android 文档没有指出这一点，同时也没有充分的测试可供参考)。</p>
<h2 id="对控件执行向后滑动"><a href="#对控件执行向后滑动" class="headerlink" title="对控件执行向后滑动"></a>对控件执行向后滑动</h2><blockquote>
<p>UiObject.scrollBackward( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对控件执行向后滑动的操作，并返回是否操作成功。</p>
<p>向后滑动包括了向右和向下滑动。如果一个控件既可以向右滑动和向下滑动，那么执行<code>scrollForward()</code>的行为是未知的(这是因为 Android 文档没有指出这一点，同时也没有充分的测试可供参考)。</p>
<h2 id="对控件执行”选中”操作"><a href="#对控件执行”选中”操作" class="headerlink" title="对控件执行”选中”操作"></a>对控件执行”选中”操作</h2><blockquote>
<p>UiObject.select( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对控件执行”选中”操作，并返回是否操作成功。”选中”和<code>isSelected()</code>的属性相关，但该操作十分少用。</p>
<h2 id="对控件执行折叠操作"><a href="#对控件执行折叠操作" class="headerlink" title="对控件执行折叠操作"></a>对控件执行折叠操作</h2><blockquote>
<p>UiObject.collapse( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对控件执行折叠操作，并返回是否操作成功。</p>
<h2 id="对控件执行展开操作"><a href="#对控件执行展开操作" class="headerlink" title="对控件执行展开操作"></a>对控件执行展开操作</h2><blockquote>
<p>UiObject.expand( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>对控件执行展开操作，并返回是否操作成功。</p>
<hr>
<h1 id="对控件集合的操作"><a href="#对控件集合的操作" class="headerlink" title="对控件集合的操作"></a>对控件集合的操作</h1><h2 id="对集合中所有控件执行显示操作"><a href="#对集合中所有控件执行显示操作" class="headerlink" title="对集合中所有控件执行显示操作"></a>对集合中所有控件执行显示操作</h2><blockquote>
<p>UiObject.show( )</p>
</blockquote>
<p>对集合中所有控件执行显示操作，并返回是否全部操作成功。</p>
<h2 id="集合中所有控件执行向上滑"><a href="#集合中所有控件执行向上滑" class="headerlink" title="集合中所有控件执行向上滑"></a>集合中所有控件执行向上滑</h2><blockquote>
<p>UiObject.scrollUp()</p>
</blockquote>
<p>对集合中所有控件执行向上滑的操作，并返回是否全部操作成功。</p>
<h2 id="集合中所有控件执行向下滑"><a href="#集合中所有控件执行向下滑" class="headerlink" title="集合中所有控件执行向下滑"></a>集合中所有控件执行向下滑</h2><blockquote>
<p>UiObject.scrollDown()</p>
</blockquote>
<p>对集合中所有控件执行向下滑的操作，并返回是否全部操作成功。</p>
<h2 id="集合中所有控件执行向左滑"><a href="#集合中所有控件执行向左滑" class="headerlink" title="集合中所有控件执行向左滑"></a>集合中所有控件执行向左滑</h2><blockquote>
<p>UiObject.scrollLeft()</p>
</blockquote>
<p>对集合中所有控件执行向左滑的操作，并返回是否全部操作成功。</p>
<h2 id="集合中所有控件执行向右滑"><a href="#集合中所有控件执行向右滑" class="headerlink" title="集合中所有控件执行向右滑"></a>集合中所有控件执行向右滑</h2><blockquote>
<p>UiObject.scrollRight()</p>
</blockquote>
<p>对集合中所有控件执行向右滑的操作，并返回是否全部操作成功。</p>
<h2 id="返回该控件的所有子控件组成的控件集合"><a href="#返回该控件的所有子控件组成的控件集合" class="headerlink" title="返回该控件的所有子控件组成的控件集合"></a>返回该控件的所有子控件组成的控件集合</h2><blockquote>
<p>children( )</p>
</blockquote>
<ul>
<li>返回 UiCollection</li>
</ul>
<p>返回该控件的所有子控件组成的控件集合。可以用于遍历一个控件的子控件，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">className</span>(<span class="string">&quot;AbsListView&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">children</span>()</span><br><span class="line">    .<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">child</span>)&#123;</span><br><span class="line">        <span class="title function_">log</span>(child.<span class="title function_">className</span>());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>




<h2 id="返回子控件数目。"><a href="#返回子控件数目。" class="headerlink" title="返回子控件数目。"></a>返回子控件数目。</h2><blockquote>
<p>childCount( )</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<h2 id="返回第-i-1-个子控件"><a href="#返回第-i-1-个子控件" class="headerlink" title="返回第 i+1 个子控件"></a>返回第 i+1 个子控件</h2><blockquote>
<p>child( i )</p>
</blockquote>
<ul>
<li>i {number} 子控件索引</li>
<li>返回 {UiObject}</li>
</ul>
<p>返回第 i+1 个子控件。如果 i&gt;&#x3D;控件数目或者小于 0，则抛出异常。</p>
<p>需要注意的是，由于布局捕捉的问题，该函数可能返回<code>null</code>，也就是可能获取不到某个子控件。</p>
<p>遍历子控件的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="title function_">className</span>(<span class="string">&quot;AbsListView&quot;</span>).<span class="title function_">findOne</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.<span class="title function_">childCount</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> child = list.<span class="title function_">child</span>(i);</span><br><span class="line">    <span class="title function_">log</span>(child.<span class="title function_">className</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="返回该控件的父控件"><a href="#返回该控件的父控件" class="headerlink" title="返回该控件的父控件"></a>返回该控件的父控件</h2><blockquote>
<p>parent( )</p>
</blockquote>
<ul>
<li>返回 {UiObject}</li>
</ul>
<p>返回该控件的父控件。如果该控件没有父控件，返回<code>null</code>。</p>
<h2 id="返回控件在屏幕上的范围"><a href="#返回控件在屏幕上的范围" class="headerlink" title="返回控件在屏幕上的范围"></a>返回控件在屏幕上的范围</h2><blockquote>
<p>bounds( )</p>
</blockquote>
<ul>
<li>返回 <a href="https://hyb1996.github.io/AutoJsDocs/widgetsbasedautomation.html#rect">Rect</a></li>
</ul>
<p>返回控件在屏幕上的范围，其值是一个<a href="https://hyb1996.github.io/AutoJsDocs/widgetsbasedautomation.html#rect">Rect</a>对象。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title function_">text</span>(<span class="string">&quot;Auto.js&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">bounds</span>();</span><br><span class="line"><span class="title function_">toast</span>(<span class="string">&quot;控件在屏幕上的范围为&quot;</span> + b);</span><br></pre></td></tr></table></figure>
<p>如果一个控件本身无法通过<code>click()</code>点击，那么我们可以利用<code>bounds()</code>函数获取其坐标，再利用坐标点击。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="title function_">desc</span>(<span class="string">&quot;打开侧拉菜单&quot;</span>).<span class="title function_">findOne</span>().<span class="title function_">bounds</span>();</span><br><span class="line"><span class="title function_">click</span>(b.<span class="title function_">centerX</span>(), b.<span class="title function_">centerY</span>());</span><br><span class="line"><span class="comment">//如果使用root权限，则用 Tap(b.centerX(), b.centerY());</span></span><br></pre></td></tr></table></figure>





<h2 id="返回控件在父控件中的范围"><a href="#返回控件在父控件中的范围" class="headerlink" title="返回控件在父控件中的范围"></a>返回控件在父控件中的范围</h2><blockquote>
<p>boundsInParent( )</p>
</blockquote>
<ul>
<li>返回 <a href="https://hyb1996.github.io/AutoJsDocs/widgetsbasedautomation.html#rect">Rect</a></li>
</ul>
<p>返回控件在父控件中的范围，其值是一个<a href="https://hyb1996.github.io/AutoJsDocs/widgetsbasedautomation.html#rect">Rect</a>对象。</p>
<h2 id="返回控件在父控件中的绘制次序"><a href="#返回控件在父控件中的绘制次序" class="headerlink" title="返回控件在父控件中的绘制次序"></a>返回控件在父控件中的绘制次序</h2><blockquote>
<p>drawingOrder( )</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>返回控件在父控件中的绘制次序。该函数在安卓 7.0 及以上才有效，7.0 以下版本调用会返回 0。</p>
<h2 id="获取控件的-id"><a href="#获取控件的-id" class="headerlink" title="获取控件的 id"></a>获取控件的 id</h2><blockquote>
<p>id( )</p>
</blockquote>
<ul>
<li>返回 {string}</li>
</ul>
<p>获取控件的 id，如果一个控件没有 id，则返回<code>null</code>。</p>
<h2 id="获取控件的文本"><a href="#获取控件的文本" class="headerlink" title="获取控件的文本"></a>获取控件的文本</h2><blockquote>
<p>text( )</p>
</blockquote>
<ul>
<li>返回 {string}</li>
</ul>
<p>获取控件的文本，如果控件没有文本，返回<code>&quot;&quot;</code>。</p>
<h2 id="在该控件的子控件中查找包含指定文本的控件"><a href="#在该控件的子控件中查找包含指定文本的控件" class="headerlink" title="在该控件的子控件中查找包含指定文本的控件"></a>在该控件的子控件中查找包含指定文本的控件</h2><blockquote>
<p>findByText(str)</p>
</blockquote>
<ul>
<li><code>str</code> {string} 文本</li>
<li>返回 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uicollection">UiCollection</a></li>
</ul>
<p>根据文本 text 在子控件中递归地寻找并返回 “文本( text )或描述( desc )” <strong>包含</strong>这段文本 str 的控件，返回它们组成的集合。</p>
<p>该函数会在当前控件的子控件，孙控件，曾孙控件…中搜索 text 或 desc 包含 str 的控件，并返回它们组合的集合。</p>
<h2 id="找到符合要求的子控件中的第一个控件"><a href="#找到符合要求的子控件中的第一个控件" class="headerlink" title="找到符合要求的子控件中的第一个控件"></a>找到符合要求的子控件中的第一个控件</h2><p><a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=findoneselector">findOne(selector)</a></p>
<ul>
<li><code>selector</code> <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselector">UiSelector</a></li>
<li>返回 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiobject">UiOobject</a></li>
</ul>
<p>根据选择器 selector 在该控件的子控件、孙控件…中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回<code>null</code>。</p>
<p>例如，对于酷安动态列表，我们可以遍历他的子控件(每个动态列表项)，并在每个子控件中依次寻找点赞数量和图标，对于点赞数量小于 10 的点赞：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//找出动态列表</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="title function_">id</span>(<span class="string">&quot;recycler_view&quot;</span>).<span class="title function_">findOne</span>();</span><br><span class="line"><span class="comment">//遍历动态</span></span><br><span class="line">list.<span class="title function_">children</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">child</span>)&#123;</span><br><span class="line">    <span class="comment">//找出点赞图标</span></span><br><span class="line">    <span class="keyword">var</span> like = child.<span class="title function_">findOne</span>(<span class="title function_">id</span>(<span class="string">&quot;feed_action_view_like&quot;</span>));</span><br><span class="line">    <span class="comment">//找出点赞数量</span></span><br><span class="line">    <span class="keyword">var</span> likeCount = child.<span class="title function_">findOne</span>(<span class="title function_">id</span>(<span class="string">&quot;text_view&quot;</span>));</span><br><span class="line">    <span class="comment">//如果这两个控件没有找到就不继续了</span></span><br><span class="line">    <span class="keyword">if</span>(like == <span class="literal">null</span> || likeCount == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断点赞数量是否小于10</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">parseInt</span>(likeCount.<span class="title function_">text</span>()) &lt; <span class="number">10</span>)&#123;</span><br><span class="line">        <span class="comment">//点赞</span></span><br><span class="line">        like.<span class="title function_">click</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>







<h2 id="找到符合要求的所有子控件集合"><a href="#找到符合要求的所有子控件集合" class="headerlink" title="找到符合要求的所有子控件集合"></a>找到符合要求的所有子控件集合</h2><blockquote>
<p>find(selector)</p>
</blockquote>
<ul>
<li><code>selector</code> UiSelector</li>
<li>返回 UiCollection</li>
</ul>
<p>根据选择器 selector 在该控件的子控件、孙控件…中搜索符合该选择器条件的控件，并返回它们组合的集合。</p>
<p>UiCollection</p>
<p>UiCollection, 控件集合, 通过选择器的<code>find()</code>, <code>untilFind()</code>方法返回的对象。</p>
<p>UiCollection”继承”于数组，实际上是一个 UiObject 的数组，因此可以使用数组的函数和属性，例如使用 length 属性获取 UiCollection 的大小，使用 forEach 函数来遍历 UiCollection。</p>
<p>例如，采用 forEach 遍历屏幕上所有的文本控件并打印出文本内容的代码为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">show</span>();</span><br><span class="line"><span class="title function_">className</span>(<span class="string">&quot;TextView&quot;</span>).<span class="title function_">find</span>().<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">tv</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tv.<span class="title function_">text</span>() != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="title function_">log</span>(tv.<span class="title function_">text</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>也可以使用传统的数组遍历方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">show</span>();</span><br><span class="line"><span class="keyword">var</span> uc = <span class="title function_">className</span>(<span class="string">&quot;TextView&quot;</span>).<span class="title function_">find</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; uc.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> tv = uc[i];</span><br><span class="line">    <span class="keyword">if</span>(tv.<span class="title function_">text</span>() != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">        <span class="title function_">log</span>(tv.<span class="title function_">text</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UiCollection 的每一个元素都是 UiObject，我们可以取出他的元素进行操作，例如取出第一个 UiObject 并点击的代码为<code>ui[0].click()</code>。如果想要对该集合的所有元素进行操作，可以直接在集合上调用相应的函数，例如<code>uc.click()</code>，该代码会对集合上所有 UiObject 执行点击操作并返回是否全部点击成功。</p>
<p>因此，UiCollection 具有所有 UiObject 对控件操作的函数，包括<code>click()</code>, <code>longClick()</code>, <code>scrollForward()</code>等等，不再赘述。</p>
<h2 id="返回集合中的控件数"><a href="#返回集合中的控件数" class="headerlink" title="返回集合中的控件数"></a>返回集合中的控件数</h2><blockquote>
<p>UiCollection.size( )</p>
</blockquote>
<ul>
<li>返回 {number}</li>
</ul>
<p>返回集合中的控件数。</p>
<p>历史遗留函数，相当于属性 length。</p>
<h2 id="返回集合中第-i-1-个控件"><a href="#返回集合中第-i-1-个控件" class="headerlink" title="返回集合中第 i+1 个控件"></a>返回集合中第 i+1 个控件</h2><blockquote>
<p>UiCollection.get( i )</p>
</blockquote>
<ul>
<li><code>i</code> {number} 索引</li>
<li>返回 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiobject">UiObject</a></li>
</ul>
<p>返回集合中第 i+1 个控件(UiObject)。</p>
<p>历史遗留函数，建议直接使用数组下标的方式访问元素。</p>
<h2 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h2><blockquote>
<p>UiCollection.each( func )</p>
</blockquote>
<ul>
<li><code>func</code> {Function} 遍历函数，参数为 UiObject。</li>
</ul>
<p>遍历集合。</p>
<p>历史遗留函数，相当于<code>forEach</code>。参考<a href="https://developer.mozilla.org/zhCN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach">forEach</a>。</p>
<h2 id="判断返回控件集合是否为空"><a href="#判断返回控件集合是否为空" class="headerlink" title="判断返回控件集合是否为空"></a>判断返回控件集合是否为空</h2><blockquote>
<p>empty( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>返回控件集合是否为空。</p>
<h2 id="返回控件集合是否非空"><a href="#返回控件集合是否非空" class="headerlink" title="返回控件集合是否非空"></a>返回控件集合是否非空</h2><blockquote>
<p>nonEmpty( )</p>
</blockquote>
<ul>
<li>返回 {Boolean}</li>
</ul>
<p>返回控件集合是否非空。</p>
<h2 id="找到所有符合条件的子控件并返回控件集合"><a href="#找到所有符合条件的子控件并返回控件集合" class="headerlink" title="找到所有符合条件的子控件并返回控件集合"></a>找到所有符合条件的子控件并返回控件集合</h2><blockquote>
<p>UiCollection.find( selector )</p>
</blockquote>
<ul>
<li><code>selector</code> <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselector">UiSelector</a></li>
<li>返回 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uicollection">UiCollection</a></li>
</ul>
<p>根据 selector 所确定的条件在该控件集合的控件、子控件、孙控件…中找到所有符合条件的控件并返回找到的控件集合。</p>
<p>注意这会递归地遍历控件集合里所有的控件以及他们的子控件。和数组的<code>filter</code>函数不同。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = <span class="title function_">id</span>(<span class="string">&quot;name&quot;</span>).<span class="title function_">find</span>();</span><br><span class="line"><span class="comment">//在集合</span></span><br><span class="line"><span class="keyword">var</span> clickableNames = names.<span class="title function_">find</span>(<span class="title function_">clickable</span>());</span><br></pre></td></tr></table></figure>





<h2 id="在控件集合中返回找到符合要求的第一个控件"><a href="#在控件集合中返回找到符合要求的第一个控件" class="headerlink" title="在控件集合中返回找到符合要求的第一个控件"></a>在控件集合中返回找到符合要求的第一个控件</h2><blockquote>
<p>UiCollection.findOne( selector )</p>
</blockquote>
<ul>
<li><code>selector</code> <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiselector">UiSelector</a></li>
<li>返回 <a href="http://doc.autoxjs.com/#/widgetsBasedAutomation?id=uiobject">UiOobject</a></li>
</ul>
<p>根据选择器 selector 在该控件集合的控件的子控件、孙控件…中搜索符合该选择器条件的控件，并返回找到的第一个控件；如果没有找到符合条件的控件则返回<code>null</code>。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器 Timers</title>
    <url>//blog/note/code/AutoXjs/timers.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a><a href="http://doc.autoxjs.com/#/timers?id=timers">Timers</a></h1><h2 id="Timers-1"><a href="#Timers-1" class="headerlink" title="Timers"></a><a href="http://doc.autoxjs.com/#/timers?id=timers">Timers</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>timers 模块暴露了一个全局的 API，用于在某个未来时间段调用调度函数。</p>
<p>因为定时器函数是全局的，所以使用该 API 无需调用 timers.XXXXX</p>
<p>Auto.js 中的计时器函数实现了与 Web 浏览器提供的定时器类似的 API，除了它使用了一个不同的内部实现，它是基于 <code>Android Looper-Handler</code> 消息循环机制构建的。其实现机制与 Node.js 比较相似。</p>
<p>例如，要在5秒后发出消息”hello”:</p>
<pre><code>setTimeout(function()&#123;
    toast(&quot;hello&quot;)
&#125;, 5000);
</code></pre>
<p>需要注意的是，这些定时器仍然是单线程的。如果脚本主体有耗时操作或死循环，则设定的定时器不能被及时执行，例如：</p>
<pre><code>setTimeout(function()&#123;
    //这里的语句会在15秒后执行而不是5秒后
    toast(&quot;hello&quot;)
&#125;, 5000);
//暂停10秒
sleep(10000);
</code></pre>
<p>再如：</p>
<pre><code>setTimeout(function()&#123;
    //这里的语句永远不会被执行
    toast(&quot;hello&quot;)
&#125;, 5000);
//死循环
while(true);
</code></pre>
<h2 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a><a href="http://doc.autoxjs.com/#/timers?id=setintervalcallback-delay-args">setInterval(callback, delay[, …args])</a></h2><ul>
<li><code>callback</code> {Function} 当定时器到点时要调用的函数。</li>
<li><code>delay</code> {number} 调用 callback 之前要等待的毫秒数。</li>
<li><code>...args</code> {any} 当调用 callback 时要传入的可选参数。</li>
</ul>
<p>预定每隔 delay 毫秒重复执行的 callback。 返回一个用于 clearInterval() 的 id。</p>
<p>当 delay 小于 0 时，delay 会被设为 0。</p>
<h2 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a><a href="http://doc.autoxjs.com/#/timers?id=settimeoutcallback-delay-args">setTimeout(callback, delay[, …args])</a></h2><ul>
<li><code>callback</code> {Function} 当定时器到点时要调用的函数。</li>
<li><code>delay</code> {number} 调用 callback 之前要等待的毫秒数。</li>
<li><code>...args</code> {any} 当调用 callback 时要传入的可选参数。</li>
</ul>
<p>预定在 delay 毫秒之后执行的单次 callback。 返回一个用于 clearTimeout() 的 id。</p>
<p>callback 可能不会精确地在 delay 毫秒被调用。 Auto.js 不能保证回调被触发的确切时间，也不能保证它们的顺序。 回调会在尽可能接近所指定的时间上调用。</p>
<p>当 delay 小于 0 时，delay 会被设为 0。</p>
<ul>
<li><code>callback</code> {Function} 在Looper循环的当前回合结束时要调用的函数。</li>
<li><code>...args</code> {any} 当调用 callback 时要传入的可选参数。</li>
</ul>
<p>预定立即执行的 callback，它是在 I&#x2F;O 事件的回调之后被触发。 返回一个用于 clearImmediate() 的 id。</p>
<p>当多次调用 setImmediate() 时，callback 函数会按照它们被创建的顺序依次执行。 每次事件循环迭代都会处理整个回调队列。 如果一个立即定时器是被一个正在执行的回调排入队列的，则该定时器直到下一次事件循环迭代才会被触发。</p>
<p>setImmediate()、setInterval() 和 setTimeout() 方法每次都会返回表示预定的计时器的id。 它们可用于取消定时器并防止触发。</p>
<h2 id="clearInterval-id"><a href="#clearInterval-id" class="headerlink" title="clearInterval(id)"></a><a href="http://doc.autoxjs.com/#/timers?id=clearintervalid">clearInterval(id)</a></h2><ul>
<li><code>id</code> {number} 一个 setInterval() 返回的 id。</li>
</ul>
<p>取消一个由 setInterval() 创建的循环定时任务。</p>
<p>例如：</p>
<pre><code>//每5秒就发出一次hello
var id = setInterval(function()&#123;
    toast(&quot;hello&quot;);
&#125;, 5000);
//1分钟后取消循环
setTimeout(function()&#123;
    clearInterval(id);
&#125;, 60 * 1000);
</code></pre>
<h2 id="clearTimeout-id"><a href="#clearTimeout-id" class="headerlink" title="clearTimeout(id)"></a><a href="http://doc.autoxjs.com/#/timers?id=cleartimeoutid">clearTimeout(id)</a></h2><ul>
<li><code>id</code> {number} 一个 setTimeout() 返回的 id。</li>
</ul>
<p>取消一个由 setTimeout() 创建的定时任务。</p>
<ul>
<li><code>id</code> {number} 一个 setImmediate() 返回的 id。</li>
</ul>
<p>取消一个由 setImmediate() 创建的 Immediate 对象。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>按键模拟</title>
    <url>//blog/note/code/AutoXjs/keys.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a><a href="http://doc.autoxjs.com/#/keys?id=keys">Keys</a></h2><p>按键模拟部分提供了一些模拟物理按键的全局函数，包括Home、音量键、照相键等，有的函数依赖于无障碍服务，有的函数依赖于root权限。</p>
<p>一般来说，以大写字母开头的函数都依赖于root权限。执行此类函数时，如果没有root权限，则函数执行后没有效果，并会在控制台输出一个警告。</p>
<h2 id="back"><a href="#back" class="headerlink" title="back()"></a><a href="http://doc.autoxjs.com/#/keys?id=back">back()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>模拟按下返回键。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="home"><a href="#home" class="headerlink" title="home()"></a><a href="http://doc.autoxjs.com/#/keys?id=home">home()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>模拟按下Home键。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="powerDialog"><a href="#powerDialog" class="headerlink" title="powerDialog()"></a><a href="http://doc.autoxjs.com/#/keys?id=powerdialog">powerDialog()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>弹出电源键菜单。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="notifications"><a href="#notifications" class="headerlink" title="notifications()"></a><a href="http://doc.autoxjs.com/#/keys?id=notifications">notifications()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>拉出通知栏。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="quickSettings"><a href="#quickSettings" class="headerlink" title="quickSettings()"></a><a href="http://doc.autoxjs.com/#/keys?id=quicksettings">quickSettings()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>显示快速设置(下拉通知栏到底)。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="recents"><a href="#recents" class="headerlink" title="recents()"></a><a href="http://doc.autoxjs.com/#/keys?id=recents">recents()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>显示最近任务。返回是否执行成功。 此函数依赖于无障碍服务。</p>
<h2 id="splitScreen"><a href="#splitScreen" class="headerlink" title="splitScreen()"></a><a href="http://doc.autoxjs.com/#/keys?id=splitscreen">splitScreen()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>分屏。返回是否执行成功。 此函数依赖于无障碍服务, 并且需要系统自身功能的支持。</p>
<h2 id="takeScreenshot"><a href="#takeScreenshot" class="headerlink" title="takeScreenshot()"></a><a href="http://doc.autoxjs.com/#/keys?id=takescreenshot">takeScreenshot()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 9以上</li>
</ul>
<p>模拟按键 <strong>电源键+音量下键</strong> 截屏 不返回截屏得到的图片对象，只返回是否截图成功，图片保存到系统相册</p>
<h2 id="lockScreen"><a href="#lockScreen" class="headerlink" title="lockScreen()"></a><a href="http://doc.autoxjs.com/#/keys?id=lockscreen">lockScreen()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 9以上</li>
</ul>
<p>模拟按键 <strong>电源键</strong> 锁屏</p>
<h2 id="dismissNotificationShade"><a href="#dismissNotificationShade" class="headerlink" title="dismissNotificationShade()"></a><a href="http://doc.autoxjs.com/#/keys?id=dismissnotificationshade">dismissNotificationShade()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>关闭通知栏的操作</p>
<h2 id="keyCodeHeadsetHook"><a href="#keyCodeHeadsetHook" class="headerlink" title="keyCodeHeadsetHook()"></a><a href="http://doc.autoxjs.com/#/keys?id=keycodeheadsethook">keyCodeHeadsetHook()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>发送KEYCODE_HEADSETHOOK KeyEvent的动作，用于接听&#x2F;挂断通话和播放&#x2F;停止媒体</p>
<h2 id="accessibilityShortcut"><a href="#accessibilityShortcut" class="headerlink" title="accessibilityShortcut()"></a><a href="http://doc.autoxjs.com/#/keys?id=accessibilityshortcut">accessibilityShortcut()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>触发辅助功能快捷方式的操作。此快捷方式有一个硬件触发器并且可以通过按住两个音量键来激活。</p>
<h2 id="accessibilityButtonChooser"><a href="#accessibilityButtonChooser" class="headerlink" title="accessibilityButtonChooser()"></a><a href="http://doc.autoxjs.com/#/keys?id=accessibilitybuttonchooser">accessibilityButtonChooser()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>调出辅助功能按钮的选择器菜单的操作</p>
<h2 id="accessibilityButton"><a href="#accessibilityButton" class="headerlink" title="accessibilityButton()"></a><a href="http://doc.autoxjs.com/#/keys?id=accessibilitybutton">accessibilityButton()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>触发辅助功能按钮的操作</p>
<h2 id="accessibilityAllApps"><a href="#accessibilityAllApps" class="headerlink" title="accessibilityAllApps()"></a><a href="http://doc.autoxjs.com/#/keys?id=accessibilityallapps">accessibilityAllApps()</a></h2><ul>
<li>返回 {boolean}</li>
<li>需要Android 12以上</li>
</ul>
<p>显示 Launcher（启动器） 的所有应用的操作。</p>
<h2 id="Home"><a href="#Home" class="headerlink" title="Home()"></a><a href="http://doc.autoxjs.com/#/keys?id=home-1">Home()</a></h2><p>模拟按下Home键。 此函数依赖于root权限。</p>
<h2 id="Back"><a href="#Back" class="headerlink" title="Back()"></a><a href="http://doc.autoxjs.com/#/keys?id=back-1">Back()</a></h2><p>模拟按下返回键。 此函数依赖于root权限。</p>
<h2 id="Power"><a href="#Power" class="headerlink" title="Power()"></a><a href="http://doc.autoxjs.com/#/keys?id=power">Power()</a></h2><p>模拟按下电源键。 此函数依赖于root权限。</p>
<p>模拟按下菜单键。 此函数依赖于root权限。</p>
<h2 id="VolumeUp"><a href="#VolumeUp" class="headerlink" title="VolumeUp()"></a><a href="http://doc.autoxjs.com/#/keys?id=volumeup">VolumeUp()</a></h2><p>按下音量上键。 此函数依赖于root权限。</p>
<h2 id="VolumeDown"><a href="#VolumeDown" class="headerlink" title="VolumeDown()"></a><a href="http://doc.autoxjs.com/#/keys?id=volumedown">VolumeDown()</a></h2><p>按键音量上键。 此函数依赖于root权限。</p>
<h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera()"></a><a href="http://doc.autoxjs.com/#/keys?id=camera">Camera()</a></h2><p>模拟按下照相键。</p>
<h2 id="Up"><a href="#Up" class="headerlink" title="Up()"></a><a href="http://doc.autoxjs.com/#/keys?id=up">Up()</a></h2><p>模拟按下物理按键上。 此函数依赖于root权限。</p>
<h2 id="Down"><a href="#Down" class="headerlink" title="Down()"></a><a href="http://doc.autoxjs.com/#/keys?id=down">Down()</a></h2><p>模拟按下物理按键下。 此函数依赖于root权限。</p>
<h2 id="Left"><a href="#Left" class="headerlink" title="Left()"></a><a href="http://doc.autoxjs.com/#/keys?id=left">Left()</a></h2><p>模拟按下物理按键左。 此函数依赖于root权限。</p>
<h2 id="Right"><a href="#Right" class="headerlink" title="Right()"></a><a href="http://doc.autoxjs.com/#/keys?id=right">Right()</a></h2><p>模拟按下物理按键右。 此函数依赖于root权限。</p>
<h2 id="OK"><a href="#OK" class="headerlink" title="OK()"></a><a href="http://doc.autoxjs.com/#/keys?id=ok">OK()</a></h2><p>模拟按下物理按键确定。 此函数依赖于root权限。</p>
<h2 id="Text-text"><a href="#Text-text" class="headerlink" title="Text(text)"></a><a href="http://doc.autoxjs.com/#/keys?id=texttext">Text(text)</a></h2><ul>
<li><code>text</code> {string} 要输入的文字，只能为英文或英文符号 输入文字text。例如<code>Text(&quot;aaa&quot;);</code></li>
</ul>
<h2 id="KeyCode-code"><a href="#KeyCode-code" class="headerlink" title="KeyCode(code)"></a><a href="http://doc.autoxjs.com/#/keys?id=keycodecode">KeyCode(code)</a></h2><ul>
<li><code>code</code> {number} | 要按下的按键的数字代码或名称。参见下表。 模拟物理按键。例如<code>KeyCode(29)</code>和<code>KeyCode(&quot;KEYCODE_A&quot;)</code>是按下A键。</li>
</ul>
<h2 id="附录-KeyCode对照表"><a href="#附录-KeyCode对照表" class="headerlink" title="附录: KeyCode对照表"></a><a href="http://doc.autoxjs.com/#/keys?id=%e9%99%84%e5%bd%95-keycode%e5%af%b9%e7%85%a7%e8%a1%a8">附录: KeyCode对照表</a></h2><p>KeyCode KeyEvent Value</p>
<ul>
<li>KEYCODE_MENU 1</li>
<li>KEYCODE_SOFT_RIGHT 2</li>
<li>KEYCODE_HOME 3</li>
<li>KEYCODE_BACK 4</li>
<li>KEYCODE_CALL 5</li>
<li>KEYCODE_ENDCALL 6</li>
<li>KEYCODE_0 7</li>
<li>KEYCODE_1 8</li>
<li>KEYCODE_2 9</li>
<li>KEYCODE_3 10</li>
<li>KEYCODE_4 11</li>
<li>KEYCODE_5 12</li>
<li>KEYCODE_6 13</li>
<li>KEYCODE_7 14</li>
<li>KEYCODE_8 15</li>
<li>KEYCODE_9 16</li>
<li>KEYCODE_STAR 17</li>
<li>KEYCODE_POUND 18</li>
<li>KEYCODE_DPAD_UP 19</li>
<li>KEYCODE_DPAD_DOWN 20</li>
<li>KEYCODE_DPAD_LEFT 21</li>
<li>KEYCODE_DPAD_RIGHT 22</li>
<li>KEYCODE_DPAD_CENTER 23</li>
<li>KEYCODE_VOLUME_UP 24</li>
<li>KEYCODE_VOLUME_DOWN 25</li>
<li>KEYCODE_POWER 26</li>
<li>KEYCODE_CAMERA 27</li>
<li>KEYCODE_CLEAR 28</li>
<li>KEYCODE_A 29</li>
<li>KEYCODE_B 30</li>
<li>KEYCODE_C 31</li>
<li>KEYCODE_D 32</li>
<li>KEYCODE_E 33</li>
<li>KEYCODE_F 34</li>
<li>KEYCODE_G 35</li>
<li>KEYCODE_H 36</li>
<li>KEYCODE_I 37</li>
<li>KEYCODE_J 38</li>
<li>KEYCODE_K 39</li>
<li>KEYCODE_L 40</li>
<li>KEYCODE_M 41</li>
<li>KEYCODE_N 42</li>
<li>KEYCODE_O 43</li>
<li>KEYCODE_P 44</li>
<li>KEYCODE_Q 45</li>
<li>KEYCODE_R 46</li>
<li>KEYCODE_S 47</li>
<li>KEYCODE_T 48</li>
<li>KEYCODE_U 49</li>
<li>KEYCODE_V 50</li>
<li>KEYCODE_W 51</li>
<li>KEYCODE_X 52</li>
<li>KEYCODE_Y 53</li>
<li>KEYCODE_Z 54</li>
<li>KEYCODE_COMMA 55</li>
<li>KEYCODE_PERIOD 56</li>
<li>KEYCODE_ALT_LEFT 57</li>
<li>KEYCODE_ALT_RIGHT 58</li>
<li>KEYCODE_SHIFT_LEFT 59</li>
<li>KEYCODE_SHIFT_RIGHT 60</li>
<li>KEYCODE_TAB 61</li>
<li>KEYCODE_SPACE 62</li>
<li>KEYCODE_SYM 63</li>
<li>KEYCODE_EXPLORER 64</li>
<li>KEYCODE_ENVELOPE 65</li>
<li>KEYCODE_ENTER 66</li>
<li>KEYCODE_DEL 67</li>
<li>KEYCODE_GRAVE 68</li>
<li>KEYCODE_MINUS 69</li>
<li>KEYCODE_EQUALS 70</li>
<li>KEYCODE_LEFT_BRACKET 71</li>
<li>KEYCODE_RIGHT_BRACKET 72</li>
<li>KEYCODE_BACKSLASH 73</li>
<li>KEYCODE_SEMICOLON 74</li>
<li>KEYCODE_APOSTROPHE 75</li>
<li>KEYCODE_SLASH 76</li>
<li>KEYCODE_AT 77</li>
<li>KEYCODE_NUM 78</li>
<li>KEYCODE_HEADSETHOOK 79</li>
<li>KEYCODE_FOCUS 80</li>
<li>KEYCODE_PLUS 81</li>
<li>KEYCODE_MENU 82</li>
<li>KEYCODE_NOTIFICATION 83</li>
<li>KEYCODE_SEARCH 84</li>
<li>TAG_LAST_ KEYCODE 85</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>控制台 Console</title>
    <url>//blog/note/code/AutoXjs/console.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Console"><a href="#Console" class="headerlink" title="Console"></a><a href="http://doc.autoxjs.com/#/console?id=console">Console</a></h1><h2 id="Console-1"><a href="#Console-1" class="headerlink" title="Console"></a><a href="http://doc.autoxjs.com/#/console?id=console">Console</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>控制台模块提供了一个和Web浏览器中相似的用于调试的控制台。用于输出一些调试信息、中间结果等。 console模块中的一些函数也可以直接作为全局函数使用，例如log, print等。</p>
<h2 id="console-show-autoHide"><a href="#console-show-autoHide" class="headerlink" title="console.show(autoHide)"></a><a href="http://doc.autoxjs.com/#/console?id=consoleshowautohide">console.show(autoHide)</a></h2><ul>
<li><p><code>autoHide</code> {boolean} 是否自动隐藏，默认false当程序结束的时候是否自动隐藏控制 显示控制台。这会显示一个控制台的悬浮窗(需要悬浮窗权限)。</p>
<p>console.show(true); &#x2F;&#x2F;程序结束自动 隐藏控制台<br>console.show();   &#x2F;&#x2F;结束不会自动隐藏控制台</p>
</li>
</ul>
<h2 id="console-hide"><a href="#console-hide" class="headerlink" title="console.hide()"></a><a href="http://doc.autoxjs.com/#/console?id=consolehide">console.hide()</a></h2><p>隐藏控制台悬浮窗。</p>
<h2 id="console-clear"><a href="#console-clear" class="headerlink" title="console.clear()"></a><a href="http://doc.autoxjs.com/#/console?id=consoleclear">console.clear()</a></h2><p>清空控制台。</p>
<h2 id="console-log-data-…args"><a href="#console-log-data-…args" class="headerlink" title="console.log([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consolelogdata-args">console.log([data][, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>打印到控制台，并带上换行符。 可以传入多个参数，第一个参数作为主要信息，其他参数作为类似于 <a href="http://man7.org/linux/man-pages/man3/printf.3.html">printf(3)</a> 中的代替值（参数都会传给 util.format()）。</p>
<pre><code>const count = 5;
console.log(&#39;count: %d&#39;, count);
// 打印: count: 5 到 stdout
console.log(&#39;count:&#39;, count);
// 打印: count: 5 到 stdout
</code></pre>
<p>详见 util.format()。</p>
<p>该函数也可以作为全局函数使用。</p>
<h2 id="console-verbose-data-…args"><a href="#console-verbose-data-…args" class="headerlink" title="console.verbose([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consoleverbosedata-args">console.verbose([data][, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log类似，但输出结果以灰色字体显示。输出优先级低于log，用于输出观察性质的信息。</p>
<h2 id="console-info-data-…args"><a href="#console-info-data-…args" class="headerlink" title="console.info([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consoleinfodata-args">console.info([data][, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log类似，但输出结果以绿色字体显示。输出优先级高于log, 用于输出重要信息。</p>
<h2 id="console-warn-data-…args"><a href="#console-warn-data-…args" class="headerlink" title="console.warn([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consolewarndata-args">console.warn([data][, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log类似，但输出结果以蓝色字体显示。输出优先级高于info, 用于输出警告信息。</p>
<h2 id="console-error-data-…args"><a href="#console-error-data-…args" class="headerlink" title="console.error([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consoleerrordata-args">console.error([data][, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log类似，但输出结果以红色字体显示。输出优先级高于warn, 用于输出错误信息。</p>
<h2 id="console-assert-value-message"><a href="#console-assert-value-message" class="headerlink" title="console.assert(value, message)"></a><a href="http://doc.autoxjs.com/#/console?id=consoleassertvalue-message">console.assert(value, message)</a></h2><ul>
<li><code>value</code> {any} 要断言的布尔值</li>
<li><code>message</code> {string} value为false时要输出的信息</li>
</ul>
<p>断言。如果value为false则输出错误信息message并停止脚本运行。</p>
<pre><code>var a = 1 + 1;
console.assert(a == 3, &quot;加法出错啦&quot;);
</code></pre>
<h2 id="console-time-label"><a href="#console-time-label" class="headerlink" title="console.time([label])"></a><a href="http://doc.autoxjs.com/#/console?id=consoletimelabel">console.time([label])</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>label</code> {String} 计时器标签，可省略</li>
</ul>
<p>启动一个计时器，用以计算一个操作的持续时间。 计时器由一个唯一的 <code>label</code> 标识。 若<code>label</code>重复，则会覆盖上一个同名<code>label</code>的计时器。 以同名 <code>label</code>调用 <code>console.timeEnd()</code> 来停止计时器，并以毫秒为单位将持续时间输出到控制台。</p>
<h2 id="console-timeEnd-label"><a href="#console-timeEnd-label" class="headerlink" title="console.timeEnd(label)"></a><a href="http://doc.autoxjs.com/#/console?id=consoletimeendlabel">console.timeEnd(label)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>label</code> {String} 计时器标签</li>
</ul>
<p>停止之前通过调用 <code>console.time()</code> 启动的定时器，并打印结果到控制台。 调用 <code>console.timeEnd()</code> 后定时器会被删除。如果不存在标签指定的定时器则会打印 <code>NaNms</code>。</p>
<pre><code>console.time(&#39;求和&#39;);
var sum = 0;
for(let i = 0; i &lt; 100000; i++)&#123;
    sum += i;
&#125;
console.timeEnd(&#39;求和&#39;);
// 打印 求和: xxx ms
</code></pre>
<h2 id="console-trace-data-…args"><a href="#console-trace-data-…args" class="headerlink" title="console.trace([data][, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consoletracedata-args">console.trace([data][, …args])</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log类似，同时会打印出调用这个函数所在的调用栈信息（即当前运行的文件、行数等信息）。</p>
<pre><code>console.trace(&#39;Show me&#39;);
// 打印: (堆栈跟踪会根据被调用的跟踪的位置而变化)
// Show me
//  at &lt;test&gt;:7
</code></pre>
<h2 id="console-input-data-…args"><a href="#console-input-data-…args" class="headerlink" title="console.input(data[, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consoleinputdata-args">console.input(data[, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与<code>console.log</code>一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串用<code>eval</code>计算后返回。</p>
<p><strong>部分机型可能会有控制台不显示输入框的情况，属于bug。</strong></p>
<p>例如：</p>
<pre><code>var n = console.input(&quot;请输入一个数字:&quot;); 
//输入123之后：
toast(n + 1);
//显示124
</code></pre>
<h2 id="console-rawInput-data-…args"><a href="#console-rawInput-data-…args" class="headerlink" title="console.rawInput(data[, …args])"></a><a href="http://doc.autoxjs.com/#/console?id=consolerawinputdata-args">console.rawInput(data[, …args])</a></h2><ul>
<li><code>data</code> {any}</li>
<li><code>...args</code> {any}</li>
</ul>
<p>与console.log一样输出信息，并在控制台显示输入框等待输入。按控制台的确认按钮后会将输入的字符串直接返回。</p>
<p>部分机型可能会有控制台不显示输入框的情况，属于bug。</p>
<p>例如：</p>
<pre><code>var n = console.rawInput(&quot;请输入一个数字:&quot;); 
//输入123之后：
toast(n + 1);
//显示1231
</code></pre>
<h2 id="console-setSize-w-h"><a href="#console-setSize-w-h" class="headerlink" title="console.setSize(w, h)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetsizew-h">console.setSize(w, h)</a></h2><ul>
<li><code>w</code> {number} 宽度</li>
<li><code>h</code> {number} 高度</li>
</ul>
<p>设置控制台的大小，单位像素。</p>
<pre><code>console.show();
//设置控制台大小为屏幕的四分之一
console.setSize(device.width / 2, device.height / 2);
</code></pre>
<h2 id="console-setPosition-x-y"><a href="#console-setPosition-x-y" class="headerlink" title="console.setPosition(x, y)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetpositionx-y">console.setPosition(x, y)</a></h2><ul>
<li><code>x</code> {number} 横坐标</li>
<li><code>y</code> {number} 纵坐标</li>
</ul>
<p>设置控制台的位置，单位像素。</p>
<pre><code>console.show();
console.setPosition(100, 100);
</code></pre>
<h2 id="console-setGlobalLogConfig-config"><a href="#console-setGlobalLogConfig-config" class="headerlink" title="console.setGlobalLogConfig(config)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetgloballogconfigconfig">console.setGlobalLogConfig(config)</a></h2><p><strong>[v4.1.0新增]</strong></p>
<ul>
<li><code>config</code> {Object} 日志配置，可选的项有：<ul>
<li><code>file</code> {string} 日志文件路径，将会把日志写入该文件中</li>
<li><code>maxFileSize</code> {number} 最大文件大小，单位字节，默认为512 * 1024 (512KB)</li>
<li><code>rootLevel</code> {string} 写入的日志级别，默认为”ALL”（所有日志），可以为”OFF”(关闭), “DEBUG”, “INFO”, “WARN”, “ERROR”, “FATAL”等。</li>
<li><code>maxBackupSize</code> {number} 日志备份文件最大数量，默认为5</li>
<li><code>filePattern</code> {string} 日志写入格式，参见<a href="http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html">PatternLayout</a></li>
</ul>
</li>
</ul>
<p>设置日志保存的路径和配置。例如把日志保存到”&#x2F;sdcard&#x2F;1.txt”:</p>
<pre><code>console.setGlobalLogConfig(&#123;
    &quot;file&quot;: &quot;/sdcard/1.txt&quot;
&#125;);
</code></pre>
<h2 id="print-text"><a href="#print-text" class="headerlink" title="print(text)"></a><a href="http://doc.autoxjs.com/#/console?id=printtext">print(text)</a></h2><ul>
<li>text {string} | {Object} 要打印到控制台的信息</li>
</ul>
<p>相当于<code>log(text)</code>。</p>
<h2 id="console-setTitle-title-color-size"><a href="#console-setTitle-title-color-size" class="headerlink" title="console.setTitle(title,color,size)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesettitletitlecolorsize">console.setTitle(title,color,size)</a></h2><p><strong>[v4.2.5新增]</strong></p>
<ul>
<li><code>title</code> {string} 标题</li>
<li><code>color</code> {string} 颜色值 #AARRGGBB</li>
<li><code>size</code> {number} 标题高度，字号会随高度变化，单位是dp</li>
</ul>
<p>设置标题名称，字体颜色，标题栏高度</p>
<pre><code>console.setTitle(&quot;中文&quot;,&quot;#ff11ee00&quot;,30);
console.setTitle(&quot;中文&quot;);
console.setTitle(&quot;中文&quot;,&quot;#ff11ee00&quot;);
</code></pre>
<h2 id="console-setLogSize-size"><a href="#console-setLogSize-size" class="headerlink" title="console.setLogSize(size)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetlogsizesize">console.setLogSize(size)</a></h2><p><strong>[v4.2.5新增]</strong></p>
<ul>
<li><code>size</code> {number} 字号大小，单位是dp或sp 20以内比较合适<br>设置log字号大小</li>
</ul>
<p><strong>需要在显示控制台之后才能设置，否则空指针</strong></p>
<pre><code>function myrandom(min,max)&#123;
    return Math.floor(Math.random() * (max - min + 1) ) + min;
&#125;

threads.start(function () &#123;
    console.show();
    console.setTitle(&quot;中文&quot;,&quot;#ff11ee00&quot;,30);
    console.setCanInput(false);
    var i=0;    
    do &#123;
        console.setLogSize(myrandom(4,20) );
        console.setCanInput(i%2==0);
        i++;
        console.log(&quot;i-----&gt;&quot;+i);
        sleep(3000);
    &#125; while (true);

&#125;); 
</code></pre>
<p>​      </p>
<h2 id="console-setCanInput-can"><a href="#console-setCanInput-can" class="headerlink" title="console.setCanInput(can)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetcaninputcan">console.setCanInput(can)</a></h2><p><strong>[v4.2.5新增]</strong></p>
<ul>
<li><code>can</code> {boolean} true 或 false 可以输入或不可以输入</li>
</ul>
<p>控制 console 是否可以输入文字</p>
<pre><code>console.setCanInput(false);
</code></pre>
<h2 id="console-setBackgroud-color"><a href="#console-setBackgroud-color" class="headerlink" title="console.setBackgroud(color)"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetbackgroudcolor">console.setBackgroud(color)</a></h2><p><strong>[v4.2.5新增]</strong></p>
<ul>
<li><code>color</code> {string} 颜色值 #AARRGGBB</li>
</ul>
<p>设置 console 背景色,<strong>需要在显示控制台之后才能设置，否则空指针</strong></p>
<pre><code>console.setBackgroud(&quot;#33ef0000&quot;);
</code></pre>
<h2 id="console-setMaxLines-maxLines"><a href="#console-setMaxLines-maxLines" class="headerlink" title="console.setMaxLines(maxLines);"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetmaxlinesmaxlines">console.setMaxLines(maxLines);</a></h2><p><strong>[v5.0.2新增]</strong></p>
<ul>
<li><p><code>maxLines</code> {number} 最大行数 如 10 行 设置 console 显示最大行数，默认-1，不限 ，超出行数系统会清空，从0开始显示 不限制，显示列表过长，android内存又不足，系统会回收console的引用，即console 将不显示。</p>
<p>console.setMaxLines(500);</p>
</li>
</ul>
<h2 id="console-setBackground"><a href="#console-setBackground" class="headerlink" title="console.setBackground()"></a><a href="http://doc.autoxjs.com/#/console?id=consolesetbackground">console.setBackground()</a></h2>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理 files</title>
    <url>//blog/note/code/AutoXjs/files.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a><a href="http://doc.autoxjs.com/#/files?id=files">Files</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>files模块提供了一些常见的文件处理，包括文件读写、移动、复制、删掉等。</p>
<p>一次性的文件读写可以直接使用<code>files.read()</code>, <code>files.write()</code>, <code>files.append()</code>等方便的函数，但如果需要频繁读写或随机读写，则使用<code>open()</code>函数打开一个文件对象来操作文件，并在操作完毕后调用<code>close()</code>函数关闭文件。</p>
<h2 id="files-isFile-path"><a href="#files-isFile-path" class="headerlink" title="files.isFile(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesisfilepath">files.isFile(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>返回路径path是否是文件。</p>
<pre><code>log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回false
log(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回true
</code></pre>
<h2 id="files-isDir-path"><a href="#files-isDir-path" class="headerlink" title="files.isDir(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesisdirpath">files.isDir(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>返回路径path是否是文件夹。</p>
<pre><code>log(files.isDir(&quot;/sdcard/文件夹/&quot;)); //返回true
log(files.isDir(&quot;/sdcard/文件.txt&quot;)); //返回false
</code></pre>
<h2 id="files-isEmptyDir-path"><a href="#files-isEmptyDir-path" class="headerlink" title="files.isEmptyDir(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesisemptydirpath">files.isEmptyDir(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>返回文件夹path是否为空文件夹。如果该路径并非文件夹，则直接返回<code>false</code>。</p>
<h2 id="files-join-parent-child"><a href="#files-join-parent-child" class="headerlink" title="files.join(parent, child)"></a><a href="http://doc.autoxjs.com/#/files?id=filesjoinparent-child">files.join(parent, child)</a></h2><ul>
<li><code>parent</code> {string} 父目录路径</li>
<li><code>child</code> {string} 子路径</li>
<li>返回 {string}</li>
</ul>
<p>连接两个路径并返回，例如<code>files.join(&quot;/sdcard/&quot;, &quot;1.txt&quot;)</code>返回”&#x2F;sdcard&#x2F;1.txt”。</p>
<h2 id="files-create-path"><a href="#files-create-path" class="headerlink" title="files.create(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filescreatepath">files.create(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>创建一个文件或文件夹并返回是否创建成功。如果文件已经存在，则直接返回<code>false</code>。</p>
<pre><code>files.create(&quot;/sdcard/新文件夹/&quot;);
</code></pre>
<h2 id="files-createWithDirs-path"><a href="#files-createWithDirs-path" class="headerlink" title="files.createWithDirs(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filescreatewithdirspath">files.createWithDirs(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>创建一个文件或文件夹并返回是否创建成功。如果文件所在文件夹不存在，则先创建他所在的一系列文件夹。如果文件已经存在，则直接返回<code>false</code>。</p>
<pre><code>files.createWithDirs(&quot;/sdcard/新文件夹/新文件夹/新文件夹/1.txt&quot;);
</code></pre>
<h2 id="files-exists-path"><a href="#files-exists-path" class="headerlink" title="files.exists(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesexistspath">files.exists(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>返回在路径path处的文件是否存在。</p>
<h2 id="files-ensureDir-path"><a href="#files-ensureDir-path" class="headerlink" title="files.ensureDir(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesensuredirpath">files.ensureDir(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
</ul>
<p>确保路径path所在的文件夹存在。如果该路径所在文件夹不存在，则创建该文件夹。</p>
<p>例如对于路径”&#x2F;sdcard&#x2F;Download&#x2F;ABC&#x2F;1.txt”，如果&#x2F;Download&#x2F;文件夹不存在，则会先创建Download，再创建ABC文件夹。</p>
<h2 id="files-read-path-encoding-“utf-8”"><a href="#files-read-path-encoding-“utf-8”" class="headerlink" title="files.read(path[, encoding &#x3D; “utf-8”])"></a><a href="http://doc.autoxjs.com/#/files?id=filesreadpath-encoding-quotutf-8quot">files.read(path[, encoding &#x3D; “utf-8”])</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>encoding</code> {string} 字符编码，可选，默认为utf-8</li>
<li>返回 {string}</li>
</ul>
<p>读取文本文件path的所有内容并返回。如果文件不存在，则抛出<code>FileNotFoundException</code>。</p>
<pre><code>log(files.read(&quot;/sdcard/1.txt&quot;));
</code></pre>
<h2 id="files-readBytes-path"><a href="#files-readBytes-path" class="headerlink" title="files.readBytes(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesreadbytespath">files.readBytes(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {byte[]}</li>
</ul>
<p>读取文件path的所有内容并返回一个字节数组。如果文件不存在，则抛出<code>FileNotFoundException</code>。</p>
<p>注意，该数组是Java的数组，不具有JavaScript数组的forEach, slice等函数。</p>
<p>一个以16进制形式打印文件的例子如下:</p>
<pre><code>var data = files.readBytes(&quot;/sdcard/1.png&quot;);
var sb = new java.lang.StringBuilder();
for(var i = 0; i &lt; data.length; i++)&#123;
    sb.append(data[i].toString(16));
&#125;
log(sb.toString());
</code></pre>
<h2 id="files-write-path-text-encoding-“utf-8”"><a href="#files-write-path-text-encoding-“utf-8”" class="headerlink" title="files.write(path, text[, encoding &#x3D; “utf-8”])"></a><a href="http://doc.autoxjs.com/#/files?id=fileswritepath-text-encoding-quotutf-8quot">files.write(path, text[, encoding &#x3D; “utf-8”])</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>text</code> {string} 要写入的文本内容</li>
<li><code>encoding</code> {string} 字符编码</li>
</ul>
<p>把text写入到文件path中。如果文件存在则覆盖，不存在则创建。</p>
<pre><code>var text = &quot;文件内容&quot;;
//写入文件
files.write(&quot;/sdcard/1.txt&quot;, text);
//用其他应用查看文件
app.viewFile(&quot;/sdcard/1.txt&quot;);
</code></pre>
<h2 id="files-writeBytes-path-bytes"><a href="#files-writeBytes-path-bytes" class="headerlink" title="files.writeBytes(path, bytes)"></a><a href="http://doc.autoxjs.com/#/files?id=fileswritebytespath-bytes">files.writeBytes(path, bytes)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>bytes</code> {byte[]} 字节数组，要写入的二进制数据</li>
</ul>
<p>把bytes写入到文件path中。如果文件存在则覆盖，不存在则创建。</p>
<h2 id="files-append-path-text-encoding-‘utf-8’"><a href="#files-append-path-text-encoding-‘utf-8’" class="headerlink" title="files.append(path, text[, encoding &#x3D; ‘utf-8’])"></a><a href="http://doc.autoxjs.com/#/files?id=filesappendpath-text-encoding-39utf-839">files.append(path, text[, encoding &#x3D; ‘utf-8’])</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>text</code> {string} 要写入的文本内容</li>
<li><code>encoding</code> {string} 字符编码</li>
</ul>
<p>把text追加到文件path的末尾。如果文件不存在则创建。</p>
<pre><code>var text = &quot;追加的文件内容&quot;;
files.append(&quot;/sdcard/1.txt&quot;, text);
files.append(&quot;/sdcard/1.txt&quot;, text);
//用其他应用查看文件
app.viewFile(&quot;/sdcard/1.txt&quot;);
</code></pre>
<h2 id="files-appendBytes-path-text-encoding-‘utf-8’"><a href="#files-appendBytes-path-text-encoding-‘utf-8’" class="headerlink" title="files.appendBytes(path, text[, encoding &#x3D; ‘utf-8’])"></a><a href="http://doc.autoxjs.com/#/files?id=filesappendbytespath-text-encoding-39utf-839">files.appendBytes(path, text[, encoding &#x3D; ‘utf-8’])</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>bytes</code> {byte[]} 字节数组，要写入的二进制数据</li>
</ul>
<p>把bytes追加到文件path的末尾。如果文件不存在则创建。</p>
<h2 id="files-copy-fromPath-toPath"><a href="#files-copy-fromPath-toPath" class="headerlink" title="files.copy(fromPath, toPath)"></a><a href="http://doc.autoxjs.com/#/files?id=filescopyfrompath-topath">files.copy(fromPath, toPath)</a></h2><ul>
<li><code>fromPath</code> {string} 要复制的原文件路径</li>
<li><code>toPath</code> {string} 复制到的文件路径</li>
<li>返回 {boolean}</li>
</ul>
<p>复制文件，返回是否复制成功。例如<code>files.copy(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)</code>。</p>
<h2 id="files-move-fromPath-toPath"><a href="#files-move-fromPath-toPath" class="headerlink" title="files.move(fromPath, toPath)"></a><a href="http://doc.autoxjs.com/#/files?id=filesmovefrompath-topath">files.move(fromPath, toPath)</a></h2><ul>
<li><code>fromPath</code> {string} 要移动的原文件路径</li>
<li><code>toPath</code> {string} 移动到的文件路径</li>
<li>返回 {boolean}</li>
</ul>
<p>移动文件，返回是否移动成功。例如<code>files.move(&quot;/sdcard/1.txt&quot;, &quot;/sdcard/Download/1.txt&quot;)</code>会把1.txt文件从sd卡根目录移动到Download文件夹。</p>
<h2 id="files-rename-path-newName"><a href="#files-rename-path-newName" class="headerlink" title="files.rename(path, newName)"></a><a href="http://doc.autoxjs.com/#/files?id=filesrenamepath-newname">files.rename(path, newName)</a></h2><ul>
<li><code>path</code> {string} 要重命名的原文件路径</li>
<li><code>newName</code> {string} 要重命名的新文件名</li>
<li>返回 {boolean}</li>
</ul>
<p>重命名文件，并返回是否重命名成功。例如<code>files.rename(&quot;/sdcard/1.txt&quot;, &quot;2.txt&quot;)</code>。</p>
<h2 id="files-renameWithoutExtension-path-newName"><a href="#files-renameWithoutExtension-path-newName" class="headerlink" title="files.renameWithoutExtension(path, newName)"></a><a href="http://doc.autoxjs.com/#/files?id=filesrenamewithoutextensionpath-newname">files.renameWithoutExtension(path, newName)</a></h2><ul>
<li><code>path</code> {string} 要重命名的原文件路径</li>
<li><code>newName</code> {string} 要重命名的新文件名</li>
<li>返回 {boolean}</li>
</ul>
<p>重命名文件，不包含拓展名，并返回是否重命名成功。例如<code>files.rename(&quot;/sdcard/1.txt&quot;, &quot;2&quot;)</code>会把”1.txt”重命名为”2.txt”。</p>
<h2 id="files-getName-path"><a href="#files-getName-path" class="headerlink" title="files.getName(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesgetnamepath">files.getName(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {string}</li>
</ul>
<p>返回文件的文件名。例如<code>files.getName(&quot;/sdcard/1.txt&quot;)</code>返回”1.txt”。</p>
<h2 id="files-getNameWithoutExtension-path"><a href="#files-getNameWithoutExtension-path" class="headerlink" title="files.getNameWithoutExtension(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesgetnamewithoutextensionpath">files.getNameWithoutExtension(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {string}</li>
</ul>
<p>返回不含拓展名的文件的文件名。例如<code>files.getName(&quot;/sdcard/1.txt&quot;)</code>返回”1”。</p>
<h2 id="files-getExtension-path"><a href="#files-getExtension-path" class="headerlink" title="files.getExtension(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesgetextensionpath">files.getExtension(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {string}</li>
</ul>
<p>返回文件的拓展名。例如<code>files.getExtension(&quot;/sdcard/1.txt&quot;)</code>返回”txt”。</p>
<h2 id="files-remove-path"><a href="#files-remove-path" class="headerlink" title="files.remove(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesremovepath">files.remove(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>删除文件或<strong>空文件夹</strong>，返回是否删除成功。</p>
<h2 id="files-removeDir-path"><a href="#files-removeDir-path" class="headerlink" title="files.removeDir(path)"></a><a href="http://doc.autoxjs.com/#/files?id=filesremovedirpath">files.removeDir(path)</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>path</code> {string} 路径</li>
<li>返回 {boolean}</li>
</ul>
<p>删除文件夹，如果文件夹不为空，则删除该文件夹的所有内容再删除该文件夹，返回是否全部删除成功。</p>
<h2 id="files-getSdcardPath"><a href="#files-getSdcardPath" class="headerlink" title="files.getSdcardPath()"></a><a href="http://doc.autoxjs.com/#/files?id=filesgetsdcardpath">files.getSdcardPath()</a></h2><ul>
<li>返回 {string}</li>
</ul>
<p>返回SD卡路径。所谓SD卡，即外部存储器。</p>
<h2 id="files-cwd"><a href="#files-cwd" class="headerlink" title="files.cwd()"></a><a href="http://doc.autoxjs.com/#/files?id=filescwd">files.cwd()</a></h2><ul>
<li>返回 {string}</li>
</ul>
<p>返回脚本的”当前工作文件夹路径”。该路径指的是，如果脚本本身为脚本文件，则返回这个脚本文件所在目录；否则返回<code>null</code>获取其他设定路径。</p>
<p>例如，对于脚本文件”&#x2F;sdcard&#x2F;脚本&#x2F;1.js”运行<code>files.cwd()</code>返回”&#x2F;sdcard&#x2F;脚本&#x2F;“。</p>
<h2 id="files-path-relativePath"><a href="#files-path-relativePath" class="headerlink" title="files.path(relativePath)"></a><a href="http://doc.autoxjs.com/#/files?id=filespathrelativepath">files.path(relativePath)</a></h2><ul>
<li><code>relativePath</code> {string} 相对路径</li>
<li>返回 {string}</li>
</ul>
<p>返回相对路径对应的绝对路径。例如<code>files.path(&quot;./1.png&quot;)</code>，如果运行这个语句的脚本位于文件夹”&#x2F;sdcard&#x2F;脚本&#x2F;“中，则返回<code>&quot;/sdcard/脚本/1.png&quot;</code>。</p>
<h2 id="files-listDir-path-filter"><a href="#files-listDir-path-filter" class="headerlink" title="files.listDir(path[, filter])"></a><a href="http://doc.autoxjs.com/#/files?id=fileslistdirpath-filter">files.listDir(path[, filter])</a></h2><ul>
<li><code>path</code> {string} 路径</li>
<li><code>filter</code> {Function} 过滤函数，可选。接收一个<code>string</code>参数（文件名），返回一个<code>boolean</code>值。</li>
</ul>
<p>列出文件夹path下的满足条件的文件和文件夹的名称的数组。如果不加filter参数，则返回所有文件和文件夹。</p>
<p>列出sdcard目录下所有文件和文件夹为:</p>
<pre><code>var arr = files.listDir(&quot;/sdcard/&quot;);
log(arr);
</code></pre>
<p>列出脚本目录下所有js脚本文件为:</p>
<pre><code>var dir = &quot;/sdcard/脚本/&quot;;
var jsFiles = files.listDir(dir, function(name)&#123;
    return name.endsWith(&quot;.js&quot;) &amp;&amp; files.isFile(files.join(dir, name));
&#125;);
log(jsFiles);
</code></pre>
<h2 id="open-path-mode-“r”-encoding-“utf-8”-bufferSize-8192"><a href="#open-path-mode-“r”-encoding-“utf-8”-bufferSize-8192" class="headerlink" title="open(path[, mode &#x3D; “r”, encoding &#x3D; “utf-8”, bufferSize &#x3D; 8192])"></a><a href="http://doc.autoxjs.com/#/files?id=openpath-mode-quotrquot-encoding-quotutf-8quot-buffersize-8192">open(path[, mode &#x3D; “r”, encoding &#x3D; “utf-8”, bufferSize &#x3D; 8192])</a></h2><ul>
<li><code>path</code> {string} 文件路径，例如”&#x2F;sdcard&#x2F;1.txt”。</li>
<li><code>mode</code> {string} 文件打开模式，包括:<ul>
<li><code>r</code>: 只读文本模式。该模式下只能对文件执行<strong>文本</strong>读取操作。</li>
<li><code>w</code>: 只写文本模式。该模式下只能对文件执行<strong>文本</strong>覆盖写入操作。</li>
<li><code>a</code>: 附加文本模式。该模式下将会把写入的文本附加到文件末尾。</li>
<li><code>rw</code>: 随机读写文本模式。该模式下将会把写入的文本附加到文件末尾。<br>目前暂不支持二进制模式，随机读写模式。</li>
</ul>
</li>
<li><code>encoding</code> {string} 字符编码。</li>
<li><code>bufferSize</code> {number} 文件读写的缓冲区大小。</li>
</ul>
<p>打开一个文件。根据打开模式返回不同的文件对象。包括：</p>
<ul>
<li>“r”: 返回一个ReadableTextFile对象。</li>
<li>“w”, “a”: 返回一个WritableTextFile对象。</li>
</ul>
<p>对于”w”模式，如果文件并不存在，则会创建一个，已存在则会清空该文件内容；其他模式文件不存在会抛出FileNotFoundException。</p>
<h2 id="ReadableTextFile"><a href="#ReadableTextFile" class="headerlink" title="ReadableTextFile"></a><a href="http://doc.autoxjs.com/#/files?id=readabletextfile">ReadableTextFile</a></h2><p>可读文件对象。</p>
<h2 id="ReadableTextFile-read"><a href="#ReadableTextFile-read" class="headerlink" title="ReadableTextFile.read()"></a><a href="http://doc.autoxjs.com/#/files?id=readabletextfileread">ReadableTextFile.read()</a></h2><p>返回该文件剩余的所有内容的字符串。</p>
<h2 id="ReadableTextFile-read-maxCount"><a href="#ReadableTextFile-read-maxCount" class="headerlink" title="ReadableTextFile.read(maxCount)"></a><a href="http://doc.autoxjs.com/#/files?id=readabletextfilereadmaxcount">ReadableTextFile.read(maxCount)</a></h2><ul>
<li><code>maxCount</code> {Number} 最大读取的字符数量</li>
</ul>
<p>读取该文件接下来最长为maxCount的字符串并返回。即使文件剩余内容不足maxCount也不会出错。</p>
<h2 id="ReadableTextFile-readline"><a href="#ReadableTextFile-readline" class="headerlink" title="ReadableTextFile.readline()"></a><a href="http://doc.autoxjs.com/#/files?id=readabletextfilereadline">ReadableTextFile.readline()</a></h2><p>读取一行并返回（不包含换行符）。</p>
<h2 id="ReadableTextFile-readlines"><a href="#ReadableTextFile-readlines" class="headerlink" title="ReadableTextFile.readlines()"></a><a href="http://doc.autoxjs.com/#/files?id=readabletextfilereadlines">ReadableTextFile.readlines()</a></h2><p>读取剩余的所有行，并返回它们按顺序组成的字符串数组。</p>
<h2 id="close"><a href="#close" class="headerlink" title="close()"></a><a href="http://doc.autoxjs.com/#/files?id=close">close()</a></h2><p>关闭该文件。</p>
<p><strong>打开一个文件不再使用时务必关闭</strong></p>
<h2 id="PWritableTextFile"><a href="#PWritableTextFile" class="headerlink" title="PWritableTextFile"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfile">PWritableTextFile</a></h2><p>可写文件对象。</p>
<h2 id="PWritableTextFile-write-text"><a href="#PWritableTextFile-write-text" class="headerlink" title="PWritableTextFile.write(text)"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfilewritetext">PWritableTextFile.write(text)</a></h2><ul>
<li><code>text</code> {string} 文本</li>
</ul>
<p>把文本内容text写入到文件中。</p>
<h2 id="PWritableTextFile-writeline-line"><a href="#PWritableTextFile-writeline-line" class="headerlink" title="PWritableTextFile.writeline(line)"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfilewritelineline">PWritableTextFile.writeline(line)</a></h2><ul>
<li><code>text</code> {string} 文本</li>
</ul>
<p>把文本line写入到文件中并写入一个换行符。</p>
<h2 id="PWritableTextFile-writelines-lines"><a href="#PWritableTextFile-writelines-lines" class="headerlink" title="PWritableTextFile.writelines(lines)"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfilewritelineslines">PWritableTextFile.writelines(lines)</a></h2><ul>
<li><code>lines</code> {Array} 字符串数组</li>
</ul>
<p>把很多行写入到文件中….</p>
<h2 id="PWritableTextFile-flush"><a href="#PWritableTextFile-flush" class="headerlink" title="PWritableTextFile.flush()"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfileflush">PWritableTextFile.flush()</a></h2><p>把缓冲区内容输出到文件中。</p>
<h2 id="PWritableTextFile-close"><a href="#PWritableTextFile-close" class="headerlink" title="PWritableTextFile.close()"></a><a href="http://doc.autoxjs.com/#/files?id=pwritabletextfileclose">PWritableTextFile.close()</a></h2><p>关闭文件。同时会被缓冲区内容输出到文件。</p>
<p><strong>打开一个文件写入后，不再使用时务必关闭，否则文件可能会丢失</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>本地储存 Storages</title>
    <url>//blog/note/code/AutoXjs/storages.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Storages"><a href="#Storages" class="headerlink" title="Storages"></a><a href="http://doc.autoxjs.com/#/storages?id=storages">Storages</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>storages模块提供了保存简单数据、用户配置等的支持。保存的数据除非应用被卸载或者被主动删除，否则会一直保留。</p>
<p>storages支持<code>number</code>, <code>boolean</code>, <code>string</code>等数据类型以及把<code>Object</code>, <code>Array</code>用<code>JSON.stringify</code>序列化存取。</p>
<p>storages保存的数据在脚本之间是共享的，任何脚本只要知道storage名称便可以获取到相应的数据，因此它不能用于敏感数据的储存。 storages无法像Web开发中LocalStorage一样提供根据域名独立的存储，因为脚本的路径随时可能改变。</p>
<h2 id="storages-create-name"><a href="#storages-create-name" class="headerlink" title="storages.create(name)"></a><a href="http://doc.autoxjs.com/#/storages?id=storagescreatename">storages.create(name)</a></h2><ul>
<li><code>name</code> {string} 本地存储名称</li>
</ul>
<p>创建一个本地存储并返回一个<a href="http://doc.autoxjs.com/#/storages?id=storage"><code>Storage</code></a>对象。不同名称的本地存储的数据是隔开的，而相同名称的本地存储的数据是共享的。</p>
<p>例如在一个脚本中，创建名称为ABC的存储并存入a&#x3D;123:</p>
<pre><code>var storage = storages.create(&quot;ABC&quot;);
storage.put(&quot;a&quot;, 123);
</code></pre>
<p>而在另一个脚本中是可以获取到ABC以及a的值的：</p>
<pre><code>var storage = storages.create(&quot;ABC&quot;);
log(&quot;a = &quot; + storage.get(&quot;a&quot;));
</code></pre>
<p>因此，本地存储的名称比较重要，尽量使用含有域名、作者邮箱等唯一信息的名称来避免冲突，例如：</p>
<pre><code>var storage = storages.create(&quot;2732014414@qq.com:ABC&quot;);
</code></pre>
<h2 id="storages-remove-name"><a href="#storages-remove-name" class="headerlink" title="storages.remove(name)"></a><a href="http://doc.autoxjs.com/#/storages?id=storagesremovename">storages.remove(name)</a></h2><ul>
<li><code>name</code> {string} 本地存储名称</li>
</ul>
<p>删除一个本地存储以及他的全部数据。如果该存储不存在，返回false；否则返回true。</p>
<h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a><a href="http://doc.autoxjs.com/#/storages?id=storage">Storage</a></h2><h2 id="Storage-get-key-defaultValue"><a href="#Storage-get-key-defaultValue" class="headerlink" title="Storage.get(key[, defaultValue])"></a><a href="http://doc.autoxjs.com/#/storages?id=storagegetkey-defaultvalue">Storage.get(key[, defaultValue])</a></h2><ul>
<li><code>key</code> {string} 键值</li>
<li><code>defaultValue</code> {any} 可选，默认值</li>
</ul>
<p>从本地存储中取出键值为key的数据并返回。</p>
<p>如果该存储中不包含该数据，这时若指定了默认值参数则返回默认值，否则返回undefined。</p>
<p>返回的数据可能是任意数据类型，这取决于使用<code>Storage.put</code>保存该键值的数据时的数据类型。</p>
<h2 id="Storage-put-key-value"><a href="#Storage-put-key-value" class="headerlink" title="Storage.put(key, value)"></a><a href="http://doc.autoxjs.com/#/storages?id=storageputkey-value">Storage.put(key, value)</a></h2><ul>
<li><code>key</code> {string} 键值</li>
<li><code>value</code> {any} 值</li>
</ul>
<p>把值value保存到本地存储中。value可以是undefined以外的任意数据类型。如果value为undefined则抛出TypeError。</p>
<p>存储的过程实际上是使用JSON.stringify把value转换为字符串再保存，因此value必须是可JSON化的才能被接受。</p>
<h2 id="Storage-remove-key"><a href="#Storage-remove-key" class="headerlink" title="Storage.remove(key)"></a><a href="http://doc.autoxjs.com/#/storages?id=storageremovekey">Storage.remove(key)</a></h2><ul>
<li><code>key</code> {string} 键值</li>
</ul>
<p>移除键值为key的数据。不返回任何值。</p>
<h2 id="Storage-contains-key"><a href="#Storage-contains-key" class="headerlink" title="Storage.contains(key)"></a><a href="http://doc.autoxjs.com/#/storages?id=storagecontainskey">Storage.contains(key)</a></h2><ul>
<li><code>key</code> {string} 键值</li>
</ul>
<p>返回该本地存储是否包含键值为key的数据。是则返回true，否则返回false。</p>
<h2 id="Storage-clear"><a href="#Storage-clear" class="headerlink" title="Storage.clear()"></a><a href="http://doc.autoxjs.com/#/storages?id=storageclear">Storage.clear()</a></h2><p>移除该本地存储的所有数据。不返回任何值。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>用户界面 UI</title>
    <url>//blog/note/code/AutoXjs/UI.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="用户界面-UI"><a href="#用户界面-UI" class="headerlink" title="用户界面: UI"></a><a href="http://doc.autoxjs.com/#/ui?id=%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2-ui">用户界面: UI</a></h2><p>ui 模块提供了编写用户界面的支持。</p>
<p>带有 ui 的脚本的的最前面必须使用 <code>&quot;ui&quot;;</code> 指定 ui 模式，否则脚本将不会以 ui 模式运行。</p>
<p>正确示范:</p>
<pre><code>&quot;ui&quot;;

//脚本的其他代码
</code></pre>
<p>字符串”ui”的前面可以有注释、空行和空格 <code>[v4.1.0 新增]</code>，但是不能有其他代码。</p>
<p>界面是由视图(View)组成的。View 分成两种，控件(Widget)和布局(Layout)。控件(Widget)用来具体显示文字、图片、网页等，比如文本控件(text)用来显示文字，按钮控件(button)则可以显示一个按钮并提供点击效果，图片控件(img)则用来显示来自网络或者文件的图片，除此之外还有输入框控件(input)、进度条控件(progressbar)、单选复选框控件(checkbox)等；布局(Layout)则是装着一个或多个控件的”容器”，用于控制在他里面的控件的位置，比如垂直布局(vertical)会把他里面的控件从上往下依次显示(即纵向排列)，水平布局(horizontal)则会把他里面的控件从左往右依次显示(即横向排列)，以及帧布局(frame)，他会把他里面的控件直接在左上角显示，如果有多个控件，后面的控件会重叠在前面的控件上。</p>
<p>我们使用 xml 来编写界面，并通过<code>ui.layout()</code>函数指定界面的布局 xml。举个例子：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical&gt;
        &lt;button text=&quot;第一个按钮&quot;/&gt;
        &lt;button text=&quot;第二个按钮&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个例子中，第 3~6 行的部分就是 xml，指定了界面的具体内容。代码的第 3 行的标签<code>&lt;vertical&gt; ... &lt;/vertical&gt;</code>表示垂直布局，布局的标签通常以<code>&lt;...&gt;</code>开始，以<code>&lt;/...&gt;</code>结束，两个标签之间的内容就是布局里面的内容，例如<code>&lt;frame&gt; ... &lt;/frame&gt;</code>。在这个例子中第 4, 5 行的内容就是垂直布局(vertical)里面的内容。代码的第 4 行是一个按钮控件(button)，控件的标签通常以<code>&lt;...</code>开始，以<code>/&gt;</code>结束，他们之间是控件的具体属性，例如<code>&lt;text ... /&gt;</code>。在这个例子中<code>text=&quot;第一个按钮&quot;</code>的部分就是按钮控件(button)的属性，这个属性指定了这个按钮控件的文本内容(text)为”第一个按钮”。</p>
<p>代码的第 5 行和第 4 行一样，也是一个按钮控件，只不过他的文本内容为”第二个按钮”。这两个控件在垂直布局中，因此会纵向排列，效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex1.png" alt="ex1"></p>
<p>如果我们把这个例子的垂直布局(vertical)改成水平布局(horizontal)，也即：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;horizontal&gt;
        &lt;button text=&quot;第一个按钮&quot;/&gt;
        &lt;button text=&quot;第二个按钮&quot;/&gt;
    &lt;/horizontal&gt;
);
</code></pre>
<p>则这两个按钮会横向排列，效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex1-horizontal.png" alt="ex1-horizontal"></p>
<p>一个控件可以指定多个属性(甚至可以不指定任何属性)，用空格隔开即可；布局同样也可以指定属性，例如:</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical bg=&quot;#ff0000&quot;&gt;
        &lt;button text=&quot;第一个按钮&quot; textSize=&quot;20sp&quot;/&gt;
        &lt;button text=&quot;第二个按钮&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>第三行<code>bg=&quot;#ff0000&quot;</code>指定了垂直布局的背景色(bg)为”#ff0000”，这是一个 RGB 颜色，表示红色(有关 RGB 的相关知识参见<a href="http://tool.oschina.net/commons?type=3">RGB 颜色对照表</a>)。第四行的<code>textSize=&quot;20sp&quot;</code>则指定了按钮控件的字体大小(textSize)为”20sp”，sp 是一个字体单位，暂时不用深入理会。上述代码的效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex-properties.png" alt="ex-properties"></p>
<p>一个界面便由一些布局和控件组成。为了便于文档阅读，我们再说明一下以下术语：</p>
<ul>
<li>子视图, 子控件: 布局里面的控件是这个布局的子控件&#x2F;子视图。实际上布局里面不仅仅只能有控件，还可以是嵌套的布局。因此用子视图(Child View)更准确一些。在上面的例子中，按钮便是垂直布局的子控件。</li>
<li>父视图，父布局：直接包含一个控件的布局是这个控件的父布局&#x2F;父视图(Parent View)。在上面的例子中，垂直布局便是按钮的父布局。</li>
</ul>
<h2 id="视图-View"><a href="#视图-View" class="headerlink" title="视图: View"></a><a href="http://doc.autoxjs.com/#/ui?id=%e8%a7%86%e5%9b%be-view">视图: View</a></h2><p>控件和布局都属于视图(View)。在这个章节中将介绍所有控件和布局的共有的属性和函数。例如属性背景，宽高等(所有控件和布局都能设置背景和宽高)，函数<code>click()</code>设置视图(View)被点击时执行的动作。</p>
<h2 id="w"><a href="#w" class="headerlink" title="w"></a><a href="http://doc.autoxjs.com/#/ui?id=w">w</a></h2><p>View 的宽度，是属性<code>width</code>的缩写形式。可以设置的值为<code>*</code>, <code>auto</code>和具体数值。其中<code>*</code>表示宽度<strong>尽量</strong>填满父布局，而<code>auto</code>表示宽度将根据 View 的内容自动调整(自适应宽度)。例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;horizontal&gt;
        &lt;button w=&quot;auto&quot; text=&quot;自适应宽度&quot;/&gt;
        &lt;button w=&quot;*&quot; text=&quot;填满父布局&quot;/&gt;
    &lt;/horizontal&gt;
);
</code></pre>
<p>在这个例子中，第一个按钮为自适应宽度，第二个按钮为填满父布局，显示效果为：</p>
<p><img src="http://doc.autoxjs.com/images/ex-w.png" alt="ex-w"></p>
<p>如果不设置该属性，则不同的控件和布局有不同的默认宽度，大多数为<code>auto</code>。</p>
<p>宽度属性也可以指定一个具体数值。例如<code>w=&quot;20&quot;</code>，<code>w=&quot;20px&quot;</code>等。不加单位的情况下默认单位为 dp，其他单位包括 px(像素), mm(毫米), in(英寸)。有关尺寸单位的更多内容，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;horizontal&gt;
        &lt;button w=&quot;200&quot; text=&quot;宽度200dp&quot;/&gt;
        &lt;button w=&quot;100&quot; text=&quot;宽度100dp&quot;/&gt;
    &lt;/horizontal&gt;
);
</code></pre>
<h2 id="h"><a href="#h" class="headerlink" title="h"></a><a href="http://doc.autoxjs.com/#/ui?id=h">h</a></h2><p>View 的高度，是属性<code>height</code>的缩写形式。可以设置的值为<code>*</code>, <code>auto</code>和具体数值。其中<code>*</code>表示宽度<strong>尽量</strong>填满父布局，而<code>auto</code>表示宽度将根据 View 的内容自动调整(自适应宽度)。</p>
<p>如果不设置该属性，则不同的控件和布局有不同的默认高度，大多数为<code>auto</code>。</p>
<p>宽度属性也可以指定一个具体数值。例如<code>h=&quot;20&quot;</code>，<code>h=&quot;20px&quot;</code>等。不加单位的情况下默认单位为 dp，其他单位包括 px(像素), mm(毫米), in(英寸)。有关尺寸单位的更多内容，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a><a href="http://doc.autoxjs.com/#/ui?id=id">id</a></h2><p>View 的 id，用来区分一个界面下的不同控件和布局，一个界面的 id 在同一个界面下通常是唯一的，也就是一般不存在两个 View 有相同的 id。id 属性也是连接 xml 布局和 JavaScript 代码的桥梁，在代码中可以通过一个 View 的 id 来获取到这个 View，并对他进行操作(设置点击动作、设置属性、获取属性等)。例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame&gt;
        &lt;button id=&quot;ok&quot; text=&quot;确定&quot;/&gt;
    &lt;/frame&gt;
);
//通过ui.ok获取到按钮控件
toast(ui.ok.getText());
</code></pre>
<p>这个例子中有一个按钮控件”确定”，id 属性为”ok”，那么我们可以在代码中使用<code>ui.ok</code>来获取他，再通过<code>getText()</code>函数获取到这个按钮控件的文本内容。 另外这个例子中使用帧布局(frame)是因为，我们只有一个控件，因此用于最简单的布局帧布局。</p>
<h2 id="gravity"><a href="#gravity" class="headerlink" title="gravity"></a><a href="http://doc.autoxjs.com/#/ui?id=gravity">gravity</a></h2><p>View 的”重力”。用于决定 View 的内容相对于 View 的位置，可以设置的值为:</p>
<ul>
<li><code>left</code> 靠左</li>
<li><code>right</code> 靠右</li>
<li><code>top</code> 靠顶部</li>
<li><code>bottom</code> 靠底部</li>
<li><code>center</code> 居中</li>
<li><code>center_vertical</code> 垂直居中</li>
<li><code>center_horizontal</code> 水平居中</li>
</ul>
<p>例如对于一个按钮控件，<code>gravity=&quot;right&quot;</code>会使其中的文本内容靠右显示。例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame&gt;
        &lt;button gravity=&quot;right&quot; w=&quot;*&quot; h=&quot;auto&quot; text=&quot;靠右的文字&quot;/&gt;
    &lt;/frame&gt;
);
</code></pre>
<p>显示效果为:</p>
<p><img src="http://doc.autoxjs.com/images/ex-gravity.png" alt="ex-gravity"></p>
<p>这些属性是可以组合的，例如<code>gravity=&quot;right|bottom&quot;</code>的 View 他的内容会在右下角。</p>
<h2 id="layout-gravity"><a href="#layout-gravity" class="headerlink" title="layout_gravity"></a><a href="http://doc.autoxjs.com/#/ui?id=layout_gravity">layout_gravity</a></h2><p>View 在布局中的”重力”，用于决定 View 本身在他的<strong>父布局</strong>的位置，可以设置的值和 gravity 属性相同。注意把这个属性和 gravity 属性区分开来。</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame w=&quot;*&quot; h=&quot;*&quot;&gt;
        &lt;button layout_gravity=&quot;center&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;居中的按钮&quot;/&gt;
        &lt;button layout_gravity=&quot;right|bottom&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;右下角的按钮&quot;/&gt;
    &lt;/frame&gt;
);
</code></pre>
<p>在这个例子中，我们让帧布局(frame)的大小占满整个屏幕，通过给第一个按钮设置属性<code>layout_gravity=&quot;center&quot;</code>来使得按钮在帧布局中居中，通过给第二个按钮设置属性<code>layout_gravity=&quot;right|bottom&quot;</code>使得他在帧布局中位于右下角。效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex-layout-gravity.png" alt="ex-layout-gravity"></p>
<p>要注意的是，layout_gravity 的属性不一定总是生效的，具体取决于布局的类别。例如不能让水平布局中的第一个子控件靠底部显示(否则和水平布局本身相违背)。</p>
<h2 id="margin"><a href="#margin" class="headerlink" title="margin"></a><a href="http://doc.autoxjs.com/#/ui?id=margin">margin</a></h2><p>margin 为 View 和其他 View 的间距，即外边距。margin 属性包括四个值:</p>
<ul>
<li><code>marginLeft</code> 左外边距</li>
<li><code>marginRight</code> 右外边距</li>
<li><code>marginTop</code> 上外边距</li>
<li><code>marginBottom</code> 下外边距</li>
</ul>
<p>而 margin 属性本身的值可以有三种格式:</p>
<ul>
<li><code>margin=&quot;marginAll&quot;</code> 指定各个外边距都是该值。例如<code>margin=&quot;10&quot;</code>表示左右上下边距都是 10dp。</li>
<li><code>margin=&quot;marginLeft marginTop marginRight marginBottom&quot;</code> 分别指定各个外边距。例如<code>margin=&quot;10 20 30 40&quot;</code>表示左边距为 10dp, 上边距为 20dp, 右边距为 30dp, 下边距为 40dp</li>
<li><code>margin=&quot;marginHorizontal marginVertical&quot;</code> 指定水平外边距和垂直外边距。例如<code>margin=&quot;10 20&quot;</code>表示左右边距为 10dp, 上下边距为 20dp。</li>
</ul>
<p>用一个例子来具体理解外边距的含义：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;horizontal&gt;
        &lt;button margin=&quot;30&quot; text=&quot;距离四周30&quot;/&gt;
        &lt;button text=&quot;普通的按钮&quot;/&gt;
    &lt;/horizontal&gt;
);
</code></pre>
<p>第一个按钮的 margin 属性指定了他的边距为 30dp, 也就是他与水平布局以及第二个按钮的间距都是 30dp, 其显示效果如图:</p>
<p><img src="http://doc.autoxjs.com/images/ex1-margin.png" alt="ex1-margin"></p>
<p>如果把<code>margin=&quot;30&quot;</code>改成<code>margin=&quot;10 40&quot;</code>那么第一个按钮的左右间距为 10dp, 上下间距为 40dp, 效果如图:</p>
<p><img src="http://doc.autoxjs.com/images/ex2-margin.png" alt="ex2-margin"></p>
<p>有关 margin 属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="marginLeft"><a href="#marginLeft" class="headerlink" title="marginLeft"></a><a href="http://doc.autoxjs.com/#/ui?id=marginleft">marginLeft</a></h2><p>View 的左外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效，例如<code>margin=&quot;20&quot; marginLeft=&quot;10&quot;</code>的左外边距为 10dp，其他外边距为 20dp。</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;horizontal&gt;
        &lt;button marginLeft=&quot;50&quot; text=&quot;距离左边50&quot;/&gt;
        &lt;button text=&quot;普通的按钮&quot;/&gt;
    &lt;/horizontal&gt;
);
</code></pre>
<p>第一个按钮指定了左外边距为 50dp，则他和他的父布局水平布局(horizontal)的左边的间距为 50dp, 效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex-marginLeft.png" alt="ex-marginLeft"></p>
<h2 id="marginRight"><a href="#marginRight" class="headerlink" title="marginRight"></a><a href="http://doc.autoxjs.com/#/ui?id=marginright">marginRight</a></h2><p>View 的右外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="marginTop"><a href="#marginTop" class="headerlink" title="marginTop"></a><a href="http://doc.autoxjs.com/#/ui?id=margintop">marginTop</a></h2><p>View 的上外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="marginBottom"><a href="#marginBottom" class="headerlink" title="marginBottom"></a><a href="http://doc.autoxjs.com/#/ui?id=marginbottom">marginBottom</a></h2><p>View 的下外边距。如果该属性和 margin 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="padding"><a href="#padding" class="headerlink" title="padding"></a><a href="http://doc.autoxjs.com/#/ui?id=padding">padding</a></h2><p>View 和他的自身内容的间距，也就是内边距。注意和 margin 属性区分开来，margin 属性是 View 之间的间距，而 padding 是 View 和他自身内容的间距。举个例子，一个文本控件的 padding 也即文本控件的边缘和他的文本内容的间距，paddingLeft 即文本控件的左边和他的文本内容的间距。</p>
<p>paddding 属性的值同样有三种格式：</p>
<ul>
<li><code>padding=&quot;paddingAll&quot;</code> 指定各个内边距都是该值。例如<code>padding=&quot;10&quot;</code>表示左右上下内边距都是 10dp。</li>
<li><code>padding=&quot;paddingLeft paddingTop paddingRight paddingBottom&quot;</code> 分别指定各个内边距。例如<code>padding=&quot;10 20 30 40&quot;</code>表示左内边距为 10dp, 上内边距为 20dp, 右内边距为 30dp, 下内边距为 40dp</li>
<li><code>padding=&quot;paddingHorizontal paddingVertical&quot;</code> 指定水平内边距和垂直内边距。例如<code>padding=&quot;10 20&quot;</code>表示左右内边距为 10dp, 上下内边距为 20dp。</li>
</ul>
<p>用一个例子来具体理解内边距的含义：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame w=&quot;*&quot; h=&quot;*&quot; gravity=&quot;center&quot;&gt;
        &lt;text padding=&quot;10 20 30 40&quot; bg=&quot;#ff0000&quot; w=&quot;auto&quot; h=&quot;auto&quot; text=&quot;HelloWorld&quot;/&gt;
    &lt;/frame&gt;
);
</code></pre>
<p>这个例子是一个居中的按钮(通过父布局的<code>gravity=&quot;center&quot;</code>属性设置)，背景色为红色(<code>bg=&quot;#ff0000&quot;</code>)，文本内容为”HelloWorld”，左边距为 10dp，上边距为 20dp，下边距为 30dp，右边距为 40dp，其显示效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex-padding.png" alt="ex-padding"></p>
<h2 id="paddingLeft"><a href="#paddingLeft" class="headerlink" title="paddingLeft"></a><a href="http://doc.autoxjs.com/#/ui?id=paddingleft">paddingLeft</a></h2><p>View 的左内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="paddingRight"><a href="#paddingRight" class="headerlink" title="paddingRight"></a><a href="http://doc.autoxjs.com/#/ui?id=paddingright">paddingRight</a></h2><p>View 的右内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="paddingTop"><a href="#paddingTop" class="headerlink" title="paddingTop"></a><a href="http://doc.autoxjs.com/#/ui?id=paddingtop">paddingTop</a></h2><p>View 的上内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="paddingBottom"><a href="#paddingBottom" class="headerlink" title="paddingBottom"></a><a href="http://doc.autoxjs.com/#/ui?id=paddingbottom">paddingBottom</a></h2><p>View 的下内边距。如果该属性和 padding 属性指定的值冲突，则在后面的属性生效，前面的属性无效。</p>
<h2 id="bg"><a href="#bg" class="headerlink" title="bg"></a><a href="http://doc.autoxjs.com/#/ui?id=bg">bg</a></h2><p>View 的背景。其值可以是一个链接或路径指向的图片，或者 RGB 格式的颜色，或者其他背景。具体参见<a href="http://doc.autoxjs.com/#/ui?id=draw">Drawables</a>。</p>
<p>例如，<code>bg=&quot;#00ff00&quot;</code>设置背景为绿色，<code>bg=&quot;file:///sdcard/1.png&quot;</code>设置背景为图片”1.png”，<code>bg=&quot;?attr/selectableItemBackground&quot;</code>设置背景为点击时出现的波纹效果(可能需要同时设置<code>clickable=&quot;true&quot;</code>才生效)。</p>
<h2 id="alpha"><a href="#alpha" class="headerlink" title="alpha"></a><a href="http://doc.autoxjs.com/#/ui?id=alpha">alpha</a></h2><p>View 的透明度，其值是一个 0~1 之间的小数，0 表示完全透明，1 表示完全不透明。例如<code>alpha=&quot;0.5&quot;</code>表示半透明。</p>
<h2 id="foreground"><a href="#foreground" class="headerlink" title="foreground"></a><a href="http://doc.autoxjs.com/#/ui?id=foreground">foreground</a></h2><p>View 的前景。前景即在一个 View 的内容上显示的内容，可能会覆盖掉 View 本身的内容。其值和属性 bg 的值类似。</p>
<h2 id="minHeight"><a href="#minHeight" class="headerlink" title="minHeight"></a><a href="http://doc.autoxjs.com/#/ui?id=minheight">minHeight</a></h2><p>View 的最小高度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。</p>
<p>例：<code>&lt;text height=&quot;auto&quot; minHeight=&quot;50&quot;/&gt;</code></p>
<p>有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="minWidth"><a href="#minWidth" class="headerlink" title="minWidth"></a><a href="http://doc.autoxjs.com/#/ui?id=minwidth">minWidth</a></h2><p>View 的最小宽度。该值不总是生效的，取决于其父布局是否有足够的空间容纳。</p>
<p>例：<code>&lt;input width=&quot;auto&quot; minWidth=&quot;50&quot;/&gt;</code></p>
<p>有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="visibility"><a href="#visibility" class="headerlink" title="visibility"></a><a href="http://doc.autoxjs.com/#/ui?id=visibility">visibility</a></h2><p>View 的可见性，该属性可以决定 View 是否显示出来。其值可以为：</p>
<ul>
<li><code>gone</code> 不可见。</li>
<li><code>visible</code> 可见。默认情况下 View 都是可见的。</li>
<li><code>invisible</code> 不可见，但仍然占用位置。</li>
</ul>
<h2 id="rotation"><a href="#rotation" class="headerlink" title="rotation"></a><a href="http://doc.autoxjs.com/#/ui?id=rotation">rotation</a></h2><p>View 的旋转角度。通过该属性可以让这个 View 顺时针旋转一定的角度。例如<code>rotation=&quot;90&quot;</code>可以让他顺时针旋转 90 度。</p>
<p>如果要设置旋转中心，可以通过<code>transformPivotX</code>, <code>transformPivotY</code>属性设置。默认的旋转中心为 View 的中心。</p>
<h2 id="transformPivotX"><a href="#transformPivotX" class="headerlink" title="transformPivotX"></a><a href="http://doc.autoxjs.com/#/ui?id=transformpivotx">transformPivotX</a></h2><p>View 的变换中心坐标 x。用于 View 的旋转、放缩等变换的中心坐标。例如<code>transformPivotX=&quot;10&quot;</code>。</p>
<p>该坐标的坐标系以 View 的左上角为原点。也就是 x 值为变换中心到 View 的左边的距离。</p>
<p>有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="transformPivotY"><a href="#transformPivotY" class="headerlink" title="transformPivotY"></a><a href="http://doc.autoxjs.com/#/ui?id=transformpivoty">transformPivotY</a></h2><p>View 的变换中心坐标 y。用于 View 的旋转、放缩等变换的中心坐标。例如<code>transformPivotY=&quot;10&quot;</code>。</p>
<p>该坐标的坐标系以 View 的左上角为原点。也就是 y 值为变换中心到 View 的上边的距离。</p>
<p>有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="style"><a href="#style" class="headerlink" title="style"></a><a href="http://doc.autoxjs.com/#/ui?id=style">style</a></h2><p>设置 View 的样式。不同控件有不同的可选的内置样式。具体参见各个控件的说明。</p>
<p>需要注意的是，style 属性只支持安卓 5.1 及其以上。</p>
<h2 id="文本控件-text"><a href="#文本控件-text" class="headerlink" title="文本控件: text"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%96%87%e6%9c%ac%e6%8e%a7%e4%bb%b6-text">文本控件: text</a></h2><p>文本控件用于显示文本，可以控制文本的字体大小，字体颜色，字体等。</p>
<p>以下介绍该控件的主要属性和方法，如果要查看他的所有属性和方法，请阅读<a href="http://www.zhdoc.net/android/reference/android/widget/TextView.html">TextView</a>。</p>
<h2 id="text"><a href="#text" class="headerlink" title="text"></a><a href="http://doc.autoxjs.com/#/ui?id=text">text</a></h2><p>设置文本的内容。例如<code>text=&quot;一段文本&quot;</code>。</p>
<h2 id="textColor"><a href="#textColor" class="headerlink" title="textColor"></a><a href="http://doc.autoxjs.com/#/ui?id=textcolor">textColor</a></h2><p>设置字体的颜色，可以是 RGB 格式的颜色(例如#ff00ff)，或者颜色名称(例如 red, green 等)，具体参见<a href="http://doc.autoxjs.com/#/ui?id=%e9%a2%9c%e8%89%b2">颜色</a>。</p>
<p>示例, 红色字体：<code>&lt;text text=&quot;红色字体&quot; textColor=&quot;red&quot;/&gt;</code></p>
<h2 id="textSize"><a href="#textSize" class="headerlink" title="textSize"></a><a href="http://doc.autoxjs.com/#/ui?id=textsize">textSize</a></h2><p>设置字体的大小，单位一般是 sp。按照 Material Design 的规范，正文字体大小为 14sp，标题字体大小为 18sp，次标题为 16sp。</p>
<p>示例，超大字体: <code>&lt;text text=&quot;超大字体&quot; textSize=&quot;40sp&quot;/&gt;</code></p>
<h2 id="textStyle"><a href="#textStyle" class="headerlink" title="textStyle"></a><a href="http://doc.autoxjs.com/#/ui?id=textstyle">textStyle</a></h2><p>设置字体的样式，比如斜体、粗体等。可选的值为：</p>
<ul>
<li>bold 加粗字体</li>
<li>italic 斜体</li>
<li>normal 正常字体</li>
</ul>
<p>可以用或(“|”)把他们组合起来，比如粗斜体为”bold|italic”。</p>
<p>例如，粗体：`</p>
<h2 id="lines"><a href="#lines" class="headerlink" title="lines"></a><a href="http://doc.autoxjs.com/#/ui?id=lines">lines</a></h2><p>设置文本控件的行数。即使文本内容没有达到设置的行数，控件也会留出相应的宽度来显示空白行；如果文本内容超出了设置的行数，则超出的部分不会显示。</p>
<p>另外在 xml 中是不能设置多行文本的，要在代码中设置。例如:</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical&gt;
        &lt;text id=&quot;myText&quot; line=&quot;3&quot;&gt;
    &lt;/vertical&gt;
)
//通过\n换行
ui.myText.setText(&quot;第一行\n第二行\n第三行\n第四行&quot;);
</code></pre>
<h2 id="maxLines"><a href="#maxLines" class="headerlink" title="maxLines"></a><a href="http://doc.autoxjs.com/#/ui?id=maxlines">maxLines</a></h2><p>设置文本控件的最大行数。</p>
<h2 id="typeface"><a href="#typeface" class="headerlink" title="typeface"></a><a href="http://doc.autoxjs.com/#/ui?id=typeface">typeface</a></h2><p>设置字体。可选的值为：</p>
<ul>
<li><code>normal</code> 正常字体</li>
<li><code>sans</code> 衬线字体</li>
<li><code>serif</code> 非衬线字体</li>
<li><code>monospace</code> 等宽字体</li>
</ul>
<p>示例，等宽字体: <code>&lt;text text=&quot;等宽字体&quot; typeface=&quot;monospace&quot;/&gt;</code></p>
<h2 id="ellipsize"><a href="#ellipsize" class="headerlink" title="ellipsize"></a><a href="http://doc.autoxjs.com/#/ui?id=ellipsize">ellipsize</a></h2><p>设置文本的省略号位置。文本的省略号会在文本内容超出文本控件时显示。可选的值为：</p>
<ul>
<li><code>end</code> 在文本末尾显示省略号</li>
<li><code>marquee</code> 跑马灯效果，文本将滚动显示</li>
<li><code>middle</code> 在文本中间显示省略号</li>
<li><code>none</code> 不显示省略号</li>
<li><code>start</code> 在文本开头显示省略号</li>
</ul>
<h2 id="ems"><a href="#ems" class="headerlink" title="ems"></a><a href="http://doc.autoxjs.com/#/ui?id=ems">ems</a></h2><p>当设置该属性后,TextView 显示的字符长度（单位是 em）,超出的部分将不显示，或者根据 ellipsize 属性的设置显示省略号。</p>
<p>例如，限制文本最长为 5em: `</p>
<h2 id="autoLink"><a href="#autoLink" class="headerlink" title="autoLink"></a><a href="http://doc.autoxjs.com/#/ui?id=autolink">autoLink</a></h2><p>控制是否自动找到 url 和电子邮件地址等链接，并转换为可点击的链接。默认值为“none”。</p>
<p>设置该值可以让文本中的链接、电话等变成可点击状态。</p>
<p>可选的值为以下的值以其通过或(“|”)的组合：</p>
<ul>
<li><code>all</code> 匹配所有连接、邮件、地址、电话</li>
<li><code>email</code> 匹配电子邮件地址</li>
<li><code>map</code> 匹配地图地址</li>
<li><code>none</code> 不匹配 (默认)</li>
<li><code>phone</code> 匹配电话号码</li>
<li><code>web</code> 匹配 URL 地址</li>
</ul>
<p>示例：<code>&lt;text autoLink=&quot;web|phone&quot; text=&quot;百度: http://www.baidu.com 电信电话: 10000&quot;/&gt;</code></p>
<h2 id="按钮控件-button"><a href="#按钮控件-button" class="headerlink" title="按钮控件: button"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%8c%89%e9%92%ae%e6%8e%a7%e4%bb%b6-button">按钮控件: button</a></h2><p>按钮控件是一个特殊的文本控件，因此所有文本控件的函数的属性都适用于按钮控件。</p>
<p>除此之外，按钮控件有一些内置的样式，通过<code>style</code>属性设置，包括：</p>
<ul>
<li>Widget.AppCompat.Button.Colored 带颜色的按钮</li>
<li>Widget.AppCompat.Button.Borderless 无边框按钮</li>
<li>Widget.AppCompat.Button.Borderless.Colored 带颜色的无边框按钮</li>
</ul>
<p>这些样式的具体效果参见”示例&#x2F;界面控件&#x2F;按钮控件.js”。</p>
<p>例如：<code>&lt;button style=&quot;Widget.AppCompat.Button.Colored&quot; text=&quot;漂亮的按钮&quot;/&gt;</code></p>
<h2 id="输入框控件-input"><a href="#输入框控件-input" class="headerlink" title="输入框控件: input"></a><a href="http://doc.autoxjs.com/#/ui?id=%e8%be%93%e5%85%a5%e6%a1%86%e6%8e%a7%e4%bb%b6-input">输入框控件: input</a></h2><p>输入框控件也是一个特殊的文本控件，因此所有文本控件的函数的属性和函数都适用于按钮控件。输入框控件有自己的属性和函数，要查看所有这些内容，阅读<a href="http://www.zhdoc.net/android/reference/android/widget/EditText.html">EditText</a>。</p>
<p>对于一个输入框控件，我们可以通过 text 属性设置他的内容，通过 lines 属性指定输入框的行数；在代码中通过<code>getText()</code>函数获取输入的内容。 <code>注意：getText()函数获取输入框的内容时，返回类型是Editable，如果判断是否为空，不能==null，因为不为null，也不能equals（“”），因为类型不一样。如果要获取内容作为字符串，并且使用原生js对字符串的操作函数，需要使用ui.xx.text()的写法来获取内容，如：ui.name.text()</code></p>
<p>例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical padding=&quot;16&quot;&gt;
        &lt;text textSize=&quot;16sp&quot; textColor=&quot;black&quot; text=&quot;请输入姓名&quot;/&gt;
        &lt;input id=&quot;name&quot; text=&quot;小明&quot;/&gt;
        &lt;button id=&quot;ok&quot; text=&quot;确定&quot;/&gt;
    &lt;/vertical&gt;
);
//指定确定按钮点击时要执行的动作
ui.ok.click(function()&#123;
    //通过getText()获取输入的内容
    //var name = ui.name.getText();
    var name = ui.name.text();
    toast(name + &quot;您好!&quot;);
&#125;);
</code></pre>
<p>效果如图：</p>
<p><img src="http://doc.autoxjs.com/images/ex-input.png" alt="ex-input"></p>
<p>除此之外，输入框控件有另外一些主要属性(虽然这些属性对于文本控件也是可用的但一般只用于输入框控件)：</p>
<h2 id="hint"><a href="#hint" class="headerlink" title="hint"></a><a href="http://doc.autoxjs.com/#/ui?id=hint">hint</a></h2><p>输入提示。这个提示会在输入框为空的时候显示出来。如图所示:</p>
<p><img src="http://doc.autoxjs.com/images/ex-hint.png" alt="ex-hint"></p>
<p>上面图片效果的代码为：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical&gt;
        &lt;input hint=&quot;请输入姓名&quot;/&gt;
    &lt;/vertical&gt;
)
</code></pre>
<h2 id="textColorHint"><a href="#textColorHint" class="headerlink" title="textColorHint"></a><a href="http://doc.autoxjs.com/#/ui?id=textcolorhint">textColorHint</a></h2><p>指定输入提示的字体颜色。</p>
<h2 id="textSizeHint"><a href="#textSizeHint" class="headerlink" title="textSizeHint"></a><a href="http://doc.autoxjs.com/#/ui?id=textsizehint">textSizeHint</a></h2><p>指定输入提示的字体大小。</p>
<h2 id="inputType"><a href="#inputType" class="headerlink" title="inputType"></a><a href="http://doc.autoxjs.com/#/ui?id=inputtype">inputType</a></h2><p>指定输入框可以输入的文本类型。可选的值为以下值及其用”|”的组合:</p>
<ul>
<li><code>date</code> 用于输入日期。</li>
<li><code>datetime</code> 用于输入日期和时间。</li>
<li><code>none</code> 没有内容类型。此输入框不可编辑。</li>
<li><code>number</code> 仅可输入数字。</li>
<li><code>numberDecimal</code> 可以与 number 和它的其他选项组合，以允许输入十进制数(包括小数)。</li>
<li><code>numberPassword</code> 仅可输入数字密码。</li>
<li><code>numberSigned</code> 可以与 number 和它的其他选项组合，以允许输入有符号的数。</li>
<li><code>phone</code> 用于输入一个电话号码。</li>
<li><code>text</code> 只是普通文本。</li>
<li><code>textAutoComplete</code> 可以与 text 和它的其他选项结合, 以指定此字段将做自己的自动完成, 并适当地与输入法交互。</li>
<li><code>textAutoCorrect</code> 可以与 text 和它的其他选项结合, 以请求自动文本输入纠错。</li>
<li><code>textCapCharacters</code> 可以与 text 和它的其他选项结合, 以请求大写所有字符。</li>
<li><code>textCapSentences</code> 可以与 text 和它的其他选项结合, 以请求大写每个句子里面的第一个字符。</li>
<li><code>textCapWords</code> 可以与 text 和它的其他选项结合, 以请求大写每个单词里面的第一个字符。</li>
<li><code>textEmailAddress</code> 用于输入一个电子邮件地址。</li>
<li><code>textEmailSubject</code> 用于输入电子邮件的主题。</li>
<li><code>textImeMultiLine</code> 可以与 text 和它的其他选项结合，以指示虽然常规文本视图不应为多行, 但如果可以, 则 IME 应提供多行支持。</li>
<li><code>textLongMessage</code> 用于输入长消息的内容。</li>
<li><code>textMultiLine</code> 可以与 text 和它的其他选项结合, 以便在该字段中允许多行文本。如果未设置此标志, 则文本字段将被限制为单行。</li>
<li><code>textNoSuggestions</code> 可以与 text 及它的其他选项结合, 以指示输入法不应显示任何基于字典的单词建议。</li>
<li><code>textPassword</code> 用于输入密码。</li>
<li><code>textPersonName</code> 用于输入人名。</li>
<li><code>textPhonetic</code> 用于输入拼音发音的文本, 如联系人条目中的拼音名称字段。</li>
<li><code>textPostalAddress</code> 用于输入邮寄地址。</li>
<li><code>textShortMessage</code> 用于输入短的消息内容。</li>
<li><code>textUri</code> 用于输入一个 URI。</li>
<li><code>textVisiblePassword</code> 用于输入可见的密码。</li>
<li><code>textWebEditText</code> 用于输入在 web 表单中的文本。</li>
<li><code>textWebEmailAddress</code> 用于在 web 表单里输入一个电子邮件地址。</li>
<li><code>textWebPassword</code> 用于在 web 表单里输入一个密码。</li>
<li><code>time</code> 用于输入时间。</li>
</ul>
<p>例如，想指定一个输入框的输入类型为小数数字，为: <code>&lt;input inputType=&quot;number|numberDecimal&quot;/&gt;</code></p>
<h2 id="password"><a href="#password" class="headerlink" title="password"></a><a href="http://doc.autoxjs.com/#/ui?id=password">password</a></h2><p>指定输入框输入框是否为密码输入框。默认为<code>false</code>。</p>
<p>例如：<code>&lt;input password=&quot;true&quot;/&gt;</code></p>
<h2 id="numeric"><a href="#numeric" class="headerlink" title="numeric"></a><a href="http://doc.autoxjs.com/#/ui?id=numeric">numeric</a></h2><p>指定输入框输入框是否为数字输入框。默认为<code>false</code>。</p>
<p>例如：<code>&lt;input numeric=&quot;true&quot;/&gt;</code></p>
<h2 id="phoneNumber"><a href="#phoneNumber" class="headerlink" title="phoneNumber"></a><a href="http://doc.autoxjs.com/#/ui?id=phonenumber">phoneNumber</a></h2><p>指定输入框输入框是否为电话号码输入框。默认为<code>false</code>。</p>
<p>例如：<code>&lt;input phoneNumber=&quot;true&quot;/&gt;</code></p>
<h2 id="digits"><a href="#digits" class="headerlink" title="digits"></a><a href="http://doc.autoxjs.com/#/ui?id=digits">digits</a></h2><p>指定输入框可以输入的字符。例如，要指定输入框只能输入”1234567890+-“，为<code>&lt;input digits=&quot;1234567890+-&quot;/&gt;</code>。</p>
<h2 id="singleLine"><a href="#singleLine" class="headerlink" title="singleLine"></a><a href="http://doc.autoxjs.com/#/ui?id=singleline">singleLine</a></h2><p>指定输入框是否为单行输入框。默认为<code>false</code>。您也可以通过<code>lines=&quot;1&quot;</code>来指定单行输入框。</p>
<p>例如：<code>&lt;input singleLine=&quot;true&quot;/&gt;</code></p>
<h2 id="图片控件-img"><a href="#图片控件-img" class="headerlink" title="图片控件: img"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%9b%be%e7%89%87%e6%8e%a7%e4%bb%b6-img">图片控件: img</a></h2><p>图片控件用于显示来自网络、本地或者内嵌数据的图片，并可以指定图片以圆角矩形、圆形等显示。但是不能用于显示 gif 动态图。</p>
<p>这里只介绍他的主要方法和属性，如果要查看他的所有方法和属性，阅读<a href="http://www.zhdoc.net/android/reference/android/widget/ImageView.html">ImageView</a>。</p>
<h2 id="src"><a href="#src" class="headerlink" title="src"></a><a href="http://doc.autoxjs.com/#/ui?id=src">src</a></h2><p>使用一个 Uri 指定图片的来源。可以是图片的地址(http:&#x2F;&#x2F;….)，本地路径(file:&#x2F;&#x2F;….)或者 base64 数据(“data:image&#x2F;png;base64,…”)。</p>
<p>如果使用图片地址或本地路径，Auto.js 会自动使用适当的缓存来储存这些图片，减少下次加载的时间。</p>
<p>例如，显示百度的 logo:</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame&gt;
        &lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;
    &lt;/frame&gt;
);
</code></pre>
<p>再例如，显示文件&#x2F;sdcard&#x2F;1.png 的图片为 <code>&lt;img src=&quot;file:///sdcard/1.png&quot;/&gt;</code>。 再例如，使 base64 显示一张钱包小图片为：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;frame&gt;
        &lt;img w=&quot;40&quot; h=&quot;40&quot; src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA8CAYAAAA6/NlyAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAEu0lEQVRoge3bW4iVVRQH8N+ZnDKxvJUGCSWUlXYle/ChiKAkIiu7UXQjonwNIopM8cHoAhkRGQXdfIiE0Ep8KalQoptRTiFFZiRlOo6TPuSk4zk97G9w5vidc77LPjNi84f1MN+391rrf9a+rL32N4xiFMcUjouo5zyciYPYH0FnBadiNiZiD2oR9JbGRdgiOFPDIXRhCWYU0Dcj6duV6BrQuyWxNaLowBcOO1Uv+7EKc4WINUIlabMq6dNI35eJzRHDWOzS2MEB6cd6XI/OQf07k2frkzat9HQnNkcUG7R2dECq2I53EtmePMvaf+MwcWqKu+RzuqhUcfcwcWqKTvmiXFQ2GDodRhQz0aN9ZHsSG0cVrkGf+GT7MG8YeeTCHeKS7sOdMR1stjcWxY2YH0nXh1gdSdf/E+2I8KVYigkl9ewVUsxNpT1qMzaKN4ejJxrtyEt7IuraE1EX2jOkp+JBnFxSzz68KuTqoyiK2BHuxDO4NpK+j/GoOAWF6BiH98Q/SHyCycPIIxMm4FPZCPTj30SynIFr+A7ThotMK4wXopA1Ym9gSiKv5Oj3bdKnFMpuS514E1fm6NMnbF098s3NS4QS0Ik5+hyBsoSXYkGO9jvxy6C/t+IPIYJZcBWW57AXFfMNrSo2kqqw2l4hvSzcIRTw1sm24FVxb5s4NcR0/JXBuUNYJttI6sDjsi1kvTgrGpsMjq3O4FQNa+SbNhWsyKj7I4wpzSYDbpFtKB/EOSn9ZwpRfx5Xp7yfhN0Z9FdxXxxKjTEe2zI4U8NnKf3PNrT2VcWTKe1eyGjjT+Eapm14IqMjNTyd0n9JSrsDwhmaEN2H8GMOO8viUjyMSfJVJh9O0bGoQdt1eFm2oVwve7UpC1ssX568KEXH6fghp54s8lRkrk7CjpxOrGqg6wQ8IKSKWXPpVtIt8ly+v4ATf2t+yqlgDl5SbCjXy8JIXFXweQEHqngxo43JeEw54l+JVLKaJeypRZzoFxavrIWG6cKPW2SO9+PCMkQHsLiA8fpIv5/DmUn4qaCtpWWIEiLzdUHj9XJA2H5uFRbBZriuoI1NSpatpio+nJtFvFvYd2c1sDsGvxfQ3a/knrwgMtm0qD8rPSprCuq8uRmhVqvanBbvm+EQfsNKIcnvTmnTiUdwQcq73oJ2L2v2stXx6vyCRr8RDuk/C8OMUK24J6VtBaekPG81zxuh0TTJhC7FhtUOHF+n61whGalvu8uRWVJFvgPEYOkqQzhLVSPPXLoYa4Xh3Stcls1NaTdb8Xx7ZxnCvSUIfy/kzWno0Pyzx3dL2C0695Hto7NGUhXy5Lzp3kLZKiqNpNTl2+YShgdIvyXbVck44TB/oKTNzWUIv13S+IDsFmpY84QvZAcwTbh4e04o18SwtbIM4dsiOTFYVgzSv7wN+m9vRqjV/PrA0JuCox1bhYNKQ7Qi3CcU1fpiedRG9AkLXhRfbxCnKlET0s21ifwaSWcPbopBdDDOwGtClTD2vCsq+/C68K8HmVDk7DhFyIsvFzKnGThN+689+oU9dptwQb5B+LB8dx4lMb7xqAhkJwo/xljhFFSfSdUc3mPrcbwj15P+pP0/QiR7hYSkGsHnUYziWMF/mXV4JVcZ8G0AAAAASUVORK5CYII=&quot;/&gt;
    &lt;/frame&gt;
);
</code></pre>
<h2 id="tint"><a href="#tint" class="headerlink" title="tint"></a><a href="http://doc.autoxjs.com/#/ui?id=tint">tint</a></h2><p>图片着色，其值是一个颜色名称或 RGB 颜色值。使用该属性会将图片中的非透明区域都涂上同一颜色。可以用于改变图片的颜色。</p>
<p>例如，对于上面的 base64 的图片: <code>&lt;img w=&quot;40&quot; h=&quot;40&quot; tint=&quot;red&quot; src=&quot;data:image/png;base64,...&quot;/&gt;</code>，则钱包图标颜色会变成红色。</p>
<h2 id="scaleType"><a href="#scaleType" class="headerlink" title="scaleType"></a><a href="http://doc.autoxjs.com/#/ui?id=scaletype">scaleType</a></h2><p>控制图片根据图片控件的宽高放缩时的模式。可选的值为：</p>
<ul>
<li><code>center</code> 在控件中居中显示图像, 但不执行缩放。</li>
<li><code>centerCrop</code> 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 等于或大于控件的相应尺寸 (不包括内边距 padding)并且使图像在控件中居中显示。</li>
<li><code>centerInside</code> 保持图像的长宽比缩放图片, 使图像的尺寸 (宽度和高度) 小于视图的相应尺寸 (不包括内边距 padding)并且图像在控件中居中显示。</li>
<li><code>fitCenter</code> 保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件中居中显示</li>
<li><code>fitEnd</code> 保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件中靠右下角显示</li>
<li><code>fitStart</code> 保持图像的长宽比缩放图片, 使图片的宽<strong>或</strong>高和控件的宽高相同并使图片在控件靠左上角显示</li>
<li><code>fitXY</code> 使图片和宽高和控件的宽高完全匹配，但图片的长宽比可能不能保持一致</li>
<li><code>matrix</code> 绘制时使用图像矩阵进行缩放。需要在代码中使用<code>setImageMatrix(Matrix)</code>函数才能生效。</li>
</ul>
<p>默认的 scaleType 为<code>fitCenter</code>；除此之外最常用的是<code>fitXY</code>， 他能使图片放缩到控件一样的大小，但图片可能会变形。</p>
<h2 id="radius"><a href="#radius" class="headerlink" title="radius"></a><a href="http://doc.autoxjs.com/#/ui?id=radius">radius</a></h2><p>图片控件的半径。如果设置为控件宽高的一半并且控件的宽高相同则图片将剪切为圆形显示；否则图片为圆角矩形显示，半径即为四个圆角的半径，也可以通过<code>radiusTopLeft</code>, <code>radiusTopRight</code>, <code>radiusBottomLeft</code>, <code>radiusBottomRight</code>等属性分别设置四个圆角的半径。</p>
<p>例如，圆角矩形的 Auto.js 图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>
<p>有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="radiusTopLeft"><a href="#radiusTopLeft" class="headerlink" title="radiusTopLeft"></a><a href="http://doc.autoxjs.com/#/ui?id=radiustopleft">radiusTopLeft</a></h2><p>图片控件的左上角圆角的半径。有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="radiusTopRight"><a href="#radiusTopRight" class="headerlink" title="radiusTopRight"></a><a href="http://doc.autoxjs.com/#/ui?id=radiustopright">radiusTopRight</a></h2><p>图片控件的右上角圆角的半径。有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="radiusBottomLeft"><a href="#radiusBottomLeft" class="headerlink" title="radiusBottomLeft"></a><a href="http://doc.autoxjs.com/#/ui?id=radiusbottomleft">radiusBottomLeft</a></h2><p>图片控件的左下角圆角的半径。有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="radiusBottomRight"><a href="#radiusBottomRight" class="headerlink" title="radiusBottomRight"></a><a href="http://doc.autoxjs.com/#/ui?id=radiusbottomright">radiusBottomRight</a></h2><p>图片控件的右下角圆角的半径。有关该属性的单位，参见<a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a>。</p>
<h2 id="borderWidth"><a href="#borderWidth" class="headerlink" title="borderWidth"></a><a href="http://doc.autoxjs.com/#/ui?id=borderwidth">borderWidth</a></h2><p>图片控件的边框宽度。用于在图片外面显示一个边框，边框会随着图片控件的外形(圆角等)改变而相应变化。 例如, 圆角矩形带灰色边框的 Auto.js 图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; radius=&quot;20&quot; borderWidth=&quot;5&quot; borderColor=&quot;gray&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>
<h2 id="borderColor"><a href="#borderColor" class="headerlink" title="borderColor"></a><a href="http://doc.autoxjs.com/#/ui?id=bordercolor">borderColor</a></h2><p>图片控件的边框颜色。</p>
<h2 id="circle"><a href="#circle" class="headerlink" title="circle"></a><a href="http://doc.autoxjs.com/#/ui?id=circle">circle</a></h2><p>指定该图片控件的图片是否剪切为圆形显示。如果为<code>true</code>，则图片控件会使其宽高保持一致(如果宽高不一致，则保持高度等于宽度)并使圆形的半径为宽度的一半。</p>
<p>例如，圆形的 Auto.js 图标：<code>&lt;img w=&quot;100&quot; h=&quot;100&quot; circle=&quot;true&quot; bg=&quot;white&quot; src=&quot;http://www.autojs.org/assets/uploads/profile/3-profileavatar.png&quot; /&gt;</code></p>
<h2 id="垂直布局-vertical"><a href="#垂直布局-vertical" class="headerlink" title="垂直布局: vertical"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%9e%82%e7%9b%b4%e5%b8%83%e5%b1%80-vertical">垂直布局: vertical</a></h2><p>垂直布局是一种比较简单的布局，会把在它里面的控件按照垂直方向依次摆放，如下图所示：</p>
<p>垂直布局:</p>
<p>—————</p>
<p>| 控件 1 |</p>
<p>| 控件 2 |</p>
<p>| 控件 3 |</p>
<p>| ………… |</p>
<p>——————</p>
<h2 id="layout-weight"><a href="#layout-weight" class="headerlink" title="layout_weight"></a><a href="http://doc.autoxjs.com/#/ui?id=layout_weight">layout_weight</a></h2><p>垂直布局中的控件可以通过<code>layout_weight</code>属性来控制控件高度占垂直布局高度的比例。如果为一个控件指定<code>layout_weight</code>, 则这个控件的高度&#x3D;垂直布局剩余高度 * layout_weight &#x2F; weightSum；如果不指定 weightSum, 则 weightSum 为所有子控件的 layout_weight 之和。所谓”剩余高度”，指的是垂直布局中减去没有指定 layout_weight 的控件的剩余高度。 例如:</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical h=&quot;100dp&quot;&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个布局中，三个控件的 layout_weight 都是 1，也就是他们的高度都会占垂直布局高度的 1&#x2F;3，都是 33.3dp. 再例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical h=&quot;100dp&quot;&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;
        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个布局中，第一个控件高度为 1&#x2F;4, 第二个控件为 2&#x2F;4, 第三个控件为 1&#x2F;4. 再例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical h=&quot;100dp&quot; weightSum=&quot;5&quot;&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;
        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个布局中，因为指定了 weightSum 为 5, 因此第一个控件高度为 1&#x2F;5, 第二个控件为 2&#x2F;5, 第三个控件为 1&#x2F;5. 再例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical h=&quot;100dp&quot;&gt;
        &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;
        &lt;text layout_weight=&quot;2&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个布局中，第一个控件并没有指定 layout_weight, 而是指定高度为 40dp, 因此不加入比例计算，此时布局剩余高度为 60dp。第二个控件高度为剩余高度的 2&#x2F;3，也就是 40dp，第三个控件高度为剩余高度的 1&#x2F;3，也就是 20dp。</p>
<p>垂直布局的 layout_weight 属性还可以用于控制他的子控件高度占满剩余空间，例如：</p>
<pre><code>&quot;ui&quot;;
ui.layout(
    &lt;vertical h=&quot;100dp&quot;&gt;
        &lt;text h=&quot;40dp&quot; text=&quot;控件1&quot; bg=&quot;#ff0000&quot;/&gt;
        &lt;text h=&quot;40dp&quot; text=&quot;控件2&quot; bg=&quot;#00ff00&quot;/&gt;
        &lt;text layout_weight=&quot;1&quot; text=&quot;控件3&quot; bg=&quot;#0000ff&quot;/&gt;
    &lt;/vertical&gt;
);
</code></pre>
<p>在这个布局中，第三个控件的高度会占满除去控件 1 和控件 2 的剩余空间。</p>
<h2 id="水平布局-horizontal"><a href="#水平布局-horizontal" class="headerlink" title="水平布局: horizontal"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%b0%b4%e5%b9%b3%e5%b8%83%e5%b1%80-horizontal">水平布局: horizontal</a></h2><p>水平布局是一种比较简单的布局，会把在它里面的控件按照水平方向依次摆放，如下图所示： 水平布局: ————————————————————————————</p>
<p>| 控件 1 | 控件 2 | 控件 3 | … |</p>
<p>————————————————————————————</p>
<h2 id="layout-weight-1"><a href="#layout-weight-1" class="headerlink" title="layout_weight"></a><a href="http://doc.autoxjs.com/#/ui?id=layout_weight-1">layout_weight</a></h2><p>水平布局中也可以使用 layout_weight 属性来控制子控件的<strong>宽度</strong>占父布局的比例。和垂直布局中类似，不再赘述。</p>
<h2 id="线性布局-linear"><a href="#线性布局-linear" class="headerlink" title="线性布局: linear"></a><a href="http://doc.autoxjs.com/#/ui?id=%e7%ba%bf%e6%80%a7%e5%b8%83%e5%b1%80-linear">线性布局: linear</a></h2><p>实际上，垂直布局和水平布局都属于线性布局。线性布局有一个 orientation 的属性，用于指定布局的方向，可选的值为<code>vertical</code>和<code>horizontal</code>。</p>
<p>例如<code>&lt;linear orientation=&quot;vertical&quot;&gt;&lt;/linear&gt;</code>相当于<code>&lt;vertical&gt;&lt;/vertical&gt;</code>。</p>
<p>线性布局的默认方向是横向的，因此，一个没有指定 orientation 属性的线性布局就是横向布局。</p>
<h2 id="帧布局-frame"><a href="#帧布局-frame" class="headerlink" title="帧布局: frame"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%b8%a7%e5%b8%83%e5%b1%80-frame">帧布局: frame</a></h2><p>帧布局</p>
<h2 id="相对布局-relative"><a href="#相对布局-relative" class="headerlink" title="相对布局: relative"></a><a href="http://doc.autoxjs.com/#/ui?id=%e7%9b%b8%e5%af%b9%e5%b8%83%e5%b1%80-relative">相对布局: relative</a></h2><h2 id="勾选框控件-checkbox"><a href="#勾选框控件-checkbox" class="headerlink" title="勾选框控件: checkbox"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%8b%be%e9%80%89%e6%a1%86%e6%8e%a7%e4%bb%b6-checkbox">勾选框控件: checkbox</a></h2><h2 id="选择框控件-radio"><a href="#选择框控件-radio" class="headerlink" title="选择框控件: radio"></a><a href="http://doc.autoxjs.com/#/ui?id=%e9%80%89%e6%8b%a9%e6%a1%86%e6%8e%a7%e4%bb%b6-radio">选择框控件: radio</a></h2><h2 id="选择框布局-radiogroup"><a href="#选择框布局-radiogroup" class="headerlink" title="选择框布局: radiogroup"></a><a href="http://doc.autoxjs.com/#/ui?id=%e9%80%89%e6%8b%a9%e6%a1%86%e5%b8%83%e5%b1%80-radiogroup">选择框布局: radiogroup</a></h2><h2 id="开关控件-switch"><a href="#开关控件-switch" class="headerlink" title="开关控件: switch"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%bc%80%e5%85%b3%e6%8e%a7%e4%bb%b6-switch">开关控件: switch</a></h2><h2 id="进度条控件-progressbar"><a href="#进度条控件-progressbar" class="headerlink" title="进度条控件: progressbar"></a><a href="http://doc.autoxjs.com/#/ui?id=%e8%bf%9b%e5%ba%a6%e6%9d%a1%e6%8e%a7%e4%bb%b6-progressbar">进度条控件: progressbar</a></h2><h2 id="拖动条控件-seekbar"><a href="#拖动条控件-seekbar" class="headerlink" title="拖动条控件: seekbar"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%8b%96%e5%8a%a8%e6%9d%a1%e6%8e%a7%e4%bb%b6-seekbar">拖动条控件: seekbar</a></h2><h2 id="下来菜单控件-spinner"><a href="#下来菜单控件-spinner" class="headerlink" title="下来菜单控件: spinner"></a><a href="http://doc.autoxjs.com/#/ui?id=%e4%b8%8b%e6%9d%a5%e8%8f%9c%e5%8d%95%e6%8e%a7%e4%bb%b6-spinner">下来菜单控件: spinner</a></h2><h2 id="时间选择控件-timepicker"><a href="#时间选择控件-timepicker" class="headerlink" title="时间选择控件: timepicker"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%97%b6%e9%97%b4%e9%80%89%e6%8b%a9%e6%8e%a7%e4%bb%b6-timepicker">时间选择控件: timepicker</a></h2><h2 id="日期选择控件-datepicker"><a href="#日期选择控件-datepicker" class="headerlink" title="日期选择控件: datepicker"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%97%a5%e6%9c%9f%e9%80%89%e6%8b%a9%e6%8e%a7%e4%bb%b6-datepicker">日期选择控件: datepicker</a></h2><h2 id="浮动按钮控件-fab"><a href="#浮动按钮控件-fab" class="headerlink" title="浮动按钮控件: fab"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%b5%ae%e5%8a%a8%e6%8c%89%e9%92%ae%e6%8e%a7%e4%bb%b6-fab">浮动按钮控件: fab</a></h2><h2 id="卡片-card"><a href="#卡片-card" class="headerlink" title="卡片: card"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%8d%a1%e7%89%87-card">卡片: card</a></h2><h2 id="抽屉布局-drawer"><a href="#抽屉布局-drawer" class="headerlink" title="抽屉布局: drawer"></a><a href="http://doc.autoxjs.com/#/ui?id=%e6%8a%bd%e5%b1%89%e5%b8%83%e5%b1%80-drawer">抽屉布局: drawer</a></h2><h2 id="列表-list"><a href="#列表-list" class="headerlink" title="列表: list"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%88%97%e8%a1%a8-list">列表: list</a></h2><h2 id="Tab-tab"><a href="#Tab-tab" class="headerlink" title="Tab: tab"></a><a href="http://doc.autoxjs.com/#/ui?id=tab-tab">Tab: tab</a></h2><h2 id="ui"><a href="#ui" class="headerlink" title="ui"></a><a href="http://doc.autoxjs.com/#/ui?id=ui">ui</a></h2><h2 id="ui-layout-xml"><a href="#ui-layout-xml" class="headerlink" title="ui.layout(xml)"></a><a href="http://doc.autoxjs.com/#/ui?id=uilayoutxml">ui.layout(xml)</a></h2><ul>
<li><code>xml</code> {XML} | {string} 布局XML或者XML字符串</li>
</ul>
<p>将布局XML渲染为视图（View）对象， 并设置为当前视图。</p>
<h2 id="ui-inflate-xml-parent-null-attachToParent-false"><a href="#ui-inflate-xml-parent-null-attachToParent-false" class="headerlink" title="ui.inflate(xml[, parent &#x3D; null, attachToParent &#x3D; false])"></a><a href="http://doc.autoxjs.com/#/ui?id=uiinflatexml-parent-null-attachtoparent-false">ui.inflate(xml[, parent &#x3D; null, attachToParent &#x3D; false])</a></h2><ul>
<li><code>xml</code> {string} | {XML} 布局XML或者XML字符串</li>
<li><code>parent</code> {View} 父视图</li>
<li><code>attachToParent</code> {boolean} 是否渲染的View加到父视图中，默认为false 返回 {View}</li>
</ul>
<p>将布局XML渲染为视图（View）对象。如果该View将作为某个View的子View，我们建议传入parent参数，这样在渲染时依赖于父视图的一些布局属性能够正确应用。</p>
<p>此函数用于动态创建、显示View。</p>
<pre><code>&quot;ui&quot;;

$ui.layout(
    &lt;linear id=&quot;container&quot;&gt;
    &lt;/linear&gt;
);

// 动态创建3个文本控件，并加到container容器中
// 这里仅为实例，实际上并不推荐这种做法，如果要展示列表，
// 使用list组件；动态创建十几个、几十个View会让界面卡顿
for (let i = 0; i &lt; 3; i++) &#123;
    let textView = $ui.inflate(
        &lt;text textColor=&quot;#000000&quot; textSize=&quot;14sp&quot;/&gt;
    , $ui.container);
    textView.attr(&quot;text&quot;, &quot;文本控件&quot; + i);
    $ui.container.addView(textView);
&#125;
</code></pre>
<h2 id="ui-findView-id"><a href="#ui-findView-id" class="headerlink" title="ui.findView(id)"></a><a href="http://doc.autoxjs.com/#/ui?id=uifindviewid">ui.findView(id)</a></h2><ul>
<li><code>id</code> {string} View的ID</li>
<li>返回 {View}</li>
</ul>
<p>在当前视图中根据ID查找相应的视图对象并返回。如果当前未设置视图或找不到此ID的视图时返回<code>null</code>。</p>
<p>一般我们都是通过<code>ui.xxx</code>来获取id为xxx的控件，如果xxx是一个ui已经有的属性，就可以通过<code>ui.findView()</code>来获取这个控件</p>
<h2 id="ui-finish"><a href="#ui-finish" class="headerlink" title="ui.finish()"></a><a href="http://doc.autoxjs.com/#/ui?id=uifinish">ui.finish()</a></h2><p>结束当前活动并销毁界面。</p>
<h2 id="ui-setContentView-view"><a href="#ui-setContentView-view" class="headerlink" title="ui.setContentView(view)"></a><a href="http://doc.autoxjs.com/#/ui?id=uisetcontentviewview">ui.setContentView(view)</a></h2><p>-<code>view</code> {View}</p>
<p>将视图对象设置为当前视图。</p>
<h2 id="ui-run-callback"><a href="#ui-run-callback" class="headerlink" title="ui.run(callback)"></a><a href="http://doc.autoxjs.com/#/ui?id=uiruncallback">ui.run(callback)</a></h2><p>-<code>callback</code> {Function} 回调函数 -返回 {any} callback的执行结果</p>
<p>将<code>callback</code>在UI线程中执行。如果当前已经在UI线程中，则直接执行<code>callback</code>；否则将<code>callback</code>抛到UI线程中执行（加到UI线程的消息循环的末尾），**并等待callback执行结束(阻塞当前线程)**。</p>
<h2 id="ui-post-callback-daley"><a href="#ui-post-callback-daley" class="headerlink" title="ui.post(callback[, daley])"></a><a href="http://doc.autoxjs.com/#/ui?id=uipostcallback-daley">ui.post(callback[, daley])</a></h2><ul>
<li><code>callback</code> {Function} 回调函数</li>
<li><code>delay</code> {number} 延迟，单位毫秒</li>
</ul>
<p>将<code>callback</code>加到UI线程的消息循环中，并延迟<code>delay</code>毫秒后执行（不能准确保证一定在delay毫秒后执行）。</p>
<p>此函数可以用于UI线程中延时执行动作（sleep不能在UI线程中使用），也可以用于子线程中更新UI。</p>
<pre><code>&quot;ui&quot;;

ui.layout(
    &lt;frame&gt;
        &lt;text id=&quot;result&quot;/&gt;
    &lt;/frame&gt;
);

ui.result.attr(&quot;text&quot;, &quot;计算中&quot;);
// 在子线程中计算1+ ... + 10000000
threads.start(&#123;
    let sum = 0;
    for (let i = 0; i &lt; 1000000; i++) &#123;
        sum += i;
    &#125;
    // 由于不能在子线程操作UI，所以要抛到UI线程执行
    ui.post(() =&gt; &#123;
        ui.result.attr(&quot;text&quot;, String(sum));
    &#125;);
&#125;);
</code></pre>
<h2 id="ui-statusBarColor-color"><a href="#ui-statusBarColor-color" class="headerlink" title="ui.statusBarColor(color)"></a><a href="http://doc.autoxjs.com/#/ui?id=uistatusbarcolorcolor">ui.statusBarColor(color)</a></h2><ul>
<li><code>color</code> {string | number} 颜色</li>
</ul>
<p>设置当前界面的状态栏颜色。</p>
<pre><code>&quot;ui&quot;;
ui.statusBarColor(&quot;#000000&quot;);
</code></pre>
<h2 id="尺寸的单位-Dimension"><a href="#尺寸的单位-Dimension" class="headerlink" title="尺寸的单位: Dimension"></a><a href="http://doc.autoxjs.com/#/ui?id=%e5%b0%ba%e5%af%b8%e7%9a%84%e5%8d%95%e4%bd%8d-dimension">尺寸的单位: Dimension</a></h2><h2 id="Drawables"><a href="#Drawables" class="headerlink" title="Drawables"></a><a href="http://doc.autoxjs.com/#/ui?id=drawables">Drawables</a></h2><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a><a href="http://doc.autoxjs.com/#/ui?id=%e9%a2%9c%e8%89%b2">颜色</a></h2><p><strong>(完善中…)</strong></p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>网络请求 HTTP</title>
    <url>//blog/note/code/AutoXjs/HTTP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a><a href="http://doc.autoxjs.com/#/http?id=http">HTTP</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>http模块提供一些进行http请求的函数。</p>
<h2 id="http-get-url-options-callback"><a href="#http-get-url-options-callback" class="headerlink" title="http.get(url[, options, callback])"></a><a href="http://doc.autoxjs.com/#/http?id=httpgeturl-options-callback">http.get(url[, options, callback])</a></h2><ul>
<li><code>url</code> {string} 请求的URL地址，需要以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头。如果url没有以”http:&#x2F;&#x2F;“开头，则默认为”http:&#x2F;&#x2F;“。</li>
<li><code>options</code> {Object} 请求选项。参见[http.request()][]。</li>
<li><code>callback</code> {Function} 回调函数，可选，其参数是一个[Response][]对象。如果不加回调函数，则该请求将阻塞、同步地执行。</li>
</ul>
<p>对地址url进行一次HTTP GET 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。</p>
<p>最简单GET请求如下:</p>
<pre><code>console.show();
var r = http.get(&quot;www.baidu.com&quot;);
log(&quot;code = &quot; + r.statusCode);
log(&quot;html = &quot; + r.body.string());
</code></pre>
<p>采用回调形式的GET请求如下：</p>
<pre><code>console.show();
http.get(&quot;www.baidu.com&quot;, &#123;&#125;, function(res, err)&#123;
    if(err)&#123;
        console.error(err);
        return;
    &#125;
    log(&quot;code = &quot; + res.statusCode);
    log(&quot;html = &quot; + res.body.string());
&#125;);
</code></pre>
<p>如果要增加HTTP头部信息，则在options参数中添加，例如：</p>
<pre><code>console.show();
var r = http.get(&quot;www.baidu.com&quot;, &#123;
    headers: &#123;
        &#39;Accept-Language&#39;: &#39;zh-cn,zh;q=0.5&#39;,
        &#39;User-Agent&#39;: &#39;Mozilla/5.0(Macintosh;IntelMacOSX10_7_0)AppleWebKit/535.11(KHTML,likeGecko)Chrome/17.0.963.56Safari/535.11&#39;
    &#125;
&#125;);
log(&quot;code = &quot; + r.statusCode);
log(&quot;html = &quot; + r.body.string());
</code></pre>
<p>一个请求天气并解析返回的天气JSON结果的例子如下：</p>
<pre><code>var city = &quot;广州&quot;;
var res = http.get(&quot;http://www.sojson.com/open/api/weather/json.shtml?city=&quot; + city);
if(res.statusCode != 200)&#123;
    toast(&quot;请求失败: &quot; + res.statusCode + &quot; &quot; + res.statusMessage);
&#125;else&#123;
    var weather = res.body.json();
    log(weather);
    toast(util.format(&quot;温度: %s 湿度: %s 空气质量: %s&quot;, weather.data.wendu,
        weather.data.shidu, weather.quality));
&#125;
</code></pre>
<h2 id="http-post-url-data-options-callback"><a href="#http-post-url-data-options-callback" class="headerlink" title="http.post(url, data[, options, callback])"></a><a href="http://doc.autoxjs.com/#/http?id=httpposturl-data-options-callback">http.post(url, data[, options, callback])</a></h2><ul>
<li><code>url</code> {string} 请求的URL地址，需要以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头。如果url没有以”http:&#x2F;&#x2F;“开头，则默认为”http:&#x2F;&#x2F;“。</li>
<li><code>data</code> {string} | {Object} POST数据。</li>
<li><code>options</code> {Object} 请求选项。</li>
<li><code>callback</code> {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。</li>
</ul>
<p>对地址url进行一次HTTP POST 请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。</p>
<p>其中POST数据可以是字符串或键值对。具体含义取决于options.contentType的值。默认为”application&#x2F;x-www-form-urlencoded”(表单提交), 这种方式是JQuery的ajax函数的默认方式。</p>
<p>一个模拟表单提交登录淘宝的例子如下:</p>
<pre><code>var url = &quot;https://login.taobao.com/member/login.jhtml&quot;;
var username = &quot;你的用户名&quot;;
var password = &quot;你的密码&quot;;
var res = http.post(url, &#123;
    &quot;TPL_username&quot;: username,
    &quot;TPL_password&quot;: password
&#125;);
var html = res.body.string();
if(html.contains(&quot;页面跳转中&quot;))&#123;
    toast(&quot;登录成功&quot;);
&#125;else&#123;
    toast(&quot;登录失败&quot;);
&#125;
</code></pre>
<h2 id="http-postJson-url-data-options-callback"><a href="#http-postJson-url-data-options-callback" class="headerlink" title="http.postJson(url[, data, options, callback])"></a><a href="http://doc.autoxjs.com/#/http?id=httppostjsonurl-data-options-callback">http.postJson(url[, data, options, callback])</a></h2><ul>
<li><code>url</code> {string} 请求的URL地址，需要以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头。如果url没有以”http:&#x2F;&#x2F;“开头，则默认为”http:&#x2F;&#x2F;“。</li>
<li><code>data</code> {Object} POST数据。</li>
<li><code>options</code> {Object} 请求选项。</li>
<li><code>callback</code> {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。</li>
</ul>
<p>以JSON格式向目标Url发起POST请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。</p>
<p>JSON格式指的是，将会调用<code>JSON.stringify()</code>把data对象转换为JSON字符串，并在HTTP头部信息中把”Content-Type”属性置为”application&#x2F;json”。这种方式是AngularJS的ajax函数的默认方式。</p>
<p>一个调用图灵机器人接口的例子如下：</p>
<pre><code>var url = &quot;http://www.tuling123.com/openapi/api&quot;;
r = http.postJson(url, &#123;
    key: &quot;65458a5df537443b89b31f1c03202a80&quot;,
    info: &quot;你好啊&quot;,
    userid: &quot;1&quot;,
&#125;);
toastLog(r.body.string());
</code></pre>
<h2 id="http-postMultipart-url-files-options-callback"><a href="#http-postMultipart-url-files-options-callback" class="headerlink" title="http.postMultipart(url, files[, options, callback])"></a><a href="http://doc.autoxjs.com/#/http?id=httppostmultiparturl-files-options-callback">http.postMultipart(url, files[, options, callback])</a></h2><ul>
<li><code>url</code> {string} 请求的URL地址，需要以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头。如果url没有以”http:&#x2F;&#x2F;“开头，则默认为”http:&#x2F;&#x2F;“。</li>
<li><code>files</code> {Object} POST数据。</li>
<li><code>options</code> {Object} 请求选项。</li>
<li><code>callback</code> {Function} 回调，其参数是一个<code>Response</code>对象。如果不加回调参数，则该请求将阻塞、同步地执行。</li>
</ul>
<p>向目标地址发起类型为multipart&#x2F;form-data的请求（通常用于文件上传等), 其中files参数是{name1: value1, name2: value2, …}的键值对，value的格式可以是以下几种情况：</p>
<ol>
<li><code>string</code></li>
<li>文件类型，即open()返回的类型</li>
<li>[fileName, filePath]</li>
<li>[fileName, mimeType, filePath]</li>
</ol>
<p>其中1属于非文件参数，2、3、4为文件参数。举个例子，最简单的文件上传的请求为：</p>
<pre><code>var res = http.postMultipart(url, &#123;
    file: open(&quot;/sdcard/1.txt&quot;)
&#125;);
log(res.body.string());
</code></pre>
<p>如果使用格式2，则代码为</p>
<pre><code>var res = http.postMultipart(url, &#123;
    file: [&quot;1.txt&quot;, &quot;/sdcard/1.txt&quot;]
&#125;);
log(res.body.string());
</code></pre>
<p>如果使用格式3，则代码为</p>
<pre><code>var res = http.postMultipart(url, &#123;
    file: [&quot;1.txt&quot;, &quot;text/plain&quot;, &quot;/sdcard/1.txt&quot;]
&#125;);
log(res.body.string());
</code></pre>
<p>如果使用格式2的同时要附带非文件参数”appId&#x3D;abcdefghijk”，则为:</p>
<pre><code>var res = http.postMultipart(url, &#123;
    appId: &quot;adcdefghijk&quot;,
    file: open(&quot;/sdcard/1.txt&quot;)
&#125;);
log(res.body.string());
</code></pre>
<h2 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[, options, callback])"></a><a href="http://doc.autoxjs.com/#/http?id=httprequesturl-options-callback">http.request(url[, options, callback])</a></h2><ul>
<li><code>url</code> {string} 请求的URL地址，需要以”http:&#x2F;&#x2F;“或”https:&#x2F;&#x2F;“开头。如果url没有以”http:&#x2F;&#x2F;“开头，则默认为”http:&#x2F;&#x2F;“。</li>
<li><code>options</code> {Object} 请求选项。参见[http.buildRequest()][]。</li>
<li><code>callback</code> {Function} 回调，其参数是一个[Response][]对象。如果不加回调参数，则该请求将阻塞、同步地执行。</li>
</ul>
<p>对目标地址url发起一次HTTP请求。如果没有回调函数，则在请求完成或失败时返回此次请求的响应(参见[Response][])。</p>
<p>选项options可以包含以下属性：</p>
<ul>
<li><code>headers</code> {Object} 键值对形式的HTTP头部信息。有关HTTP头部信息，参见<a href="http://www.runoob.com/http/http-header-fields.html">菜鸟教程：HTTP响应头信息</a>。</li>
<li><code>method</code> {string} HTTP请求方法。包括”GET”, “POST”, “PUT”, “DELET”, “PATCH”。</li>
<li><code>contentType</code> {string} HTTP头部信息中的”Content-Type”, 表示HTTP请求的内容类型。例如”text&#x2F;plain”, “application&#x2F;json”。更多信息参见<a href="http://www.runoob.com/http/http-content-type.html">菜鸟教程：HTTP contentType</a>。</li>
<li><code>body</code> {string} | {Array} | {Function} HTTP请求的内容。可以是一个字符串，也可以是一个字节数组；或者是一个以<a href="https://github.com/square/okio/blob/master/okio/src/main/java/okio/BufferedSink.java">BufferedSink</a>为参数的函数。</li>
</ul>
<p>该函数是get, post, postJson等函数的基础函数。因此除非是PUT, DELET等请求，或者需要更高定制的HTTP请求，否则直接使用get, post, postJson等函数会更加方便。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a><a href="http://doc.autoxjs.com/#/http?id=response">Response</a></h2><p>HTTP请求的响应。</p>
<h2 id="Response-statusCode"><a href="#Response-statusCode" class="headerlink" title="Response.statusCode"></a><a href="http://doc.autoxjs.com/#/http?id=responsestatuscode">Response.statusCode</a></h2><ul>
<li>{number}</li>
</ul>
<p>当前响应的HTTP状态码。例如200(OK), 404(Not Found)等。</p>
<p>有关HTTP状态码的信息，参见<a href="http://www.runoob.com/http/http-status-codes.html">菜鸟教程：HTTP状态码</a>。</p>
<h2 id="Response-statusMessage"><a href="#Response-statusMessage" class="headerlink" title="Response.statusMessage"></a><a href="http://doc.autoxjs.com/#/http?id=responsestatusmessage">Response.statusMessage</a></h2><ul>
<li>{string}</li>
</ul>
<p>当前响应的HTTP状态信息。例如”OK”, “Bad Request”, “Forbidden”。</p>
<p>有关HTTP状态码的信息，参见<a href="http://www.runoob.com/http/http-status-codes.html">菜鸟教程：HTTP状态码</a>。</p>
<p>例子：</p>
<pre><code>var res = http.get(&quot;www.baidu.com&quot;);
if(res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300)&#123;
    toast(&quot;页面获取成功!&quot;);
&#125;else if(res.statusCode == 404)&#123;
    toast(&quot;页面没找到哦...&quot;);
&#125;else&#123;
    toast(&quot;错误: &quot; + res.statusCode + &quot; &quot; + res.statusMessage);
&#125;
</code></pre>
<ul>
<li>{Object}</li>
</ul>
<p>当前响应的HTTP头部信息。该对象的键是响应头名称，值是各自的响应头值。 所有响应头名称都是小写的(吗)。</p>
<p>有关HTTP头部信息，参见<a href="http://www.runoob.com/http/http-header-fields.html">菜鸟教程：HTTP响应头信息</a>。</p>
<p>例子:</p>
<pre><code>console.show();
var res = http.get(&quot;www.qq.com&quot;);
console.log(&quot;HTTP Headers:&quot;)
for(var headerName in res.headers)&#123;
    console.log(&quot;%s: %s&quot;, headerName, res.headers[headerName]);
&#125;
</code></pre>
<h2 id="Response-body"><a href="#Response-body" class="headerlink" title="Response.body"></a><a href="http://doc.autoxjs.com/#/http?id=responsebody">Response.body</a></h2><ul>
<li>{Object}</li>
</ul>
<p>当前响应的内容。他有以下属性和函数：</p>
<ul>
<li>bytes() {Array} 以字节数组形式返回响应内容</li>
<li>string() {string} 以字符串形式返回响应内容</li>
<li>json() {Object} 把响应内容作为JSON格式的数据并调用JSON.parse，返回解析后的对象</li>
<li>contentType {string} 当前响应的内容类型</li>
</ul>
<h2 id="Response-request"><a href="#Response-request" class="headerlink" title="Response.request"></a><a href="http://doc.autoxjs.com/#/http?id=responserequest">Response.request</a></h2><ul>
<li>{Request} 当前响应所对应的请求。参见[Request][]。</li>
</ul>
<h2 id="Response-url"><a href="#Response-url" class="headerlink" title="Response.url"></a><a href="http://doc.autoxjs.com/#/http?id=responseurl">Response.url</a></h2><ul>
<li>{number} 当前响应所对应的请求URL。</li>
</ul>
<h2 id="Response-method"><a href="#Response-method" class="headerlink" title="Response.method"></a><a href="http://doc.autoxjs.com/#/http?id=responsemethod">Response.method</a></h2><ul>
<li>{string} 当前响应所对应的HTTP请求的方法。例如”GET”, “POST”, “PUT”等。</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>设备 device</title>
    <url>//blog/note/code/AutoXjs/device.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Device"><a href="#Device" class="headerlink" title="Device"></a><a href="http://doc.autoxjs.com/#/device?id=device">Device</a></h1><h2 id="Device-1"><a href="#Device-1" class="headerlink" title="Device"></a><a href="http://doc.autoxjs.com/#/device?id=device">Device</a></h2><blockquote>
<p>稳定性: 稳定</p>
</blockquote>
<p>device模块提供了与设备有关的信息与操作，例如获取设备宽高，内存使用率，IMEI，调整设备亮度、音量等。</p>
<p>此模块的部分函数，例如调整音量，需要”修改系统设置”的权限。如果没有该权限，会抛出<code>SecurityException</code>并跳转到权限设置界面。</p>
<h2 id="device-width"><a href="#device-width" class="headerlink" title="device.width"></a><a href="http://doc.autoxjs.com/#/device?id=devicewidth">device.width</a></h2><ul>
<li>{number}</li>
</ul>
<p>设备屏幕分辨率宽度。例如1080。</p>
<h2 id="device-height"><a href="#device-height" class="headerlink" title="device.height"></a><a href="http://doc.autoxjs.com/#/device?id=deviceheight">device.height</a></h2><ul>
<li>{number}</li>
</ul>
<p>设备屏幕分辨率高度。例如1920。</p>
<h2 id="device-buildId"><a href="#device-buildId" class="headerlink" title="device.buildId"></a><a href="http://doc.autoxjs.com/#/device?id=devicebuildid">device.buildId</a></h2><ul>
<li>{string}</li>
</ul>
<p>Either a changelist number, or a label like “M4-rc20”.</p>
<p>修订版本号，或者诸如”M4-rc20”的标识。</p>
<h2 id="device-broad"><a href="#device-broad" class="headerlink" title="device.broad"></a><a href="http://doc.autoxjs.com/#/device?id=devicebroad">device.broad</a></h2><ul>
<li>{string}</li>
</ul>
<p>The name of the underlying board, like “goldfish”.</p>
<p>设备的主板(?)型号。</p>
<h2 id="device-brand"><a href="#device-brand" class="headerlink" title="device.brand"></a><a href="http://doc.autoxjs.com/#/device?id=devicebrand">device.brand</a></h2><ul>
<li>{string}</li>
</ul>
<p>The consumer-visible brand with which the product&#x2F;hardware will be associated, if any.</p>
<p>与产品或硬件相关的厂商品牌，如”Xiaomi”, “Huawei”等。</p>
<h2 id="device-device"><a href="#device-device" class="headerlink" title="device.device"></a><a href="http://doc.autoxjs.com/#/device?id=devicedevice">device.device</a></h2><ul>
<li>{string}</li>
</ul>
<p>The name of the industrial design.</p>
<p>设备在工业设计中的名称。</p>
<h2 id="device-model"><a href="#device-model" class="headerlink" title="device.model"></a><a href="http://doc.autoxjs.com/#/device?id=devicemodel">device.model</a></h2><ul>
<li>{string}</li>
</ul>
<p>The end-user-visible name for the end product.</p>
<p>设备型号。</p>
<h2 id="device-product"><a href="#device-product" class="headerlink" title="device.product"></a><a href="http://doc.autoxjs.com/#/device?id=deviceproduct">device.product</a></h2><ul>
<li>{string}</li>
</ul>
<p>The name of the overall product.</p>
<p>整个产品的名称。</p>
<h2 id="device-bootloader"><a href="#device-bootloader" class="headerlink" title="device.bootloader"></a><a href="http://doc.autoxjs.com/#/device?id=devicebootloader">device.bootloader</a></h2><ul>
<li>{string}</li>
</ul>
<p>The system bootloader version number.</p>
<p>设备Bootloader的版本。</p>
<h2 id="device-hardware"><a href="#device-hardware" class="headerlink" title="device.hardware"></a><a href="http://doc.autoxjs.com/#/device?id=devicehardware">device.hardware</a></h2><ul>
<li>{string}</li>
</ul>
<p>The name of the hardware (from the kernel command line or &#x2F;proc).</p>
<p>设备的硬件名称(来自内核命令行或者&#x2F;proc)。</p>
<h2 id="device-fingerprint"><a href="#device-fingerprint" class="headerlink" title="device.fingerprint"></a><a href="http://doc.autoxjs.com/#/device?id=devicefingerprint">device.fingerprint</a></h2><ul>
<li>{string}</li>
</ul>
<p>A string that uniquely identifies this build. Do not attempt to parse this value.</p>
<p>构建(build)的唯一标识码。</p>
<h2 id="device-serial"><a href="#device-serial" class="headerlink" title="device.serial"></a><a href="http://doc.autoxjs.com/#/device?id=deviceserial">device.serial</a></h2><ul>
<li>{string}</li>
</ul>
<p>A hardware serial number, if available. Alphanumeric only, case-insensitive.</p>
<p>硬件序列号。</p>
<h2 id="device-sdkInt"><a href="#device-sdkInt" class="headerlink" title="device.sdkInt"></a><a href="http://doc.autoxjs.com/#/device?id=devicesdkint">device.sdkInt</a></h2><ul>
<li>{number}</li>
</ul>
<p>The user-visible SDK version of the framework; its possible values are defined in Build.VERSION_CODES.</p>
<p>安卓系统API版本。例如安卓4.4的sdkInt为19。</p>
<h2 id="device-incremental"><a href="#device-incremental" class="headerlink" title="device.incremental"></a><a href="http://doc.autoxjs.com/#/device?id=deviceincremental">device.incremental</a></h2><ul>
<li>{string}</li>
</ul>
<p>The internal value used by the underlying source control to represent this build. E.g., a perforce changelist number or a git hash.</p>
<h2 id="device-release"><a href="#device-release" class="headerlink" title="device.release"></a><a href="http://doc.autoxjs.com/#/device?id=devicerelease">device.release</a></h2><ul>
<li>{string}</li>
</ul>
<p>The user-visible version string. E.g., “1.0” or “3.4b5”.</p>
<p>Android系统版本号。例如”5.0”, “7.1.1”。</p>
<h2 id="device-baseOS"><a href="#device-baseOS" class="headerlink" title="device.baseOS"></a><a href="http://doc.autoxjs.com/#/device?id=devicebaseos">device.baseOS</a></h2><ul>
<li>{string}</li>
</ul>
<p>The base OS build the product is based on.</p>
<h2 id="device-securityPatch"><a href="#device-securityPatch" class="headerlink" title="device.securityPatch"></a><a href="http://doc.autoxjs.com/#/device?id=devicesecuritypatch">device.securityPatch</a></h2><ul>
<li>{string}</li>
</ul>
<p>The user-visible security patch level.</p>
<p>安全补丁程序级别。</p>
<h2 id="device-codename"><a href="#device-codename" class="headerlink" title="device.codename"></a><a href="http://doc.autoxjs.com/#/device?id=devicecodename">device.codename</a></h2><ul>
<li>{string}</li>
</ul>
<p>The current development codename, or the string “REL” if this is a release build.</p>
<p>开发代号，例如发行版是”REL”。</p>
<h2 id="device-getIMEI"><a href="#device-getIMEI" class="headerlink" title="device.getIMEI()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetimei">device.getIMEI()</a></h2><ul>
<li>{string}</li>
</ul>
<p>返回设备的IMEI.</p>
<h2 id="device-getAndroidId"><a href="#device-getAndroidId" class="headerlink" title="device.getAndroidId()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetandroidid">device.getAndroidId()</a></h2><ul>
<li>{string}</li>
</ul>
<p>返回设备的Android ID。</p>
<p>Android ID为一个用16进制字符串表示的64位整数，在设备第一次使用时随机生成，之后不会更改，除非恢复出厂设置。</p>
<h2 id="device-getMacAddress"><a href="#device-getMacAddress" class="headerlink" title="device.getMacAddress()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetmacaddress">device.getMacAddress()</a></h2><ul>
<li>{string}</li>
</ul>
<p>返回设备的Mac地址。该函数需要在有WLAN连接的情况下才能获取，否则会返回null。</p>
<p><strong>可能的后续修改</strong>：未来可能增加有root权限的情况下通过root权限获取，从而在没有WLAN连接的情况下也能返回正确的Mac地址，因此请勿使用此函数判断WLAN连接。</p>
<h2 id="device-getBrightness"><a href="#device-getBrightness" class="headerlink" title="device.getBrightness()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetbrightness">device.getBrightness()</a></h2><ul>
<li>{number}</li>
</ul>
<p>返回当前的(手动)亮度。范围为0~255。</p>
<h2 id="device-getBrightnessMode"><a href="#device-getBrightnessMode" class="headerlink" title="device.getBrightnessMode()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetbrightnessmode">device.getBrightnessMode()</a></h2><ul>
<li>{number}</li>
</ul>
<p>返回当前亮度模式，0为手动亮度，1为自动亮度。</p>
<h2 id="device-setBrightness-b"><a href="#device-setBrightness-b" class="headerlink" title="device.setBrightness(b)"></a><a href="http://doc.autoxjs.com/#/device?id=devicesetbrightnessb">device.setBrightness(b)</a></h2><ul>
<li><code>b</code> {number} 亮度，范围0~255</li>
</ul>
<p>设置当前手动亮度。如果当前是自动亮度模式，该函数不会影响屏幕的亮度。</p>
<p>此函数需要”修改系统设置”的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。</p>
<h2 id="device-setBrightnessMode-mode"><a href="#device-setBrightnessMode-mode" class="headerlink" title="device.setBrightnessMode(mode)"></a><a href="http://doc.autoxjs.com/#/device?id=devicesetbrightnessmodemode">device.setBrightnessMode(mode)</a></h2><ul>
<li><code>mode</code> {number} 亮度模式，0为手动亮度，1为自动亮度</li>
</ul>
<p>设置当前亮度模式。</p>
<p>此函数需要”修改系统设置”的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。</p>
<h2 id="device-getMusicVolume"><a href="#device-getMusicVolume" class="headerlink" title="device.getMusicVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetmusicvolume">device.getMusicVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回当前媒体音量。</p>
<h2 id="device-getNotificationVolume"><a href="#device-getNotificationVolume" class="headerlink" title="device.getNotificationVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetnotificationvolume">device.getNotificationVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回当前通知音量。</p>
<h2 id="device-getAlarmVolume"><a href="#device-getAlarmVolume" class="headerlink" title="device.getAlarmVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetalarmvolume">device.getAlarmVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回当前闹钟音量。</p>
<h2 id="device-getMusicMaxVolume"><a href="#device-getMusicMaxVolume" class="headerlink" title="device.getMusicMaxVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetmusicmaxvolume">device.getMusicMaxVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回媒体音量的最大值。</p>
<h2 id="device-getNotificationMaxVolume"><a href="#device-getNotificationMaxVolume" class="headerlink" title="device.getNotificationMaxVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetnotificationmaxvolume">device.getNotificationMaxVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回通知音量的最大值。</p>
<h2 id="device-getAlarmMaxVolume"><a href="#device-getAlarmMaxVolume" class="headerlink" title="device.getAlarmMaxVolume()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetalarmmaxvolume">device.getAlarmMaxVolume()</a></h2><ul>
<li>{number} 整数值</li>
</ul>
<p>返回闹钟音量的最大值。</p>
<h2 id="device-setMusicVolume-volume"><a href="#device-setMusicVolume-volume" class="headerlink" title="device.setMusicVolume(volume)"></a><a href="http://doc.autoxjs.com/#/device?id=devicesetmusicvolumevolume">device.setMusicVolume(volume)</a></h2><ul>
<li><code>volume</code> {number} 音量</li>
</ul>
<p>设置当前媒体音量。</p>
<p>此函数需要”修改系统设置”的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。</p>
<h2 id="device-setNotificationVolume-volume"><a href="#device-setNotificationVolume-volume" class="headerlink" title="device.setNotificationVolume(volume)"></a><a href="http://doc.autoxjs.com/#/device?id=devicesetnotificationvolumevolume">device.setNotificationVolume(volume)</a></h2><ul>
<li><code>volume</code> {number} 音量</li>
</ul>
<p>设置当前通知音量。</p>
<p>此函数需要”修改系统设置”的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。</p>
<h2 id="device-setAlarmVolume-volume"><a href="#device-setAlarmVolume-volume" class="headerlink" title="device.setAlarmVolume(volume)"></a><a href="http://doc.autoxjs.com/#/device?id=devicesetalarmvolumevolume">device.setAlarmVolume(volume)</a></h2><ul>
<li><code>volume</code> {number} 音量</li>
</ul>
<p>设置当前闹钟音量。</p>
<p>此函数需要”修改系统设置”的权限。如果没有该权限，会抛出SecurityException并跳转到权限设置界面。</p>
<h2 id="device-getBattery"><a href="#device-getBattery" class="headerlink" title="device.getBattery()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetbattery">device.getBattery()</a></h2><ul>
<li>{number} 0.0~100.0的浮点数</li>
</ul>
<p>返回当前电量百分比。</p>
<h2 id="device-isCharging"><a href="#device-isCharging" class="headerlink" title="device.isCharging()"></a><a href="http://doc.autoxjs.com/#/device?id=deviceischarging">device.isCharging()</a></h2><ul>
<li>{boolean}</li>
</ul>
<p>返回设备是否正在充电。</p>
<h2 id="device-getTotalMem"><a href="#device-getTotalMem" class="headerlink" title="device.getTotalMem()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegettotalmem">device.getTotalMem()</a></h2><ul>
<li>{number}</li>
</ul>
<p>返回设备内存总量，单位字节(B)。1MB &#x3D; 1024 * 1024B。</p>
<h2 id="device-getAvailMem"><a href="#device-getAvailMem" class="headerlink" title="device.getAvailMem()"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetavailmem">device.getAvailMem()</a></h2><ul>
<li>{number}</li>
</ul>
<p>返回设备当前可用的内存，单位字节(B)。</p>
<h2 id="device-isScreenOn"><a href="#device-isScreenOn" class="headerlink" title="device.isScreenOn()"></a><a href="http://doc.autoxjs.com/#/device?id=deviceisscreenon">device.isScreenOn()</a></h2><ul>
<li>返回 {boolean}</li>
</ul>
<p>返回设备屏幕是否是亮着的。如果屏幕亮着，返回<code>true</code>; 否则返回<code>false</code>。</p>
<p>需要注意的是，类似于vivo xplay系列的息屏时钟不属于”屏幕亮着”的情况，虽然屏幕确实亮着但只能显示时钟而且不可交互，此时<code>isScreenOn()</code>也会返回<code>false</code>。</p>
<h2 id="device-wakeUp"><a href="#device-wakeUp" class="headerlink" title="device.wakeUp()"></a><a href="http://doc.autoxjs.com/#/device?id=devicewakeup">device.wakeUp()</a></h2><p>唤醒设备。包括唤醒设备CPU、屏幕等。可以用来点亮屏幕。</p>
<h2 id="device-wakeUpIfNeeded"><a href="#device-wakeUpIfNeeded" class="headerlink" title="device.wakeUpIfNeeded()"></a><a href="http://doc.autoxjs.com/#/device?id=devicewakeupifneeded">device.wakeUpIfNeeded()</a></h2><p>如果屏幕没有点亮，则唤醒设备。</p>
<h2 id="device-keepScreenOn-timeout"><a href="#device-keepScreenOn-timeout" class="headerlink" title="device.keepScreenOn([timeout])"></a><a href="http://doc.autoxjs.com/#/device?id=devicekeepscreenontimeout">device.keepScreenOn([timeout])</a></h2><ul>
<li><code>timeout</code> {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。</li>
</ul>
<p>保持屏幕常亮。</p>
<p>此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。</p>
<p>在某些设备上，如果不加参数timeout，只能在Auto.js的界面保持屏幕常亮，在其他界面会自动失效，这是因为设备的省电策略造成的。因此，建议使用比较长的时长来代替”一直保持屏幕常亮”的功能，例如<code>device.keepScreenOn(3600 * 1000)</code>。</p>
<p>可以使用<code>device.cancelKeepingAwake()</code>来取消屏幕常亮。</p>
<pre><code>//一直保持屏幕常亮
device.keepScreenOn()
</code></pre>
<h2 id="device-keepScreenDim-timeout"><a href="#device-keepScreenDim-timeout" class="headerlink" title="device.keepScreenDim([timeout])"></a><a href="http://doc.autoxjs.com/#/device?id=devicekeepscreendimtimeout">device.keepScreenDim([timeout])</a></h2><ul>
<li><code>timeout</code> {number} 屏幕保持常亮的时间, 单位毫秒。如果不加此参数，则一直保持屏幕常亮。</li>
</ul>
<p>保持屏幕常亮，但允许屏幕变暗来节省电量。此函数可以用于定时脚本唤醒屏幕操作，不需要用户观看屏幕，可以让屏幕变暗来节省电量。</p>
<p>此函数无法阻止用户使用锁屏键等正常关闭屏幕，只能使得设备在无人操作的情况下保持屏幕常亮；同时，如果此函数调用时屏幕没有点亮，则会唤醒屏幕。</p>
<p>可以使用<code>device.cancelKeepingAwake()</code>来取消屏幕常亮。</p>
<h2 id="device-cancelKeepingAwake"><a href="#device-cancelKeepingAwake" class="headerlink" title="device.cancelKeepingAwake()"></a><a href="http://doc.autoxjs.com/#/device?id=devicecancelkeepingawake">device.cancelKeepingAwake()</a></h2><p>取消设备保持唤醒状态。用于取消<code>device.keepScreenOn()</code>, <code>device.keepScreenDim()</code>等函数设置的屏幕常亮。</p>
<h2 id="device-vibrate-millis"><a href="#device-vibrate-millis" class="headerlink" title="device.vibrate(millis)"></a><a href="http://doc.autoxjs.com/#/device?id=devicevibratemillis">device.vibrate(millis)</a></h2><ul>
<li><code>millis</code> {number} 震动时间，单位毫秒</li>
</ul>
<p>使设备震动一段时间。</p>
<pre><code>//震动两秒
device.vibrate(2000);
</code></pre>
<h2 id="device-cancelVibration"><a href="#device-cancelVibration" class="headerlink" title="device.cancelVibration()"></a><a href="http://doc.autoxjs.com/#/device?id=devicecancelvibration">device.cancelVibration()</a></h2><p><strong>[v4.2.7新增]</strong> 如果设备处于震动状态，则取消震动。</p>
<h2 id="device-checkDeviceHasNavigationBar"><a href="#device-checkDeviceHasNavigationBar" class="headerlink" title="device.checkDeviceHasNavigationBar()"></a><a href="http://doc.autoxjs.com/#/device?id=devicecheckdevicehasnavigationbar">device.checkDeviceHasNavigationBar()</a></h2><p><strong>[v4.2.7新增]</strong></p>
<ul>
<li>{boolean} 返回 true|false 设备是否存储虚拟导航栏</li>
</ul>
<h2 id="device-getVirtualBarHeigh"><a href="#device-getVirtualBarHeigh" class="headerlink" title="device.getVirtualBarHeigh();"></a><a href="http://doc.autoxjs.com/#/device?id=devicegetvirtualbarheigh">device.getVirtualBarHeigh();</a></h2><p><strong>[v4.2.7新增]</strong></p>
<ul>
<li>{number} 返回导航栏的高度 设备虚拟导航栏的高度,可以用设备高度 减去 这个高度，再按一定比例 点击底部附件的坐标</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
        <category>AutoX.js</category>
      </categories>
      <tags>
        <tag>AutoX.js</tag>
      </tags>
  </entry>
  <entry>
    <title>我的hexo博客设置以及next主题个人喜好</title>
    <url>//blog/note/hexo/blog-next-diy.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>next配置文件（theme文件夹—next文件夹—config.yml）——主题配置文件</p>
<p>hexo配置文件（博客根目录文件夹内的—config.yml）——博客配置文件</p>
<h1 id="一、博客配置文件的修改"><a href="#一、博客配置文件的修改" class="headerlink" title="一、博客配置文件的修改"></a>一、博客配置文件的修改</h1><h2 id="1-修改站点语言为中文"><a href="#1-修改站点语言为中文" class="headerlink" title="1.修改站点语言为中文"></a>1.修改站点语言为中文</h2><p>打开配置文件，搜索 language，找到如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">author:</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br></pre></td></tr></table></figure>

<p>在 language 后面输入 <strong>zh-CN。</strong></p>
<h2 id="2、博客文章生成永久链接"><a href="#2、博客文章生成永久链接" class="headerlink" title="2、博客文章生成永久链接"></a>2、博客文章生成永久链接</h2><p>这里有两种方法，一种使用hexo自带的，另一种需要安装插件。</p>
<p>方法一 hexo自带生成永久链接</p>
<p>例如我博客的首页，网址为<a href="https://github.com/aboucide/aboucide.github.io.git">https://github.com/aboucide/aboucide.github.io.git</a></p>
<p>那我的url就设置成这个<a href="https://github.com/aboucide/aboucide.github.io.git">https://github.com/aboucide/aboucide.github.io.git</a></p>
<p>root字段没有，就手动输入<code>root: /</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 博客生成永久地址  URL</span><br><span class="line">url:  https://github.com/aboucide/aboucide.github.io.git   </span><br><span class="line">root: /</span><br><span class="line">permalink: :urldiy	# 预设永久链接格式  </span><br><span class="line">permalink_defaults:      # 默认永久链接</span><br><span class="line">pretty_urls:             # 美化永久链接</span><br><span class="line">  trailing_index: true   </span><br><span class="line">  trailing_html: true    </span><br></pre></td></tr></table></figure>

<p>如果你的博客首页网址是  url：<a href="http://www.mfm.com/blog">http://www.mfm.com/blog</a></p>
<p>则你的  root：&#x2F;blog</p>
<p>后续在每个文章的文件头那里输入字段</p>
<p><code>urldiy: /文件夹名称/分类名称/文章自定义名称.html</code></p>
<p>文件夹名称是 hexo将md文件转换成网页文件后上传到GitHub中的文件夹名称，可以随意取，程序会自动新建该文件夹，然后把html文件放进去。</p>
<p>分类名称 是自己在Category &amp; Tag 中设置的中文对应的名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Category &amp; Tag    </span><br><span class="line">#把分类和标签与地址栏对应的英文在这进行分别设置，否则地址栏现实的是中文，分享出去的网址会是一大串转义字符。</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">  笔记: note</span><br><span class="line">  高中化学: chemistry</span><br><span class="line">  实验视频: experiment-videos</span><br><span class="line">  资源分享: source</span><br><span class="line">  生活记录: liferecord</span><br><span class="line">  随笔: essay</span><br><span class="line">  常见电脑疑难的解决方案: solution</span><br><span class="line">  时事分享: epicwebevent            #记录互联网精彩的事情           </span><br><span class="line">  未分类: uncategorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tag_map:</span><br><span class="line">  视频: video</span><br></pre></td></tr></table></figure>



<p>例如本篇文章的urldiy设置如下</p>
<p><code>urldiy: /blog/note/hexo/diy.html</code></p>
<p>即本文网址：aboucide.github.io&#x2F;blog&#x2F;note&#x2F;hexo&#x2F;diy.html</p>
<p>方法二 安装插件</p>
<p>【我没有使用这种方法，因此在这不做介绍】</p>
<h2 id="3、修改博客默认模板"><a href="#3、修改博客默认模板" class="headerlink" title="3、修改博客默认模板"></a>3、修改博客默认模板</h2><p>hexo博客的默认模板储存在：<code>博客根目录/scaffolds/</code></p>
<p>什么情况下会使用到默认模板？</p>
<p>博客的文章储存在<code>\source\_posts</code>，因此我们写作的方法是</p>
<p>① 写好一份md文档，放进该文件夹中，再进行更新博客即可。</p>
<p>但是这种直接手动新建的md文件不能自带 ”文件头“ （front matter），这样子上传的md文件hexo博客是默认不识别的。必须要手动输入文件头，在md文件的开头输入<code>---</code>回车，再手动输入文章的各个信息才行。但是很明显每次写博客都手动输入文章信息就太麻烦了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">author: ZhongYuan</span><br><span class="line">urlname: &#123;&#123;title&#125;&#125;</span><br><span class="line">categories: 未分类</span><br><span class="line">tags:</span><br><span class="line">- 无标签</span><br><span class="line">description: 这里是显示在主页的文章描述。注意冒号后面有一个英文空格。</span><br></pre></td></tr></table></figure>

<p>②使用官方自带的hexo命令，使用默认模板新建一个md文件。</p>
<p>这样新建的md文件就能自带文件头（front matter）。</p>
<p>使用方法 <code>hexo new 模板名称 文件名称</code><br>例如，我想使用默认模板，新建一个<code>这是我的新博客.md</code>文件，命令如下<br><code>hexo new post 这是我的新博客</code>              其中<code>new</code>可以缩写成<code>n</code><br>等效于 <code>hexo n post 这是我的新博客</code></p>
<p>如果你输入的命令中不包含<code>模板名称</code>，则使用默认模板<code>post</code>。<br>也就是说如果你想使用默认模板新建博客，可以使用如下命令：<br><code>hexo n 这是我的新博客</code></p>
<p>官方自带的默认模板是<code>post</code>,代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>很显然使用hexo命令使用默认模板新建的md文件虽然有文件头，但包含的文件头信息还是太少了。<br>下面是我使用的模板，比自带的模板多包含了”分类“、”描述“。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">author: ZhongYuan</span><br><span class="line">categories: 未分类</span><br><span class="line">tags:</span><br><span class="line">- 无标签</span><br><span class="line">description: 这里是显示在主页的文章描述。注意冒号后面有一个英文空格。</span><br></pre></td></tr></table></figure>

<p>我们可以①修改官方自带的post模板；②也可以自己新建一个模板文件放在<code>/scaffolds/</code>的文件夹内。  我这里采用的是方法②。</p>
<p>例如，我创建了一个名为 <code>blog.md</code>的模板，设置这个md的文件头的代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">author: ZhongYuan</span><br><span class="line">categories: 未分类</span><br><span class="line">tags:</span><br><span class="line">- 无标签</span><br><span class="line">description: 这里是显示在主页的文章描述。注意冒号后面有一个英文空格。</span><br></pre></td></tr></table></figure>

<p>后续如何使用这个模板呢？</p>
<p>在博客的根目录文件夹内，打开cmd，使用<code>hexo new blog 这是我的新文档</code>，就会在<code>\source\_posts</code>新建一个<code>这是我的新文档.md</code>的文件</p>
<h2 id="4、博客页面插入视频"><a href="#4、博客页面插入视频" class="headerlink" title="4、博客页面插入视频"></a>4、博客页面插入视频</h2><p>使用插件hexo-tag-dplayer</p>
<p><a href="https://easyhexo.com/3-Plugins-use-and-config/3-2-hexo-tag-dplayer/">https://easyhexo.com/3-Plugins-use-and-config/3-2-hexo-tag-dplayer/</a></p>
<h2 id="5、博客页面分类"><a href="#5、博客页面分类" class="headerlink" title="5、博客页面分类"></a>5、博客页面分类</h2><p>1、先去next主题配置文件，打开对应的功能。#号相当于注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || fa fa-home</span><br><span class="line">  #about: /about/ || fa fa-user</span><br><span class="line">  tags: /tags/ || fa fa-tags                  #标签</span><br><span class="line">  categories: /categories/ || fa fa-th        #分类</span><br><span class="line">  archives: /archives/     || fa fa-archive       #归档</span><br><span class="line">  #schedule: /schedule/     || fa fa-calendar      #日程表</span><br><span class="line">  sitemap: /sitemap.xml    || fa fa-sitemap      #站点地图</span><br><span class="line"> # commonweal: /404/ || fa fa-heartbeat       #公益404</span><br></pre></td></tr></table></figure>

<p>2、可以自定义分类名称对应的网址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Category &amp; Tag    </span><br><span class="line">#把分类和标签与地址栏对应的英文在这进行分别设置，否则地址栏现实的是中文，分享出去的网址会是一大串转义字符。</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">  笔记: note</span><br><span class="line">  高中化学: chemistry</span><br><span class="line">  实验视频: experiment-videos</span><br><span class="line">  资源分享: source</span><br><span class="line">  生活记录: liferecord</span><br><span class="line">  随笔: essay</span><br><span class="line">  常见电脑疑难的解决方案: solution</span><br><span class="line">  未分类: uncategorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tag_map:</span><br><span class="line">  视频: video</span><br></pre></td></tr></table></figure>

<p>3、每次写的博客如何设置分类名称</p>
<p>多级分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">author: ZhongYuan</span><br><span class="line">categories: </span><br><span class="line">- 博客自定义</span><br><span class="line">- 主题修改</span><br><span class="line">tags:</span><br><span class="line">- DIY</span><br><span class="line">description: 这里是显示在主页的文章描述。注意冒号后面有一个英文空格。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这里创建了<code>博客自定义</code>分类，并且创建了下面的一个子分类<code>主题修改</code>，并且添加了一个子标签<code>DIY</code></p>
<p>一篇文章属于多个分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123;title&#125;&#125;</span><br><span class="line">date: &#123;&#123;date&#125;&#125;</span><br><span class="line">author: ZhongYuan</span><br><span class="line">categories: </span><br><span class="line">- [博客自定义,主题修改]</span><br><span class="line">tags:</span><br><span class="line">- DIY</span><br><span class="line">- blog</span><br><span class="line">description: 这里是显示在主页的文章描述。注意冒号后面有一个英文空格。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这里创建的分类是<code>博客自定义</code>和<code>主题修改</code>，相当于这篇文章属于两个分类，同时这个文章加了两个标签。</p>
<hr>
<h1 id="二、主题配置文件的修改"><a href="#二、主题配置文件的修改" class="headerlink" title="二、主题配置文件的修改"></a>二、主题配置文件的修改</h1><h2 id="1、博客主页显示分类、标签等"><a href="#1、博客主页显示分类、标签等" class="headerlink" title="1、博客主页显示分类、标签等"></a>1、博客主页显示分类、标签等</h2><p>打开主题配置文件，修改menu对应的配置，“#”是注释的标志，删除代码前对应的#号即可激活。</p>
<img src=" https://im.gurl.eu.org/file/682d06efd3f4ff44679cd.png "  style="zoom:50%;" />



<h2 id="2、切换next显示的样式（默认提供4种选择）"><a href="#2、切换next显示的样式（默认提供4种选择）" class="headerlink" title="2、切换next显示的样式（默认提供4种选择）"></a>2、切换next显示的样式（默认提供4种选择）</h2><p>找到Schemes板块，选择喜欢的主题，去掉＃即可激活对应模式。</p>
<p>Dark mode是黑夜模式，把ture改成false就是白天模式。</p>
<img src=" https://im.gurl.eu.org/file/cf84358115ffcba437def.png "  style="zoom:50%;" />



<h2 id="3、隐藏网页底部-powered-By-Hexo-强力驱动"><a href="#3、隐藏网页底部-powered-By-Hexo-强力驱动" class="headerlink" title="3、隐藏网页底部 powered By Hexo &#x2F; 强力驱动"></a>3、隐藏网页底部 powered By Hexo &#x2F; 强力驱动</h2><p>（推荐）方法一：打开next主题配置文件，设置下面字段为false</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Powered by Hexo &amp; NexT</span><br><span class="line">powered: false</span><br></pre></td></tr></table></figure>





<p>方法二：打开 themes&#x2F;next&#x2F;layout&#x2F;_partials&#x2F;footer.swig</p>
<p>像我这样把这段代码的前后分别加上<code>&lt;!--</code>和<code>--&gt;</code>，即可实现去除底部推广。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&#123;%- if theme.footer.powered %&#125;</span><br><span class="line">  &lt;div class=&quot;powered-by&quot;&gt;</span><br><span class="line">    &#123;%- set next_site = &#x27;https://theme-next.js.org&#x27; if theme.scheme === &#x27;Gemini&#x27; else &#x27;https://theme-next.js.org/&#x27; + theme.scheme | lower + &#x27;/&#x27; %&#125;</span><br><span class="line">    &#123;&#123;- __(&#x27;footer.powered&#x27;, next_url(&#x27;https://hexo.io&#x27;, &#x27;Hexo&#x27;) + &#x27; &amp; &#x27; + next_url(next_site, &#x27;NexT.&#x27; + theme.scheme)) &#125;&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;- next_inject(&#x27;footer&#x27;) &#125;&#125;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="3、文章添加阴影"><a href="#3、文章添加阴影" class="headerlink" title="3、文章添加阴影"></a>3、文章添加阴影</h2><p>打开    themes\next\source\css_common\components\post\index.styl</p>
<p>替换成如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.rtl &#123;</span><br><span class="line">  &amp;.post-body &#123;</span><br><span class="line">    p, a, h1, h2, h3, h4, h5, h6, li, ul, ol &#123;</span><br><span class="line">      direction: rtl;</span><br><span class="line">      font-family: UKIJ Ekran;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;.post-title &#123;</span><br><span class="line">    font-family: UKIJ Ekran;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-button &#123;</span><br><span class="line">  margin-top: 40px;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.use-motion &#123;</span><br><span class="line">  if (hexo-config(&#x27;motion.transition.post_block&#x27;)) &#123;</span><br><span class="line">    .post-block&#123;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">      margin-top: 60px;</span><br><span class="line">      margin-bottom: 60px;</span><br><span class="line">      padding: 25px;</span><br><span class="line">      -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, 1);</span><br><span class="line">      -moz-box-shadow: 0 0 5px rgba(202, 203, 204, 1);  </span><br><span class="line">    &#125;</span><br><span class="line">    .pagination, .comments &#123;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hexo-config(&#x27;motion.transition.post_header&#x27;)) &#123;</span><br><span class="line">    .post-header &#123;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hexo-config(&#x27;motion.transition.post_body&#x27;)) &#123;</span><br><span class="line">    .post-body &#123;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (hexo-config(&#x27;motion.transition.coll_header&#x27;)) &#123;</span><br><span class="line">    .collection-header &#123;</span><br><span class="line">      visibility: hidden;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@import &#x27;post-collapse&#x27;;</span><br><span class="line">@import &#x27;post-body&#x27;;</span><br><span class="line">@import &#x27;post-gallery&#x27;;</span><br><span class="line">@import &#x27;post-header&#x27;;</span><br><span class="line">@import &#x27;post-nav&#x27;;</span><br><span class="line">@import &#x27;post-footer&#x27;;</span><br><span class="line">@import &#x27;post-widgets&#x27;;</span><br><span class="line">@import &#x27;post-reward&#x27;;</span><br><span class="line">@import &#x27;post-followme&#x27;;</span><br></pre></td></tr></table></figure>





<p>依次执行hexo cl &amp;&amp; hexo g &amp;&amp; hexo d       ，即可看到效果。</p>
<p>添加阴影前，可以看到这里3篇文章，分割线基本没有，看起来感官不佳。</p>
<img src=" https://im.gurl.eu.org/file/c52e2863f2b224b8bbd0c.png "  style="zoom:25%;" />

<p>这里是修改后的，添加了文章阴影，好看了一些。</p>
<img src=" https://im.gurl.eu.org/file/1ae0518330caae0c2faf6.png "  style="zoom:30%;" />



<h2 id="4、浏览页面显示当前浏览进度"><a href="#4、浏览页面显示当前浏览进度" class="headerlink" title="4、浏览页面显示当前浏览进度"></a>4、浏览页面显示当前浏览进度</h2><p>打开 themes&#x2F;next&#x2F;_config.yml，搜索关键字 <code>scrollpercent</code>，把 false 改为 true。</p>
<p>会看到左下角显示当前页面滚动的百分比。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">back2top:</span><br><span class="line">  enable: true                            #打开返回页面顶部的按钮</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: true                           #是否设置把当前阅读百分比合并到侧边栏，选择false则阅读进度单独显示小的悬浮窗。</span><br><span class="line">  # Scroll percent label in b2t button.   显示当前页面滚动百分比</span><br><span class="line">  scrollpercent: true                     </span><br></pre></td></tr></table></figure>



<p>图下为更新前。</p>
<img src=" https://im.gurl.eu.org/file/0d1b6f5d273481d77bed7.png "  style="zoom:20%;" />

<p>更下为更新后。可以看到左下角多了一个浏览进度百分比。</p>
<img src=" https://im.gurl.eu.org/file/88e563b9d42bce4680f1e.png "  style="zoom:25%;" />



<p>还可以设置页面顶部的浏览进度条</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Reading progress bar     页面顶部显示阅读进度条</span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: left | right</span><br><span class="line">  start_at: left</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  reversed: false</span><br><span class="line">  color: &quot;#37c6c0&quot;</span><br><span class="line">  height: 3px</span><br></pre></td></tr></table></figure>









<h2 id="5、Local-Search本地搜索"><a href="#5、Local-Search本地搜索" class="headerlink" title="5、Local Search本地搜索"></a>5、Local Search本地搜索</h2><p>5.1 安装插件hexo-generator-searchdb,执行以下命令:</p>
<p><code>npm install hexo-generator-searchdb --save</code></p>
<p>5.2 修改博客的配置文件，新增以下内容到任意位置：</p>
<p>search:<br>path: search.xml<br>field: post<br>format: html<br>limit: 10000			#最多显示搜索结果的数量为10000个</p>
<p>5.3 编辑 主题配置文件，启用本地搜索功能：</p>
<p>打开主题的配置文件，把# local search的enable改成true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">enable: true</span><br></pre></td></tr></table></figure>



<p>修改后，如下图多了搜索功能。</p>
<img src=" https://im.gurl.eu.org/file/d5b66cafdc27a65a8153d.png "  style="zoom:30%;" />



<h2 id="6、修改博客的相关图标"><a href="#6、修改博客的相关图标" class="headerlink" title="6、修改博客的相关图标"></a>6、修改博客的相关图标</h2><p>博客的默认图标在对应主题的文件夹内<code>/themes/next/source/images</code></p>
<p>只需要把你想要的图片修改成一模一样的名字并替换原文件即可。</p>
<h2 id="7、打开博客分享按钮"><a href="#7、打开博客分享按钮" class="headerlink" title="7、打开博客分享按钮"></a>7、打开博客分享按钮</h2><p>打开主题配置文件，修改成如下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#打开网站分享的按钮，会显示在文章的底部</span><br><span class="line"># AddToAny Share. See: https://www.addtoany.com</span><br><span class="line">addtoany:</span><br><span class="line">  enable: true</span><br><span class="line">  buttons:</span><br><span class="line">    - facebook</span><br><span class="line">    - twitter</span><br><span class="line">    - telegram</span><br><span class="line">    - wechat</span><br><span class="line">    - qzone</span><br></pre></td></tr></table></figure>



<h2 id="8、文章加密访问"><a href="#8、文章加密访问" class="headerlink" title="8、文章加密访问"></a>8、文章加密访问</h2><p>这里提供两种方法，一种是next自带的加密；另一种需要安装加密插件。</p>
<p>我本人使用的加密是第二种方法。</p>
<p>8.1 next主题自带的加密</p>
<p>8.2 使用加密插件hexo-blog-encrypt</p>
<p>github有使用说明，很简单。</p>
<h2 id="9、文章字数统计，阅读时间推荐"><a href="#9、文章字数统计，阅读时间推荐" class="headerlink" title="9、文章字数统计，阅读时间推荐"></a>9、文章字数统计，阅读时间推荐</h2><p>打开主题配置文件，修改post_wordcount对应如下代码即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_wordcount:</span><br><span class="line"></span><br><span class="line"> item_text: true</span><br><span class="line"></span><br><span class="line"> wordcount: true     # 单篇 字数统计</span><br><span class="line"></span><br><span class="line"> min2read: true      # 单篇 阅读时长</span><br><span class="line"></span><br><span class="line"> totalcount: false    # 网站 字数统计</span><br><span class="line"></span><br><span class="line"> separated_meta: true</span><br></pre></td></tr></table></figure>



<h2 id="10、如何让首页的文章部分显示"><a href="#10、如何让首页的文章部分显示" class="headerlink" title="10、如何让首页的文章部分显示"></a>10、如何让首页的文章部分显示</h2><p>这里提供两种方法。</p>
<p>首先确保主题配置文件中的<code>excerpt_description</code>是true（next主题安装后默认是true）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Use `description` in front-matter to specify post excerpt.</span><br><span class="line">excerpt_description: true</span><br></pre></td></tr></table></figure>



<p>10.1 方法一：写博客的概述</p>
<p>在文章的开头处，添加一个description，这样首页只会显示描述的内容，不会显示正文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 让首页显示部分内容</span><br><span class="line">date: 2020-02-23 22:55:10</span><br><span class="line">description: 这是显示在首页的概述，正文内容均会被隐藏。</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>如果description的后面没有文字，则又会默认全部显示正文内容。</p>
<p>10.2 方法二：文章截断</p>
<p>在需要截断的地方加入以下代码，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>这样主页看到的那篇文章就只显示到这串代码之前的内容。（推荐使用方法二）</p>
<p>10.3 不常用的方法：使用加密插件hexo-blog-encrypt</p>
<p>但是必须得加密码，不加密码，无法实现部分内容显示。</p>
<p>修改前，打开首页，文章就是默认全部展开的，非常不美观。</p>
<img src=" https://im.gurl.eu.org/file/55642fece5998d68bcd99.png "  style="zoom:35%;" />



<h2 id="11-代码块风格设置-并-增加代码块“复制”按钮"><a href="#11-代码块风格设置-并-增加代码块“复制”按钮" class="headerlink" title="11. 代码块风格设置 并 增加代码块“复制”按钮"></a>11. 代码块风格设置 并 增加代码块“复制”按钮</h2><p>打开代码块风格预览网站    <a href="https://theme-next.js.org/highlight/">https://theme-next.js.org/highlight/</a></p>
<p>我选择的Engine是hightlight；Theme是atom-one-light。</p>
<p>在博客站点配置文件进行设置如下代码，选择highlight的enable:设置成 true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下面是设置博客文章中代码块的渲染引擎，</span><br><span class="line"># hightlight和prismjs只能二选一打开enable的true，另一个选择false</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line"></span><br><span class="line">prismjs:</span><br><span class="line">  enable: false</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#x27;&#x27;</span><br></pre></td></tr></table></figure>

<p>在next主题配置文件设置如下代码theme: atom-one-light</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#这里是博客里面的代码块的样式</span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # All available themes: https://theme-next.js.org/highlight/</span><br><span class="line">  theme:</span><br><span class="line">    light: atom-one-light</span><br><span class="line">    dark: atom-one-light</span><br><span class="line">  prism:</span><br><span class="line">    light: prism</span><br><span class="line">    dark: prism-dark</span><br></pre></td></tr></table></figure>



<p>打开代码块复制按钮</p>
<p>在next主题配置文件,打开copy_button的enable设置成true</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Add copy button on codeblock   增加代码块复制按钮</span><br><span class="line">copy_button:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>





<h2 id="12-设置页面加载特效"><a href="#12-设置页面加载特效" class="headerlink" title="12. 设置页面加载特效"></a>12. 设置页面加载特效</h2><p>页面有时加载缓慢，可以设置一个当前页面加载的进度条显示，避免焦虑。</p>
<p>打开next主题的配置文件，找到<code>pace</code>片段，enable的值设置成true，可以自定义color和theme的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Progress bar in the top during page loading.</span><br><span class="line">#这里是设置博客加载的进度条，可以访问下面的网址，查看各个效果的例子。</span><br><span class="line"># For more information: https://github.com/CodeByZach/pace</span><br><span class="line">pace:</span><br><span class="line">  enable: true</span><br><span class="line">  # All available colors:</span><br><span class="line">  # black | blue | green | orange | pink | purple | red | silver | white | yellow</span><br><span class="line">  color: green</span><br><span class="line">  # All available themes:</span><br><span class="line">  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span><br><span class="line">  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span><br><span class="line">  theme: loading-bar</span><br></pre></td></tr></table></figure>



<h2 id="13-修改博客文章侧边栏的圆角和边距"><a href="#13-修改博客文章侧边栏的圆角和边距" class="headerlink" title="13. 修改博客文章侧边栏的圆角和边距"></a>13. 修改博客文章侧边栏的圆角和边距</h2><p><a href="https://cs-cshi.github.io/hexo-blog/Hexo-NexT%20%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/">https://cs-cshi.github.io/hexo-blog/Hexo-NexT%20%E8%AE%BE%E7%BD%AE%E5%9C%86%E8%A7%92/</a></p>
<p>打开     blog_root&#x2F;source&#x2F;_data&#x2F;variables.styl ，</p>
<p>没有这个文件夹就手动新建该文件夹  _data，并新建该文件variables.styl。</p>
<p>打开themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_variables&#x2F;Gemini.styl，把内容复制到上面的文件中。</p>
<p>似乎_date文件夹需要自建，用于自定义？</p>
<p>根据启用的不同主题，选择相应的文件。这里修改的是Gemini.styl。</p>
<p>在文件中修改代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$border-radius-inner     = 0 0 10px 10px;</span><br><span class="line">$border-radius           = 10px;</span><br></pre></td></tr></table></figure>



<p>进入next主题配置文件，并搜索 custom_file_path 字段，将variable行取消注释。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Define custom file paths.  自定义页面风格，取消默认配置</span><br><span class="line"># Create your custom files in site directory `source/_data` and uncomment needed files below.</span><br><span class="line">custom_file_path:</span><br><span class="line">  #head: source/_data/head.njk</span><br><span class="line">  #header: source/_data/header.njk</span><br><span class="line">  #sidebar: source/_data/sidebar.njk</span><br><span class="line">  #postMeta: source/_data/post-meta.njk</span><br><span class="line">  #postBodyStart: source/_data/post-body-start.njk</span><br><span class="line">  #postBodyEnd: source/_data/post-body-end.njk</span><br><span class="line">  #footer: source/_data/footer.njk</span><br><span class="line">  #bodyEnd: source/_data/body-end.njk</span><br><span class="line">  variable: source/_data/variables.styl</span><br><span class="line">  #mixin: source/_data/mixins.styl</span><br><span class="line">  #style: source/_data/styles.styl</span><br></pre></td></tr></table></figure>



<h2 id="14-给博客添加人数访问统计"><a href="#14-给博客添加人数访问统计" class="headerlink" title="14. 给博客添加人数访问统计"></a>14. 给博客添加人数访问统计</h2><p>进入主题配置文件，并搜索 busuanzi_count 字段，设置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: fa fa-user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: fa fa-eye</span><br><span class="line">  post_views: true</span><br><span class="line">  post_views_icon: far fa-eye</span><br></pre></td></tr></table></figure>

<p>为了增加可读性，可以增加如下设置。</p>
<p>进入 Hexo&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_partials 目录，打开 footer.njk 文件。</p>
<p>搜索 busuanzi_value_site_uv字段，修改值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">访客人数共计：&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; 人</span><br></pre></td></tr></table></figure>

<p>搜索 busuanzi_value_site_pv 字段，修改值为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本站浏览总量共计：&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; 次</span><br></pre></td></tr></table></figure>



<h2 id="15-博客文章置顶功能"><a href="#15-博客文章置顶功能" class="headerlink" title="15.博客文章置顶功能"></a>15.博客文章置顶功能</h2><h2 id="16-博客文章摘要显示图片"><a href="#16-博客文章摘要显示图片" class="headerlink" title="16. 博客文章摘要显示图片"></a>16. 博客文章摘要显示图片</h2><hr>
<h1 id="三、可能遇到的问题"><a href="#三、可能遇到的问题" class="headerlink" title="三、可能遇到的问题"></a>三、可能遇到的问题</h1><h2 id="1、修改主题相关的内容后，自动部署不加载css，导致网页只有文字，没有风格了。"><a href="#1、修改主题相关的内容后，自动部署不加载css，导致网页只有文字，没有风格了。" class="headerlink" title="1、修改主题相关的内容后，自动部署不加载css，导致网页只有文字，没有风格了。"></a>1、修改主题相关的内容后，自动部署不加载css，导致网页只有文字，没有风格了。</h2><p>解决办法</p>
<p>打开博客站点配置文件,修改url，并设置root字段的内容</p>
<p>例如我博客的首页，网址为<a href="https://github.com/aboucide/aboucide.github.io.git">https://github.com/aboucide/aboucide.github.io.git</a></p>
<p>那我的url就设置成这个<a href="https://github.com/aboucide/aboucide.github.io.git">https://github.com/aboucide/aboucide.github.io.git</a></p>
<p>root字段没有，就手动输入<code>root: /</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## Set your site url here. </span><br><span class="line">url:  https://github.com/aboucide/aboucide.github.io.git   </span><br><span class="line">root: /</span><br></pre></td></tr></table></figure>



<p>如果你的博客首页网址是  url：<a href="http://www.mfm.com/blog">http://www.mfm.com/blog</a></p>
<p>则你的  root：&#x2F;blog</p>
<p>再次重新部署即可。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Hexo和Github搭建个人博客</title>
    <url>//blog/note/hexo/blog-create.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用Hexo和Github搭建个人博客"><a href="#使用Hexo和Github搭建个人博客" class="headerlink" title="使用Hexo和Github搭建个人博客"></a>使用Hexo和Github搭建个人博客</h1><h1 id="【目录】"><a href="#【目录】" class="headerlink" title="【目录】"></a>【目录】</h1><p>[toc]</p>
<hr>
<h1 id="一、如何实现的？"><a href="#一、如何实现的？" class="headerlink" title="一、如何实现的？"></a>一、如何实现的？</h1><p>使用 GitHub Pages 服务搭建博客的好处有：</p>
<ol>
<li>全是静态文件，访问速度快；</li>
<li>免费方便，不用花钱就可以搭建个人博客，不需要服务器不需要后台；</li>
<li>可以随意绑定自己的域名；</li>
<li>数据绝对安全，基于 GitHub 的版本管理，想恢复到哪个历史版本都行；</li>
<li>博客内容可以轻松打包、转移、发布到其它平台；</li>
<li>自己可以随性所欲的设计，美观大气上档次；</li>
</ol>
<hr>
<h1 id="二、搭建步骤"><a href="#二、搭建步骤" class="headerlink" title="二、搭建步骤"></a>二、搭建步骤</h1><h2 id="2-1-原料准备及配置环境"><a href="#2-1-原料准备及配置环境" class="headerlink" title="2.1 原料准备及配置环境"></a>2.1 原料准备及配置环境</h2><h3 id="1-提前注册好Github账号"><a href="#1-提前注册好Github账号" class="headerlink" title="1.提前注册好Github账号"></a>1.提前注册好Github账号</h3><p>注册账号这个过程不难，需要注意的事项有</p>
<ul>
<li><p>账号的用户名将来会用作网址的构成，因此要注意想清楚。</p>
</li>
<li><p>如果无法访问github或者访问过程中比较卡顿，可以下载这个GitHub加速器：<a href="https://steampp.net/">https://steampp.net/</a></p>
</li>
</ul>
<hr>
<h3 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git"></a>2.安装Git</h3><p>[Git - Downloads (git-scm.com)]          官网：(<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>)</p>
<img src="../../../images/blog-create/git的下载.png" alt="git的下载" title="git的下载" style="zoom:50%;" />

<p>文件大小约几十Mb，下载完成后，双击安装包开始安装，一路点击 <code>Next</code> 即可。<br>安装完毕后可以使用以下命令测试是否安装成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure>

<img src="../../../images/blog-create/git版本验证.png" alt="git的下载" title="git的下载" style="zoom:90%;" />

<p>后续Hexo框架的更新可以使用如下代码</p>
<p><code>git clone https://github.com/git/git</code></p>
<hr>
<h3 id="3-安装node-js"><a href="#3-安装node-js" class="headerlink" title="3.安装node.js"></a>3.安装node.js</h3><p>[Node.js — 在任何地方运行 JavaScript (nodejs.org)]   官网： (<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>)</p>
<p>文件大小约几十Mb，下载完毕后，开始安装，勾选所有组件，并勾选 Add to Path 将其添加到系统环境变量。</p>
<p>安装 Node.js 会包含环境变量以及 npm 的安装，安装后，可以在命令行输入如下命令检测 Node.js 是否安装成功：</p>
<p>第一个命令，这个命令，在 nodejs 安装成功的情况下会显示 nodejs 的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>

<img src="../../../images/blog-create/node -v.png" alt="git的下载" title="git的下载" style="zoom:90%;" />

<p>第二个命令：这个命令，在 nodejs 安装成功的情况下会显示 npm 的版本号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<img src="../../../images/blog-create/npm -v.png" alt="git的下载" title="git的下载" style="zoom:90%;" />





<h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。Hexo 官网：<a href="https://hexo.io/zh-cn/">https://hexo.io/zh-cn/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-2-建立博客"><a href="#2-2-建立博客" class="headerlink" title="2.2 建立博客"></a>2.2 建立博客</h2><h4 id="2-2-1-hexo博客初始化"><a href="#2-2-1-hexo博客初始化" class="headerlink" title="2.2.1 hexo博客初始化"></a>2.2.1 hexo博客初始化</h4><p>下面这个命令会在 “cmd”命令窗口所在的工作目录中， 生成一个名称为 “hexo-blog” 博客文件夹，并自动从下载博客所必须的文件放入其中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init hexo-blog</span><br></pre></td></tr></table></figure>

<p>假设我使用这个默认名称 “hexo-blog”，那么这个“hexo-blog”文件夹就是我们博客的默认文件夹了。</p>
<p>当然上面这行代码等效于：</p>
<p>你手动建立了一个<code>hexo-blog</code>的文件夹，并且在该文件夹内运行cmd，输入hexo init 命令，自动下载hexo框架文件，进行初始化。</p>
<h4 id="2-2-2-在hexo博客文件夹中安装npm"><a href="#2-2-2-在hexo博客文件夹中安装npm" class="headerlink" title="2.2.2 在hexo博客文件夹中安装npm"></a>2.2.2 在hexo博客文件夹中安装npm</h4><p>在博客根文件夹（hexo-blog）中，启动cmd命令行窗口。</p>
<p>运行下面的命令，在hexo文件夹中安装npm。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<p>至此，本地的博客已经搭建完毕，等确认本地博客没有问题后，就可以上传到GitHub上，这样网友们就能访问你的博客了。</p>
<p>下面是博客文件夹中各个文件对应的用途。</p>
<img src="../../../images/blog-create/博客文件用途.png" alt="git的下载" title="git的下载" style="zoom:50%;" />

<hr>
<h2 id="2-3-本地化预览-新建博客文章"><a href="#2-3-本地化预览-新建博客文章" class="headerlink" title="2.3 本地化预览 + 新建博客文章"></a>2.3 本地化预览 + 新建博客文章</h2><p>下面4个命令是 hexo 博客框架常用的命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo cl</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p><code>hexo cl</code>全称是<code>hexo clean</code>    清除缓存文件 db.json 和已生成的静态文件 public。网站显示异常时可以执行这条命令试试。</p>
<p><code>hexo g</code> 全称是<code>hexo generate</code>  作用是把你写的markdown文件转换成html网页文件。</p>
<p><code>hexo s </code>全称是hexo server&#96;   启动本地服务器，用于预览主题。默认地址： <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<p><code>hexo d</code> 是 <code>hexo deploy</code> 的缩写。   把本地的博客部署（上传）到GitHub上面去</p>
<h4 id="2-3-1-本地化预览博客"><a href="#2-3-1-本地化预览博客" class="headerlink" title="2.3.1 本地化预览博客"></a>2.3.1 本地化预览博客</h4><p>由于步骤2.2 建立好了一个本地的博客，因此我们在博客根目录运行cmd，依次运行</p>
<p>hexo cl</p>
<img src="../../../images/blog-create/hexocl.png" alt="git的下载" title="git的下载" style="zoom:90%;" />

<p>hexo g</p>
<img src="../../../images/blog-create/hexog.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>hexo s</p>
<img src="../../../images/blog-create/hexos.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>复制<code>http://localhost:4000</code> 到浏览器，进行预览。</p>
<img src="../../../images/blog-create/博客预览.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:40%;" />

<p>回到cmd窗口，按下 ctrl + c  ，可以终止预览。</p>
<p>至此，可以确认本地化的博客已经建立完毕了。</p>
<h4 id="2-3-2-新建博客文章"><a href="#2-3-2-新建博客文章" class="headerlink" title="2.3.2 新建博客文章"></a>2.3.2 新建博客文章</h4><p>使用<code>hexo n 我的周报</code>，注意它们之间有空格。即可新建一个名称为“我的周报.md”的文件，储存在<code>\hexo-blog\source\_posts</code>。</p>
<p>当然，你也可以手动去<code>\hexo-blog\source\_posts</code>文件夹中新建md文件，效果也是一样滴。</p>
<p>我们先打开这个文件夹，看到里面只有官方自带的一篇hello-world.md文件。</p>
<img src="../../../images/blog-create/文章截图1.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>接下来，我们使用下面的命令，会在这个文件夹中生成一个  搭建博客教程.md   文件</p>
<p><code>hexo n 搭建博客教程</code></p>
<img src="../../../images/blog-create/hexon.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>可以看到确实生成了。</p>
<img src="../../../images/blog-create/文章截图2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>手动新建一个md文件，可以来比较一下使用<code>hexo n</code>建立的md文件和手动新建的md文件  区别。</p>
<img src="../../../images/blog-create/文章截图3.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />











<h2 id="2-4-博客上传到Github"><a href="#2-4-博客上传到Github" class="headerlink" title="2.4 博客上传到Github"></a>2.4 博客上传到Github</h2><h4 id="1-使用你的github账号新建一个仓库"><a href="#1-使用你的github账号新建一个仓库" class="headerlink" title="1. 使用你的github账号新建一个仓库"></a>1. 使用你的github账号新建一个仓库</h4><p>登录github，点击<code>Your repositories</code>，进入仓库页面。</p>
<img src="../../../images/blog-create/搭建仓库1.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:50%;" />

<p>点击<code>New</code>按钮，进入仓库创建页面。</p>
<img src="../../../images/blog-create/搭建仓库2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:50%;" />

<p>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。</p>
<p>例如，图片里的用户名<code>yaorongke</code>，则他建立的博客仓库名称必须为<code>yaorongke.github.io</code></p>
<p>将来，图片中的博客的网址就是：<a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a></p>
<img src="../../../images/blog-create/搭建仓库3.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<h4 id="2-设置SSH——公钥和私钥"><a href="#2-设置SSH——公钥和私钥" class="headerlink" title="2. 设置SSH——公钥和私钥"></a>2. 设置SSH——公钥和私钥</h4><p>这一步是让你的电脑有资格与你的GitHub账号仓库建立联系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C 注册时的邮箱地址</span><br></pre></td></tr></table></figure>

<p>例如，我的github注册邮箱是<code>erkesi@qq.com</code>,因此我输入的就是下面这个命令</p>
<p>ssh-keygen -t rsa -C  <a href="mailto:&#101;&#114;&#107;&#101;&#115;&#x69;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;">&#101;&#114;&#107;&#101;&#115;&#x69;&#64;&#113;&#113;&#46;&#x63;&#111;&#x6d;</a></p>
<p>然后依次输入三次回车即可。</p>
<img src="../../../images/blog-create/生成ssh.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>我在第二个回车之后，那里输入了一个Y，是因为我这台电脑之前就生成过，必须覆盖（overwrite）那个旧文件我就输入了Y。</p>
<p>新手第一次运行的，直接依次按下3次回车即可。</p>
<p>成功后，接着去把ssh口令输入到GitHub。</p>
<p>用记事本打开如图所示刚刚生成的<code>id_rsa.pub</code>文件。     <code>12153</code>是我当前电脑的用户名。</p>
<p>（id_rsa是私钥，不能泄露；id_rsa.pub是公钥，无所谓）</p>
<img src="../../../images/blog-create/找到ssh文件.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>复制这个文件内所有文本</p>
<img src="../../../images/blog-create/rsatxt.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>打开网址   <a href="https://github.com/settings/ssh/new">https://github.com/settings/ssh/new</a></p>
<p><code>Title</code> 为标题，任意填即可 。      把刚刚粘贴的密钥复制进去，点击<code>Add SSH key</code></p>
<img src="../../../images/blog-create/添加ssh.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>使用下面的命令，验证是否成功建立本地和GitHub的联系。</p>
<p><code>ssh -T git@github.com</code></p>
<p>我第一次测试失败了是因为我开了加速器。我关闭之后再试了一次就成功了。</p>
<img src="../../../images/blog-create/测试连接github.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />





<h4 id="3-在本地绑定-Github的用户名和邮箱"><a href="#3-在本地绑定-Github的用户名和邮箱" class="headerlink" title="3.在本地绑定 Github的用户名和邮箱"></a>3.在本地绑定 Github的用户名和邮箱</h4><p>这样你去联系github，他才知道你这台电脑是使用了哪个账号去访问的刚刚那个仓库。</p>
<p>输入以下命令：让本地的私钥绑定你“注册时用户名”。   记得手动修改  lancou  成你的名称。    引号是英文的引号，别弄成了中文。</p>
<p><code>git config --global user.name</code> “lancou” </p>
<p>输入命令：让本地的私钥绑定 “注册时邮箱”   。              记得手动修改  <a href="mailto:&#x65;&#x72;&#x6b;&#101;&#x73;&#x69;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;">&#x65;&#x72;&#x6b;&#101;&#x73;&#x69;&#x40;&#x71;&#113;&#x2e;&#99;&#111;&#x6d;</a>  成你的github邮箱。</p>
<p><code>git config --global user.email &quot;erkesi@qq.com&quot;</code></p>
<p>运行结果如下图，不会给任何提示，没事的。</p>
<img src="../../../images/blog-create/绑定用户名和邮箱.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<h4 id="4-把本地博客上传到github"><a href="#4-把本地博客上传到github" class="headerlink" title="4. 把本地博客上传到github"></a>4. 把本地博客上传到github</h4><h5 id="4-1-修改配置站点配置文件"><a href="#4-1-修改配置站点配置文件" class="headerlink" title="4.1 修改配置站点配置文件"></a>4.1 修改配置站点配置文件</h5><p><code>hexo</code> 有 2 种 <code>_config.yml</code> 文件，</p>
<p>一个是根目录下的全局的 <code>_config.yml</code>。               一般称为博客站点配置文件。</p>
<p>一个是各个主题 <code>theme</code> 文件夹下的 <code>_config.yml</code>。   称为主题配置文件。</p>
<p>打开根目录下博客站点配置文件 <code>_config.yml</code>，配置有关 <code>deploy</code> 的部分：</p>
<img src="../../../images/blog-create/博客站点配置文件的位置.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>打开博客站点配置文件，找到<code>deploy</code>字段</p>
<img src="../../../images/blog-create/找到deploy.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>修改成下面这段代码。       </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lancou/lancou.github.io</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>

<p>相当于是告诉Hexo框架，接下来你要把博客上传（部署）到哪里去。</p>
<p>其中你需要修改的地方是repo这一行，repo: <a href="mailto:&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#116;&#x40;&#x67;&#x69;&#116;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#x6d;</a>:昵称&#x2F;仓库名称</p>
<p>我的GitHub昵称是<code>lancou</code>，创建的仓库名称我设置的是<code>lancou.github.io</code>，所以我的repo这一行代码如下</p>
<p>repo: <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;">&#x67;&#105;&#116;&#64;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#x6d;</a>:lancou&#x2F;lancou.github.io</p>
<p>记得照葫芦画瓢进行修改。</p>
<h5 id="4-2-安装hexo上传（部署）工具"><a href="#4-2-安装hexo上传（部署）工具" class="headerlink" title="4.2 安装hexo上传（部署）工具"></a>4.2 安装hexo上传（部署）工具</h5><p>在博客的根目录下，运行cmd，输入下面的代码即可。     我2秒就安装完毕啦，飞一般地速度。</p>
<p><code>npm install hexo-deployer-git --save </code></p>
<img src="../../../images/blog-create/安装部署工具.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>依次运行下面的代码。</p>
<p>hexo cl</p>
<img src="../../../images/blog-create/hexocl2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>hexo g</p>
<img src="../../../images/blog-create/hexog2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<p>hexo d</p>
<img src="../../../images/blog-create/hexod2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:50%;" />

<p>可以看到我的上传过程中出现了  <code>waring:LF will be replaced by CRLF</code></p>
<p>只需要运行这个命令即可解决   <code>git config --global core.safecrlf false</code></p>
<p>我运行完这个命令后，又重新依次执行了hexo d （上传命令），现在上传就不会出现  waring 警告了。</p>
<img src="../../../images/blog-create/第一次完整上传.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>至此，你已经上传本地的博客到你的GitHub仓库。  </p>
<hr>
<h5 id="4-3-访问你的博客"><a href="#4-3-访问你的博客" class="headerlink" title="4.3 访问你的博客"></a>4.3 访问你的博客</h5><p>我（昵称为lancou）的博客的网址为：lancou.github.io</p>
<p>同理，你的博客网址也应该是        <code>用户名.github.io</code></p>
<p>结果我高高兴兴的打开我的博客,额。。。。。。。</p>
<img src="../../../images/blog-create/第一次上传后显示404.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:50%;" />

<p>下面是官方给的解释。意思是，如果你的网站是第一次发布或者是修改了昵称的话，官方需要花几分钟的时间帮你申请一个证书。</p>
<img src="../../../images/blog-create/404解释.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>几分钟之后，我的博客网页就可以正常访问啦！   <a href="https://lancou.github.io/">https://lancou.github.io/</a></p>
<img src="../../../images/blog-create/myblog.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:50%;" />





<hr>
<h1 id="三、（可选）使用Github提供的Action自动化部署更新博客"><a href="#三、（可选）使用Github提供的Action自动化部署更新博客" class="headerlink" title="三、（可选）使用Github提供的Action自动化部署更新博客"></a>三、（可选）使用Github提供的Action自动化部署更新博客</h1><p><strong>这里使用博客的GitHub账号，新建一个私有仓库，存储网站的必要文件，当这些博客文件被修改时，GitHub自动同步更新博客</strong></p>
<h2 id="1-获取github的token"><a href="#1-获取github的token" class="headerlink" title="1.获取github的token"></a>1.获取github的token</h2><p>为了确保交由<code>Github Action</code>来持续部署时，<code>Github Action</code> 具备足够的权限来进行 <code>hexo deploy</code> 操作,需要先获取 <code>Token</code>。</p>
<p>访问 Github -&gt;头像（右上角）-&gt;  Settings  -&gt;  Developer Settings  -&gt;  Personal access tokens  -&gt;  generate new token</p>
<img src="../../../images/blog-create/创建action的token.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>创建的 Token 名称随意，但必须勾选 repo 项 和 workflows 项。</p>
<img src="../../../images/blog-create/生成token的配置.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />





<p>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</p>
<img src="../../../images/blog-create/token.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />



<h2 id="2-创建存放源码的私有仓库"><a href="#2-创建存放源码的私有仓库" class="headerlink" title="2.创建存放源码的私有仓库"></a>2.创建存放源码的私有仓库</h2><p>我们需要创建一个用来存放 <code>Hexo</code> 博客源码的私有仓库</p>
<img src="../../../images/blog-create/新建仓库.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:40%;" />

<img src="../../../images/blog-create/私有仓库成立.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:40%;" />

<p>这里之所以是私有仓库，是因为在接下来的配置中会用到 <code>Token</code>，如果 <code>Token</code> 被盗用，别人可以肆意操作你的 github 仓库内容，为了避免这一风险，才选择的博客源码闭源。</p>
<img src="../../../images/blog-create/保存私有仓库的SSH地址.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:40%;" />



<h2 id="3-配置-Github-Action"><a href="#3-配置-Github-Action" class="headerlink" title="3.配置 Github Action"></a>3.配置 Github Action</h2><ul>
<li><p>在<code>[博客的文件夹根目录]</code>新建<code>.github</code>文件夹，注意开头是有个小数点<code>.</code>的。（如果这个文件夹已经存在了就跳过这一步）</p>
</li>
<li><p>然后在<code>.github</code> 内新建 <code>workflows</code> 文件夹，再在 <code>workflows</code> 文件夹内新建 <code>autodeploy.yml</code>,在<code>autodeploy.yml</code> 里面输入</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: 自动部署</span><br><span class="line"># 当有改动推送到master分支时，启动Action。</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - main</span><br><span class="line">      #2020年10月后github新建仓库默认分支改为main，注意更改。</span><br><span class="line">  release:</span><br><span class="line">    types:</span><br><span class="line">      - published</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: 检查分支</span><br><span class="line">        uses: actions/checkout@v2</span><br><span class="line">        with:</span><br><span class="line">        #这里也要修改分支对应。</span><br><span class="line">          ref: main</span><br><span class="line"></span><br><span class="line">      - name: 安装 Node</span><br><span class="line">        uses: actions/setup-node@v1</span><br><span class="line">        with:</span><br><span class="line">          #这里修改为你的node版本，大版本一致即可,不修改也没啥事。</span><br><span class="line">          node-version: &quot;20.x&quot;</span><br><span class="line"></span><br><span class="line">      - name: 安装 Hexo</span><br><span class="line">        run: |</span><br><span class="line">          export TZ=&#x27;Asia/Shanghai&#x27;</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">      - name: 缓存 Hexo</span><br><span class="line">        id: cache-npm</span><br><span class="line">        uses: actions/cache@v3</span><br><span class="line">        env:</span><br><span class="line">          cache-name: cache-node-modules</span><br><span class="line">        with:</span><br><span class="line">          path: node_modules</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-build-</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-</span><br><span class="line"></span><br><span class="line">      - name: 安装依赖</span><br><span class="line">        if: $&#123;&#123; steps.cache-npm.outputs.cache-hit != &#x27;true&#x27; &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          npm install --save</span><br><span class="line"></span><br><span class="line">      - name: 生成静态文件</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo generate</span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">      - name: 部署到Github</span><br><span class="line">        uses: JamesIves/github-pages-deploy-action@v4</span><br><span class="line">        with:</span><br><span class="line">          #刚刚得到的Github Token</span><br><span class="line">          token: ghp_qsdfsdjhdhdfgreytedfbffbsdfaefefsfaf</span><br><span class="line">          #下面这行代码是要替换成你自己的仓库名,注意这里要填写博客网站的仓库名称。</span><br><span class="line">          repository-name: lancou/lancou.github.io</span><br><span class="line">          #注意分支名称</span><br><span class="line">          branch: main</span><br><span class="line">          folder: public</span><br><span class="line">          commit-message: &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; Updated By Github Actions&quot;</span><br></pre></td></tr></table></figure>



<h2 id="4-重新设置远程仓库和分支"><a href="#4-重新设置远程仓库和分支" class="headerlink" title="4.重新设置远程仓库和分支"></a>4.重新设置远程仓库和分支</h2><ol>
<li><p>修改<code>.gitignore</code>,输入以下内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/next/.git</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果不是 next 主题，记得替换最后一行内容为你自己当前使用的主题。</p>
<p>（如果使用的是默认的主题，可以不用最后一行，但是默认主题有点丑啊，应该没有人用默认主题吧）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可能遇到的 bug</span><br><span class="line">因为 next 主题文件夹下的.git 文件夹的存在，那么主题文件夹会被识别子项目。从而无法被上传到源码仓库。若是遇到添加屏蔽项，但是还是无法正常上传主题文件夹的情况。请先将本地源码中的 themes 文件夹移动到别的目录下。然后 commit 一次。接着将 themes 文件夹移动回来，再 commit 一次。</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>开始重新设置远程仓库和分支</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin    # 删除原有仓库链接</span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:[GithubUsername]/[SourceRepo].git    #[SourceRepo]为新的存放源码的github私有仓库</span><br><span class="line">例如，我的是  git remote add origin git@github.com:lancou/hexosource.git</span><br><span class="line"></span><br><span class="line">git checkout -b main                           # 切换到main分支，</span><br><span class="line"></span><br><span class="line">#2020年10月后github新建仓库默认分支改为main</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;尝试第一次自动部署&quot;</span><br><span class="line">git push origin main</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>以后只需要使用这三行代码，在博客内容修改后，更新即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;尝试第一次自动部署&quot;</span><br><span class="line">git push origin main</span><br></pre></td></tr></table></figure>

<p>git commit -m “这里的文本用来提示作用，可以随意修改”</p>
<h2 id="5-异地修改博客"><a href="#5-异地修改博客" class="headerlink" title="5. 异地修改博客"></a>5. 异地修改博客</h2><p>这里提供两种修改方法</p>
<h3 id="方法一-不常用设备更新博客"><a href="#方法一-不常用设备更新博客" class="headerlink" title="方法一    不常用设备更新博客"></a>方法一    不常用设备更新博客</h3><p>这个远程设备我不常用，例如手机、别人的电脑、网吧等等，我又想更新我的博客该怎么办呢？</p>
<p>可以直接在网页上登录你的Github账号，在<code>博客私有仓库</code>（也就是我们教程中创建的用于保存博客源码的那个）中，</p>
<p>打开  source&#x2F;_post，我们的博客源文件就在这里面。</p>
<img src="../../../images/blog-create/异地修改.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<img src="../../../images/blog-create/异地修改2.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>切记：在网页中手动更新后，你的本地文件还是旧的，相当于本地版本与远程仓库版本不一样了，</p>
<p>在本地要使用一次  <code>git pull origin main</code>，把远程更改的文件同步到本地之后，本地才能继续把本地新修改的推送到远程。</p>
<p>参考文档：<a href="https://blog.csdn.net/yingmohuanzhou/article/details/138455235">https://blog.csdn.net/yingmohuanzhou/article/details/138455235</a></p>
<p><code>下班最后一件事push代码，上班第一件事pull代码</code></p>
<p>假设你在朋友的电脑上登录你的GitHub账号，使用这种方法修改完成之后，回到家，你想使用自己的电脑再更新一份博客文件进行上传时，你依然遵循依次使用这三行代码进行更新，就会报错failed to push some refs to</p>
<img src="../../../images/blog-create/远程更新本地报错.png" alt="当图片损坏消失，这里的文字会显示出来代替图片" title="图片的名称" style="zoom:70%;" />

<p>原因： 	</p>
<p>当你尝试向你的 Git 仓库推送时遇到的错误消息表明，远程仓库中有你本地没有的更改。这种冲突阻止了 Git 推送你的更改，因为这可能会覆盖其他人所做的更改。</p>
<p>解决办法</p>
<ul>
<li>在你推送你的更改之前，你需要将你的本地仓库与远程仓库同步。这可以通过从远程拉取更改来完成</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br></pre></td></tr></table></figure>

<p>这个命令从名为 origin 的远程的 main 分支获取更新并将它们合并到你当前的分支。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                                             #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;尝试开始更新博客&quot;                        </span><br><span class="line">git push origin main                                  #推送你的更改</span><br></pre></td></tr></table></figure>

<p>至此，问题完美解决，实现了本地和远程同步啦。</p>
<p><strong>总结</strong></p>
<p>只要本地仓库（本地的文件夹）内容和远程仓库内容不一致的时候，即本地的内容比仓库旧，</p>
<p>需要先进行 <code>git pull origin main</code>就能实现本地和远程仓库同步。</p>
<p>而修改了本地的博客文件后，就会实现本地的内容比远程仓库版本更新一些，push操作就不会报错。</p>
<p>（当本地的文件比博客文件旧，没有先进行pull，修改了本地文件之后，再进行pull时，git会自动保留最新的文件版本，本地新增的文件不会丢失，所以报错的时候直接<code>git pull origin main</code>即可实现同步，再进行push不会失败）</p>
<h3 id="方法二-常用设备更新博客"><a href="#方法二-常用设备更新博客" class="headerlink" title="方法二       常用设备更新博客"></a>方法二       常用设备更新博客</h3><p>你想在常用的两台电脑上更新你的博客，例如家里一台电脑、公司一台电脑。</p>
<p>需要让两台电脑都连上储存着博客源码的<code>私有仓库</code>。</p>
<p>这里先假设你是在家里的电脑上搭建的博客，但是想去公司更新博客，因此我们这里来讲一下如何使用公司的电脑进行博客的更新。</p>
<p>由于公司的电脑的环境没有进行配置，因此这里需要进行环境配置，参考本教程的</p>
<p>【1.1 安装Git】【2.4.2 设置SSH】、【2.4.3 在本地绑定与github的用户名和邮箱】</p>
<p>然后在公司电脑上建立一个文件夹用于储存博客文件，使用下面的代码将github仓库的博客原文件拉取到这个文件夹内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:lancou/hexosource.github.io.</span><br></pre></td></tr></table></figure>

<p>由于这个是私有仓库，新设备第一次拉取时会需要验证账号密码。</p>
<p>后面再想同步公司电脑（旧）与云端仓库（新）时，也可以使用<code>git pull origin main</code>来实现了。</p>
<p>当在公司修改了博客源文件之后，想把公司电脑上的本地仓库（新）同步到云端仓库（旧）</p>
<p>依次执行以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                                             #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;尝试开始更新博客&quot;                        </span><br><span class="line">git push origin main                                  #推送你的更改</span><br></pre></td></tr></table></figure>

<p>至此，你应该实现了在公司的电脑更新了你的博客。</p>
<hr>
<p>注意，在公司的电脑更新了博客之后，公司电脑的版本&#x3D;云端仓库的版本。</p>
<p>但此时云端仓库的版本（新），  家里电脑的仓库版本（旧），回到家里面又想更新博客时</p>
<p>要先拉取云端仓库文件到本地  ，运行命令 <code>git pull origin main</code>   </p>
<p>把你家里的电脑上的仓库（旧）更新成云端的版本（新），实现   家里电脑的仓库版本&#x3D;云端仓库的版本</p>
<p>当此时在家里电脑上修改了博客源文件之后，想把家里电脑上的本地仓库（新）同步到云端仓库（旧）</p>
<p>依次执行以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                                             #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;尝试开始更新博客&quot;                        </span><br><span class="line">git push origin main                                  #推送你的更改</span><br></pre></td></tr></table></figure>

<p>至此，你应该实现了在家里的电脑更新了你的博客。</p>
<hr>
<p>如此往复。。。。。。。。。</p>
<p><code>设备上改博客，最后一件事push代码； 换设备更新博客，第一件事pull代码</code></p>
<h1 id="四、可能遇到的问题"><a href="#四、可能遇到的问题" class="headerlink" title="四、可能遇到的问题"></a>四、可能遇到的问题</h1><h2 id="1-themes对应主题下的-git文件夹被上传导致的错误"><a href="#1-themes对应主题下的-git文件夹被上传导致的错误" class="headerlink" title="1. themes对应主题下的.git文件夹被上传导致的错误"></a>1. themes对应主题下的.git文件夹被上传导致的错误</h2><p>因为 next 主题文件夹下的.git 文件夹的存在，那么主题文件夹会被识别子项目。从而无法被上传到源码仓库。若是遇到添加屏蔽项，但是还是无法正常上传主题文件夹的情况。</p>
<p>1.剪切 themes&#x2F;next&#x2F;.git文件夹到其它处</p>
<p>2.从暂存区删除该文件夹 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rm --cache themes/next</span><br></pre></td></tr></table></figure>

<p>3.使用git status查看状态</p>
<img src=" https://img2018.cnblogs.com/blog/812260/201907/812260-20190710151913411-1393275619.png "  style="zoom:50%;" />

<p>4.提交修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .                                             #添加所有文件到暂存区</span><br><span class="line">git commit -m &quot;尝试开始更新博客&quot;                        </span><br><span class="line">git push origin main                                  #推送你的更改</span><br></pre></td></tr></table></figure>



<p>至此问题就解决了。</p>
]]></content>
      <categories>
        <category>note</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>butterfly</tag>
      </tags>
  </entry>
  <entry>
    <title>博客内嵌入视频-测试</title>
    <url>//blog/hexo/video1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这是使用html的video标签插入视频</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=&quot;xxxxxx.mp4&quot;  width=&quot;100%&quot; height=&quot;100%&quot;  poster=&quot;xxxxxx.jpg&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>
<p>src是视频的地址；poster是可以设置视频的封面（可选）</p>
<p><video src="https://cesium.com/public/SandcastleSampleData/big-buck-bunny_trailer.mp4"  width="100%" height="100%" poster="https://youimg1.c-ctrip.com/target/010341200061sysx2A203_D_10000_1200.jpg" controls="controls"></video></p>
<p>下面是B站引用的视频。autoplay&#x3D;0          (1自动播放，0点击播放)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=754099091&amp;bvid=BV1mk4y1m7nr&amp;cid=220770745&amp;page=1&amp;autoplay=0&amp;high_quality=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;500&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>


<iframe src="//player.bilibili.com/player.html?aid=754099091&bvid=BV1mk4y1m7nr&cid=220770745&page=1&autoplay=0&high_quality=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>





]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇加密文章的测试，密码6666</title>
    <url>//blog/hexo/jiami.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">
  <script id="hbeData" type="hbeData" data-hmacdigest="844a2b6db8e718bd3f5938101a7071258b83b13fd06f30995920f81a958635e9">591ad66477dc9f8d468bd98487d7d9f9cd9b9f6ee2197f4aecb152b8361f8df989fae85024aa73cbf6d601a62a94cdb2786bc0b21df69df0903f55ad88b8513e4bf063cb617d8927952d8c8ba2a1601aa90f921ef93b49195f1e6bdec3c16faffd4087343b56bad90f52318b131d240138d2a0e16dca7a136fb492c81aa21cca30a511a7d18681e22bebabcbd90e1ee5587d4afe536a5c98ab9e4c827b0b51ff3cafb1b3679f9a96eabc6591dc8aaae55de456ee7469337a0cb1e037ccc27548428cbc6f4b9a3b5151720e8bc2de7239ac63dff284624ac4961fbf4e4bf1e611c95a32bf5ce7f443d866034410670fbee5563fb23e69007f35188c8adace031ec4eb3370f8b9ca2c2f9d268621749b6bc669a4fe2e2c05943b87e4b15bdb2680bc9aa5703d881c6cfefbc86ce67c79aeeb36c1e81320605744d2a512325a0be655b9d9cf5fbeb577085a869a9f1cea6695f371b775f2d24e7a1bb5d6a11e0f490aa56aefbb589825377f7d3fd947b2d3440e04b6de125724a8b60e3db0b5da41</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-blink">
      <input class="hbe hbe-input-field hbe-input-field-blink" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-blink" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-blink" data-content="您好，这里需要密码。">您好，这里需要密码。</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>2024高考化学易错题整理</title>
    <url>//blog/chemistry/easy-mistake/2024zhenti.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2024高考易错题整理"><a href="#2024高考易错题整理" class="headerlink" title="2024高考易错题整理"></a>2024高考易错题整理</h1><h2 id="2024年甘肃卷"><a href="#2024年甘肃卷" class="headerlink" title="2024年甘肃卷"></a>2024年甘肃卷</h2><h3 id="1、灼烧海带制取海带灰"><a href="#1、灼烧海带制取海带灰" class="headerlink" title="1、灼烧海带制取海带灰"></a>1、灼烧海带制取海带灰</h3><p><strong>均匀加热</strong>：在灼烧过程中，确保海带均匀受热，避免局部过热导致燃烧。可以通过缓慢移动坩埚或瓷盘来实现均匀加热。（坩埚不能使用陶土网，应该是放在泥三角上）</p>
<p><strong>避免火焰</strong>：在碳化过程中，应避免海带直接接触火焰，以免引起燃烧。通常使用间接加热，如在火焰上方一定距离加热。</p>
<p><strong>观察变化</strong>：在加热过程中，要密切观察海带的颜色和状态变化，直到它完全变黑并碳化。</p>
<p><strong>打开坩埚盖</strong>：通过灼烧去除水分并碳化海带，通常不需要盖上盖子。这样做可以让水分和挥发性物质（如盐分）容易蒸发，同时便于观察海带的碳化过程。</p>
<h3 id="2、向氯化镁溶液中滴加氢氧化钠，看到白色沉淀，能否证明氢氧化钠碱性比氢氧化镁强。"><a href="#2、向氯化镁溶液中滴加氢氧化钠，看到白色沉淀，能否证明氢氧化钠碱性比氢氧化镁强。" class="headerlink" title="2、向氯化镁溶液中滴加氢氧化钠，看到白色沉淀，能否证明氢氧化钠碱性比氢氧化镁强。"></a>2、向氯化镁溶液中滴加氢氧化钠，看到白色沉淀，能否证明氢氧化钠碱性比氢氧化镁强。</h3><p>反应的发生可以由多种因素决定，包括：</p>
<ul>
<li><p><strong>反应朝着离子浓度减小的方向进行</strong>，例如生成沉淀、气体、弱电解质（例如水）。</p>
</li>
<li><p><strong>化学平衡的移动</strong>：反应是否进行还取决于反应物和生成物的浓度，以及温度等条件，这些都会影响化学平衡的位置。</p>
</li>
<li><p><strong>热力学和动力学因素</strong>：反应的热力学可行性（如自由能变化）和反应的动力学（反应速率）也是决定反应是否进行的重要因素。</p>
</li>
</ul>
<p>也可以这三点就是反应进行的原理，是具有普适性的。</p>
<p>氯化镁溶液中滴入氢氧化钠溶液，会发生复分解反应，生成氢氧化镁沉淀，与氢氧化钠、氢氧化镁的碱性强弱无关，不能由此得出氢氧化钠的碱性比氢氧化镁强。</p>
<p>学习过沉淀溶解平衡的知识，让我们知道了沉淀可以由Ksp大的向Ksp小的进行转化。</p>
<p>也就是说氯化镁与氢氧化钠反应涉及到真正反应动力可以用下面的原理来解释，</p>
<p>[1]复分解原理；反应总是朝着溶液中离子浓度减小的方向进行，因为这样能降低体系的自由度，▲G&lt;0。</p>
<p>[2]沉淀溶解平衡的转化；氢氧化镁为难溶物，Ksp较小。</p>
<p><strong>如何去理解”强酸制弱酸、强碱制弱碱“？</strong></p>
<p><strong>当稀溶液中的酸碱反应体系仅存在酸碱平衡时，“强酸制弱酸”的规律是成立的，不存在其他平衡例如氧化还原平衡、配位平衡、沉淀溶解平衡、气液平衡等。</strong></p>
<p>即只有体系中只存在酸性强弱的差距，不涉及到其他平衡的干扰才能认为是强酸制弱酸，这就导致”强酸制弱酸“这个所谓的”理论“使用的条件非常严格，不能随便套用。</p>
<p>最后，可以尝试去思考一下硫化氢与硫酸铜反应的例子。</p>
<hr>
<h2 id="2024浙江卷"><a href="#2024浙江卷" class="headerlink" title="2024浙江卷"></a>2024浙江卷</h2><h3 id="1、铁离子与氰酸根不能共存，会生成Fe-CN-6-3"><a href="#1、铁离子与氰酸根不能共存，会生成Fe-CN-6-3" class="headerlink" title="1、铁离子与氰酸根不能共存，会生成Fe(CN)6  3-"></a>1、铁离子与氰酸根不能共存，会生成Fe(CN)<sub>6</sub> <sup> 3-</sup></h3><h3 id="2、碘单质和碱性物质反应，产物是碘离子和碘酸根。"><a href="#2、碘单质和碱性物质反应，产物是碘离子和碘酸根。" class="headerlink" title="2、碘单质和碱性物质反应，产物是碘离子和碘酸根。"></a>2、碘单质和碱性物质反应，产物是碘离子和碘酸根。</h3><p>例如，碘单质（I₂）与氢氧化钠（NaOH）的反应通常生成碘化钠（NaI）、碘酸钠（NaIO₃）和水（H₂O）</p>
<p>与氯气和氢氧化钠的反应不同，氯气在不同条件下可以生成不同的产物（如NaCl、NaClO、NaClO₃），这是因为次氯酸盐（ClO⁻）和氯酸盐（ClO₃⁻）相对稳定，而次碘酸盐（IO⁻）则非常不稳定，容易进一步氧化为碘酸钠（NaIO₃）。因此，碘单质与氢氧化钠的反应不会产生像氯气那样的多种产物，而是倾向于生成碘化钠和碘酸钠。这种差异主要是由于不同卤素的化学性质和它们形成的化合物的稳定性所决定的。</p>
<h3 id="3、晶体硅中，用碳原子取代部分硅原子，能使其导电性增强吗？"><a href="#3、晶体硅中，用碳原子取代部分硅原子，能使其导电性增强吗？" class="headerlink" title="3、晶体硅中，用碳原子取代部分硅原子，能使其导电性增强吗？"></a>3、晶体硅中，用碳原子取代部分硅原子，能使其导电性增强吗？</h3><p>答案是：不能。</p>
<p>在晶体硅中，使用碳原子代替硅原子通常不会直接增强导电性。硅是一种半导体材料，其导电性可以通过掺杂来控制。在半导体材料中，掺杂是指在晶体中故意引入少量的杂质原子，这些杂质原子可以是施主（提供额外电子）或受主（接受电子），从而改变材料的电子结构和导电性。</p>
<p>在硅中，通常通过掺入如硼（B）这样的受主杂质来形成p型半导体，或者通过掺入如磷（P）这样的施主杂质来形成n型半导体。这些掺杂原子会改变硅的电子结构，从而增强其导电性。例如，掺入磷的硅会因为额外的电子而增加导电性，因为这些电子可以参与导电过程。</p>
<p>然而，碳原子与硅原子在晶体硅中的置换并不会直接导致导电性的增强。碳和硅都是第IV族元素，它们在周期表中的化学性质相似，但碳的原子半径小于硅，这可能导致晶体结构的畸变。此外，碳的掺杂不一定能像磷或硼那样有效地提供额外的电子或空穴来增加导电性。实际上，碳在硅中的掺杂可能会引入结构缺陷，影响硅的半导体性质。</p>
<p>在某些情况下，如在锂离子电池的硅基负极材料中，通过引入碳形成硅&#x2F;碳复合材料，可以提高材料的结构稳定性和导电性。这是因为碳材料可以提供额外的电子传输路径，并且有助于缓冲硅在充放电过程中的体积膨胀。但这种增强是通过复合材料的结构设计实现的，而不是简单地通过碳原子替代硅原子来实现的。</p>
<p>总的来说，晶体硅中使用碳原子代替硅原子并不是一种有效的增强导电性的方法。相反，通过特定的掺杂技术或者设计硅&#x2F;碳复合材料结构，可以更有效地改善硅的导电性能。</p>
<h3 id="4、关于亚硫酸钡沉淀"><a href="#4、关于亚硫酸钡沉淀" class="headerlink" title="4、关于亚硫酸钡沉淀"></a>4、关于亚硫酸钡沉淀</h3><ul>
<li><p><strong>将二氧化硫通入氯化钡溶液，一般看不到白色沉淀</strong>。原因是产物氯化氢与亚硫酸钡不能共存，反应无法进行。</p>
<p>除非此时有氧化性物质在溶液体系中，例如氧气、氯气、可以将亚硫酸根氧化成硫酸根而沉淀。</p>
<p>当然，如果溶液中有碱性物质，能够除去反应生成的氯化氢，那么也能够看到白色沉淀。</p>
</li>
<li><p>将亚硫酸溶液加入到氯化钡溶液，理论上可以生成亚硫酸钡（BaSO₃）沉淀。然而，亚硫酸钡在水中的溶解度虽然很低，但它仍然可以溶解在盐酸（HCl）中。因此，即使在实验中观察到了白色沉淀，这些沉淀也可能因为反应体系中存在的盐酸而被溶解，导致最终看不到沉淀。在实际操作中，如果实验系统中含有氧气，二氧化硫（SO₂）可能会被氧化成硫酸（H₂SO₄），进而与氯化钡反应生成硫酸钡（BaSO₄）沉淀，这是一种不溶于水和酸的白色沉淀。</p>
</li>
</ul>
<p>​	因此，这个实验中是否能看到沉淀，取决于实验条件，如反应体系中是否存在氧气，以及盐酸的浓度等因素。在无氧条件下，亚硫酸与氯化钡混合可能会看到白色沉淀接着又会溶解；但在有氧条件下，由于亚硫酸被氧化，可能看到较为稳定的白色沉淀。</p>
<h3 id="5、将硝酸与三氧化硫按照1：2发生化合反应生成A，测得A由两种物质构成，其中之一是NO2-。试问："><a href="#5、将硝酸与三氧化硫按照1：2发生化合反应生成A，测得A由两种物质构成，其中之一是NO2-。试问：" class="headerlink" title="5、将硝酸与三氧化硫按照1：2发生化合反应生成A，测得A由两种物质构成，其中之一是NO2+ 。试问："></a>5、将硝酸与三氧化硫按照1：2发生化合反应生成A，测得A由两种物质构成，其中之一是NO<sub>2</sub><sup>+</sup> 。试问：</h3><ul>
<li>比较氧化性强弱：NO<sub>2</sub><sup>+</sup>         HNO<sub>3</sub></li>
</ul>
<p>NO<sub>2</sub><sup>+</sup>的氧化性大于硝酸。可以将NO<sub>2</sub><sup>+</sup>看作是硝酸脱去了一个氢氧根所得到的产物，硝酸脱去氢氧根这个阴离子后，得电子能力更强了。</p>
<p>这种结论有点类似：“氨气的还原性强于铵根”、“铁离子的氧化性强于亚铁离子”。</p>
<ul>
<li>写出A中阴离子的结构式</li>
</ul>
<p>A中阴离子为HS<sub>2</sub> O<sub>7</sub>  <sup>—</sup>，其结构式为</p>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8htt3se11poj303x01la9u.jpg "  style="zoom:90%;" />



<h3 id="6、钠和二氧化碳加热的反应方程式"><a href="#6、钠和二氧化碳加热的反应方程式" class="headerlink" title="6、钠和二氧化碳加热的反应方程式"></a>6、钠和二氧化碳加热的反应方程式</h3><p>①二氧化碳少量，产物为氧化钠 + 一氧化碳</p>
<p>②二氧化碳过量，产物为碳酸钠  + 一氧化碳</p>
]]></content>
      <categories>
        <category>高中化学</category>
        <category>易错题</category>
      </categories>
      <tags>
        <tag>化学真题</tag>
      </tags>
  </entry>
  <entry>
    <title>近三年全国各省市高考化学真题分享（学生版+教师版）</title>
    <url>//blog/chemistry/shijuan/2021-2023.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、获取通道"><a href="#一、获取通道" class="headerlink" title="一、获取通道"></a>一、获取通道</h1><p>链接:<a href="https://caiyun.139.com/m/i?065Ct6gI60upp">https://caiyun.139.com/m/i?065Ct6gI60upp</a><br>提取码:PgLi<br>复制内容打开移动云盘PC客户端，操作更方便哦</p>
<img src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOmk6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVl6WldDeWhjVVJJa3FxRk5adFJVUmtCOTdNTmNLM0JyZVgwNk5JZTJDM1lqZz9lPVFKZGVYbQ.png" style="zoom:67%;" />







<h1 id="二、学生版实例"><a href="#二、学生版实例" class="headerlink" title="二、学生版实例"></a>二、学生版实例</h1><p><code>习题实例，习题+答案，但是每道习题后无答案。试卷的最后面是详细的答案与解析</code></p>
<img src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOmk6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVZyeUMwUGVmUnhLaUUyTURXVFN4TUVCS0tHeVJhYjM1ZjRlclZKN0E2OWo1Zz9lPXRyNkhvag.png" style="zoom:67%;" />







<p><code>答案与解析</code></p>
<img src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOmk6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVpUY3B1OEl4WjlEdW1rSlFKTGotbFVCazQtYWcwdWxwZE9rRGp1Y1F6enNhZz9lPXIzSEJLcQ.png" style="zoom:67%;" />

<h1 id="三、教师版"><a href="#三、教师版" class="headerlink" title="三、教师版"></a>三、教师版</h1><p><code>习题实例，习题+答案，但是每道习题后跟着答案与解析。</code></p>
<p>注意：教师版前半部分和学生版一样，后半部分才是<code>每道习题后跟着答案</code></p>
<img src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOmk6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVpWbEk0MFhxbEpCbWxEa0wwdFZ4d0lCbmVyeTFDZy1yeVhzUGRJbkM2ckZxdz9lPWNmeFFsTA.png" style="zoom:67%;" />]]></content>
      <categories>
        <category>高中化学</category>
        <category>试卷</category>
      </categories>
      <tags>
        <tag>download</tag>
      </tags>
  </entry>
  <entry>
    <title>高中化学90个实验视频汇总</title>
    <url>//blog/chemistry/experiment-videos/allvideos.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="01-粗盐提纯"><a href="#01-粗盐提纯" class="headerlink" title="01 粗盐提纯"></a>01 粗盐提纯</h1><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","video":{"url":"https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnY6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVo5UjRWOUZDMGxFczQ3d1cxQ2VveFlCRzdtSmp1Z2lCQ3VfbWM1eUZpMEgtUT9uYXY9ZXlKeVpXWmxjbkpoYkVsdVptOGlPbnNpY21WbVpYSnlZV3hCY0hBaU9pSlBibVZFY21sMlpVWnZja0oxYzJsdVpYTnpJaXdpY21WbVpYSnlZV3hCY0hCUWJHRjBabTl5YlNJNklsZGxZaUlzSW5KbFptVnljbUZzVFc5a1pTSTZJblpwWlhjaUxDSnlaV1psY25KaGJGWnBaWGNpT2lKTmVVWnBiR1Z6VEdsdWEwTnZjSGtpZlgwJmU9eWtRS2l6.mp4","pic":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg"},"danmaku":{"id":"粗盐提纯","api":"https://api.prprpr.me/dplayer/","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>

<hr>
<h1 id="02萃取与分液"><a href="#02萃取与分液" class="headerlink" title="02萃取与分液"></a>02萃取与分液</h1><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"theme":"#FADFA3","video":{"url":"https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnY6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVgyTnJtcVRhTVZJcm11VXFpQ3ktMElCRHp4aHpaSzVITHI0UWd4MFctOG5Udz9uYXY9ZXlKeVpXWmxjbkpoYkVsdVptOGlPbnNpY21WbVpYSnlZV3hCY0hBaU9pSlBibVZFY21sMlpVWnZja0oxYzJsdVpYTnpJaXdpY21WbVpYSnlZV3hCY0hCUWJHRjBabTl5YlNJNklsZGxZaUlzSW5KbFptVnljbUZzVFc5a1pTSTZJblpwWlhjaUxDSnlaV1psY25KaGJGWnBaWGNpT2lKTmVVWnBiR1Z6VEdsdWEwTnZjSGtpZlgwJmU9cUp2MkND.mp4","pic":"https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg"},"danmaku":{"id":"9E2E3368B56CDBB4","api":"https://api.prprpr.me/dplayer/","token":"tokendemo"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>







<h1 id="03配置100毫升1mo1L氯化钠溶液"><a href="#03配置100毫升1mo1L氯化钠溶液" class="headerlink" title="03配置100毫升1mo1L氯化钠溶液"></a>03配置100毫升1mo1L氯化钠溶液</h1><h1 id="04氢氧化铁胶体制备、丁达尔效应"><a href="#04氢氧化铁胶体制备、丁达尔效应" class="headerlink" title="04氢氧化铁胶体制备、丁达尔效应"></a>04氢氧化铁胶体制备、丁达尔效应</h1><h1 id="05离子反应"><a href="#05离子反应" class="headerlink" title="05离子反应"></a>05离子反应</h1><h1 id="06钠的性质"><a href="#06钠的性质" class="headerlink" title="06钠的性质"></a>06钠的性质</h1><h1 id="07铁与水蒸气反应"><a href="#07铁与水蒸气反应" class="headerlink" title="07铁与水蒸气反应"></a>07铁与水蒸气反应</h1><h1 id="08铝与酸、碱溶液的反应"><a href="#08铝与酸、碱溶液的反应" class="headerlink" title="08铝与酸、碱溶液的反应"></a>08铝与酸、碱溶液的反应</h1><h1 id="09过氧化钠的性质"><a href="#09过氧化钠的性质" class="headerlink" title="09过氧化钠的性质"></a>09过氧化钠的性质</h1><h1 id="10碳酸钠和碳酸氢钠的性质"><a href="#10碳酸钠和碳酸氢钠的性质" class="headerlink" title="10碳酸钠和碳酸氢钠的性质"></a>10碳酸钠和碳酸氢钠的性质</h1><h1 id="11焰色反应"><a href="#11焰色反应" class="headerlink" title="11焰色反应"></a>11焰色反应</h1><h1 id="12铁的氢氧化物的制备"><a href="#12铁的氢氧化物的制备" class="headerlink" title="12铁的氢氧化物的制备"></a>12铁的氢氧化物的制备</h1><h1 id="13三价铁离子的检验"><a href="#13三价铁离子的检验" class="headerlink" title="13三价铁离子的检验"></a>13三价铁离子的检验</h1><h1 id="14铁盐和亚铁盐的一些性质"><a href="#14铁盐和亚铁盐的一些性质" class="headerlink" title="14铁盐和亚铁盐的一些性质"></a>14铁盐和亚铁盐的一些性质</h1><h1 id="15硅酸的制备、硅酸钠的性质"><a href="#15硅酸的制备、硅酸钠的性质" class="headerlink" title="15硅酸的制备、硅酸钠的性质"></a>15硅酸的制备、硅酸钠的性质</h1><h1 id="16氢气在氯气中燃烧"><a href="#16氢气在氯气中燃烧" class="headerlink" title="16氢气在氯气中燃烧"></a>16氢气在氯气中燃烧</h1><h1 id="17氯水、氯气的漂白作用"><a href="#17氯水、氯气的漂白作用" class="headerlink" title="17氯水、氯气的漂白作用"></a>17氯水、氯气的漂白作用</h1><h1 id="18氯离子的检验"><a href="#18氯离子的检验" class="headerlink" title="18氯离子的检验"></a>18氯离子的检验</h1><h1 id="19二氧化硫的制备与性质"><a href="#19二氧化硫的制备与性质" class="headerlink" title="19二氧化硫的制备与性质"></a>19二氧化硫的制备与性质</h1><h1 id="20氨溶于水的喷泉实验"><a href="#20氨溶于水的喷泉实验" class="headerlink" title="20氨溶于水的喷泉实验"></a>20氨溶于水的喷泉实验</h1><h1 id="21氨的实验室制法"><a href="#21氨的实验室制法" class="headerlink" title="21氨的实验室制法"></a>21氨的实验室制法</h1><h1 id="22铜与浓硫酸的反应"><a href="#22铜与浓硫酸的反应" class="headerlink" title="22铜与浓硫酸的反应"></a>22铜与浓硫酸的反应</h1><h1 id="23钾在空气中燃烧"><a href="#23钾在空气中燃烧" class="headerlink" title="23钾在空气中燃烧"></a>23钾在空气中燃烧</h1><h1 id="24钾与水的反应"><a href="#24钾与水的反应" class="headerlink" title="24钾与水的反应"></a>24钾与水的反应</h1><h1 id="25新制饱和氯水与溴化钠溶液的反应"><a href="#25新制饱和氯水与溴化钠溶液的反应" class="headerlink" title="25新制饱和氯水与溴化钠溶液的反应"></a>25新制饱和氯水与溴化钠溶液的反应</h1><h1 id="26新制饱和氯水与碘化钾溶液的反应"><a href="#26新制饱和氯水与碘化钾溶液的反应" class="headerlink" title="26新制饱和氯水与碘化钾溶液的反应"></a>26新制饱和氯水与碘化钾溶液的反应</h1><h1 id="27溴水与碘化钾溶液的反应"><a href="#27溴水与碘化钾溶液的反应" class="headerlink" title="27溴水与碘化钾溶液的反应"></a>27溴水与碘化钾溶液的反应</h1><h1 id="28镁与沸水的反应"><a href="#28镁与沸水的反应" class="headerlink" title="28镁与沸水的反应"></a>28镁与沸水的反应</h1><h1 id="29镁铝与盐酸反应的对比实验"><a href="#29镁铝与盐酸反应的对比实验" class="headerlink" title="29镁铝与盐酸反应的对比实验"></a>29镁铝与盐酸反应的对比实验</h1><h1 id="30钠与氯气反应"><a href="#30钠与氯气反应" class="headerlink" title="30钠与氯气反应"></a>30钠与氯气反应</h1><h1 id="31测定铝与盐酸反应的热效应"><a href="#31测定铝与盐酸反应的热效应" class="headerlink" title="31测定铝与盐酸反应的热效应"></a>31测定铝与盐酸反应的热效应</h1><h1 id="32观察八水合氢氧化钡晶体与氯化铵晶体反应的热效应"><a href="#32观察八水合氢氧化钡晶体与氯化铵晶体反应的热效应" class="headerlink" title="32观察八水合氢氧化钡晶体与氯化铵晶体反应的热效应"></a>32观察八水合氢氧化钡晶体与氯化铵晶体反应的热效应</h1><h1 id="33测定酸碱中和反应的热效应"><a href="#33测定酸碱中和反应的热效应" class="headerlink" title="33测定酸碱中和反应的热效应"></a>33测定酸碱中和反应的热效应</h1><h1 id="34乙醇与钠的反应"><a href="#34乙醇与钠的反应" class="headerlink" title="34乙醇与钠的反应"></a>34乙醇与钠的反应</h1><h1 id="35锌铜原电池"><a href="#35锌铜原电池" class="headerlink" title="35锌铜原电池"></a>35锌铜原电池</h1><h1 id="36水果电池"><a href="#36水果电池" class="headerlink" title="36水果电池"></a>36水果电池</h1><h1 id="37温度对化学反应速率的影响"><a href="#37温度对化学反应速率的影响" class="headerlink" title="37温度对化学反应速率的影响"></a>37温度对化学反应速率的影响</h1><h1 id="38催化剂对化学反应速率的影响"><a href="#38催化剂对化学反应速率的影响" class="headerlink" title="38催化剂对化学反应速率的影响"></a>38催化剂对化学反应速率的影响</h1><h1 id="39甲烷和氯气反应所需条件的对比实验"><a href="#39甲烷和氯气反应所需条件的对比实验" class="headerlink" title="39甲烷和氯气反应所需条件的对比实验"></a>39甲烷和氯气反应所需条件的对比实验</h1><h1 id="40石蜡油分解实验及其分解产物的性质实验"><a href="#40石蜡油分解实验及其分解产物的性质实验" class="headerlink" title="40石蜡油分解实验及其分解产物的性质实验"></a>40石蜡油分解实验及其分解产物的性质实验</h1><h1 id="41葡萄糖跟新制氢氧化铜悬浊液反应"><a href="#41葡萄糖跟新制氢氧化铜悬浊液反应" class="headerlink" title="41葡萄糖跟新制氢氧化铜悬浊液反应"></a>41葡萄糖跟新制氢氧化铜悬浊液反应</h1><h1 id="42碘酒与淀粉作用"><a href="#42碘酒与淀粉作用" class="headerlink" title="42碘酒与淀粉作用"></a>42碘酒与淀粉作用</h1><h1 id="43蛋白质的颜色反应"><a href="#43蛋白质的颜色反应" class="headerlink" title="43蛋白质的颜色反应"></a>43蛋白质的颜色反应</h1><h1 id="44蔗糖的水解及其产物的验证"><a href="#44蔗糖的水解及其产物的验证" class="headerlink" title="44蔗糖的水解及其产物的验证"></a>44蔗糖的水解及其产物的验证</h1><h1 id="45铝热反应"><a href="#45铝热反应" class="headerlink" title="45铝热反应"></a>45铝热反应</h1><h1 id="46葡萄糖的银镜反应"><a href="#46葡萄糖的银镜反应" class="headerlink" title="46葡萄糖的银镜反应"></a>46葡萄糖的银镜反应</h1><h1 id="47淀粉的水解"><a href="#47淀粉的水解" class="headerlink" title="47淀粉的水解"></a>47淀粉的水解</h1><h1 id="48蛋白质的性质"><a href="#48蛋白质的性质" class="headerlink" title="48蛋白质的性质"></a>48蛋白质的性质</h1><h1 id="49维生素C的还原性"><a href="#49维生素C的还原性" class="headerlink" title="49维生素C的还原性"></a>49维生素C的还原性</h1><h1 id="50不同条件下铁钉的锈蚀"><a href="#50不同条件下铁钉的锈蚀" class="headerlink" title="50不同条件下铁钉的锈蚀"></a>50不同条件下铁钉的锈蚀</h1><h1 id="51合成氨"><a href="#51合成氨" class="headerlink" title="51合成氨"></a>51合成氨</h1><h1 id="52硫酸铜跟氨水的反应"><a href="#52硫酸铜跟氨水的反应" class="headerlink" title="52硫酸铜跟氨水的反应"></a>52硫酸铜跟氨水的反应</h1><h1 id="53氯化铁溶液跟硫氰化钾溶液反应"><a href="#53氯化铁溶液跟硫氰化钾溶液反应" class="headerlink" title="53氯化铁溶液跟硫氰化钾溶液反应"></a>53氯化铁溶液跟硫氰化钾溶液反应</h1><h1 id="54碘单质在不同溶剂中的溶解性"><a href="#54碘单质在不同溶剂中的溶解性" class="headerlink" title="54碘单质在不同溶剂中的溶解性"></a>54碘单质在不同溶剂中的溶解性</h1><h1 id="55碘单质的升华"><a href="#55碘单质的升华" class="headerlink" title="55碘单质的升华"></a>55碘单质的升华</h1><h1 id="56镁条在二氧化碳中燃烧"><a href="#56镁条在二氧化碳中燃烧" class="headerlink" title="56镁条在二氧化碳中燃烧"></a>56镁条在二氧化碳中燃烧</h1><h1 id="57测量锌与硫酸反应速率"><a href="#57测量锌与硫酸反应速率" class="headerlink" title="57测量锌与硫酸反应速率"></a>57测量锌与硫酸反应速率</h1><h1 id="58高锰酸钾溶液与草酸溶液的反应"><a href="#58高锰酸钾溶液与草酸溶液的反应" class="headerlink" title="58高锰酸钾溶液与草酸溶液的反应"></a>58高锰酸钾溶液与草酸溶液的反应</h1><h1 id="59硫代硫酸钠溶液跟稀硫酸的反应"><a href="#59硫代硫酸钠溶液跟稀硫酸的反应" class="headerlink" title="59硫代硫酸钠溶液跟稀硫酸的反应"></a>59硫代硫酸钠溶液跟稀硫酸的反应</h1><h1 id="60温度与碘化钾被氧化的关系"><a href="#60温度与碘化钾被氧化的关系" class="headerlink" title="60温度与碘化钾被氧化的关系"></a>60温度与碘化钾被氧化的关系</h1><h1 id="61过氧化氢与二氧化锰作用"><a href="#61过氧化氢与二氧化锰作用" class="headerlink" title="61过氧化氢与二氧化锰作用"></a>61过氧化氢与二氧化锰作用</h1><h1 id="62过氧化氢跟三氧化铁溶液、硫酸铜溶液作用"><a href="#62过氧化氢跟三氧化铁溶液、硫酸铜溶液作用" class="headerlink" title="62过氧化氢跟三氧化铁溶液、硫酸铜溶液作用"></a>62过氧化氢跟三氧化铁溶液、硫酸铜溶液作用</h1><h1 id="63草酸溶液跟高锰酸钾溶液、硫酸锰混合作用"><a href="#63草酸溶液跟高锰酸钾溶液、硫酸锰混合作用" class="headerlink" title="63草酸溶液跟高锰酸钾溶液、硫酸锰混合作用"></a>63草酸溶液跟高锰酸钾溶液、硫酸锰混合作用</h1><h1 id="64淀粉溶液跟唾液、稀硫酸作用"><a href="#64淀粉溶液跟唾液、稀硫酸作用" class="headerlink" title="64淀粉溶液跟唾液、稀硫酸作用"></a>64淀粉溶液跟唾液、稀硫酸作用</h1><h1 id="65重硌酸钾溶液在不同酸度时的颜色"><a href="#65重硌酸钾溶液在不同酸度时的颜色" class="headerlink" title="65重硌酸钾溶液在不同酸度时的颜色"></a>65重硌酸钾溶液在不同酸度时的颜色</h1><h1 id="66三氯化铁跟不同浓度的硫氰化钾溶液反应"><a href="#66三氯化铁跟不同浓度的硫氰化钾溶液反应" class="headerlink" title="66三氯化铁跟不同浓度的硫氰化钾溶液反应"></a>66三氯化铁跟不同浓度的硫氰化钾溶液反应</h1><h1 id="67二氧化氮和四氧化二氮的相互转化"><a href="#67二氧化氮和四氧化二氮的相互转化" class="headerlink" title="67二氧化氮和四氧化二氮的相互转化"></a>67二氧化氮和四氧化二氮的相互转化</h1><h1 id="68相同条件下，镁条跟盐酸和醋酸的反应"><a href="#68相同条件下，镁条跟盐酸和醋酸的反应" class="headerlink" title="68相同条件下，镁条跟盐酸和醋酸的反应"></a>68相同条件下，镁条跟盐酸和醋酸的反应</h1><h1 id="69相同条件下，醋酸、硼酸分别和碳酸钠溶液反应"><a href="#69相同条件下，醋酸、硼酸分别和碳酸钠溶液反应" class="headerlink" title="69相同条件下，醋酸、硼酸分别和碳酸钠溶液反应"></a>69相同条件下，醋酸、硼酸分别和碳酸钠溶液反应</h1><h1 id="70用PH计测量溶液的PH"><a href="#70用PH计测量溶液的PH" class="headerlink" title="70用PH计测量溶液的PH"></a>70用PH计测量溶液的PH</h1><h1 id="71实验测定酸碱反应曲线"><a href="#71实验测定酸碱反应曲线" class="headerlink" title="71实验测定酸碱反应曲线"></a>71实验测定酸碱反应曲线</h1><h1 id="72相同条件下，测定不同盐溶液的PH"><a href="#72相同条件下，测定不同盐溶液的PH" class="headerlink" title="72相同条件下，测定不同盐溶液的PH"></a>72相同条件下，测定不同盐溶液的PH</h1><h1 id="73三氧化铁溶液的配制"><a href="#73三氧化铁溶液的配制" class="headerlink" title="73三氧化铁溶液的配制"></a>73三氧化铁溶液的配制</h1><h1 id="74沉淀的溶解"><a href="#74沉淀的溶解" class="headerlink" title="74沉淀的溶解"></a>74沉淀的溶解</h1><h1 id="75沉淀的转化"><a href="#75沉淀的转化" class="headerlink" title="75沉淀的转化"></a>75沉淀的转化</h1><h1 id="76铜锌硫酸原电池"><a href="#76铜锌硫酸原电池" class="headerlink" title="76铜锌硫酸原电池"></a>76铜锌硫酸原电池</h1><h1 id="77氯化钠溶液的电解"><a href="#77氯化钠溶液的电解" class="headerlink" title="77氯化钠溶液的电解"></a>77氯化钠溶液的电解</h1><h1 id="78氯化铜溶液的电解"><a href="#78氯化铜溶液的电解" class="headerlink" title="78氯化铜溶液的电解"></a>78氯化铜溶液的电解</h1><h1 id="79电镀"><a href="#79电镀" class="headerlink" title="79电镀"></a>79电镀</h1><h1 id="80铁的吸氧腐蚀"><a href="#80铁的吸氧腐蚀" class="headerlink" title="80铁的吸氧腐蚀"></a>80铁的吸氧腐蚀</h1><h1 id="81验证牺牲阳极的阴极保护法"><a href="#81验证牺牲阳极的阴极保护法" class="headerlink" title="81验证牺牲阳极的阴极保护法"></a>81验证牺牲阳极的阴极保护法</h1><h1 id="82水的电解与氢氧混合气爆鸣的微型实验"><a href="#82水的电解与氢氧混合气爆鸣的微型实验" class="headerlink" title="82水的电解与氢氧混合气爆鸣的微型实验"></a>82水的电解与氢氧混合气爆鸣的微型实验</h1><h1 id="83氯气的生成及其性质的微型实验"><a href="#83氯气的生成及其性质的微型实验" class="headerlink" title="83氯气的生成及其性质的微型实验"></a>83氯气的生成及其性质的微型实验</h1><h1 id="84污水处理"><a href="#84污水处理" class="headerlink" title="84污水处理"></a>84污水处理</h1><h1 id="85蒸馏"><a href="#85蒸馏" class="headerlink" title="85蒸馏"></a>85蒸馏</h1><h1 id="86从海带中提取碘"><a href="#86从海带中提取碘" class="headerlink" title="86从海带中提取碘"></a>86从海带中提取碘</h1><h1 id="87硫酸亚铁铵的制备"><a href="#87硫酸亚铁铵的制备" class="headerlink" title="87硫酸亚铁铵的制备"></a>87硫酸亚铁铵的制备</h1><h1 id="88乙酸乙酯的制备及反应条件探究"><a href="#88乙酸乙酯的制备及反应条件探究" class="headerlink" title="88乙酸乙酯的制备及反应条件探究"></a>88乙酸乙酯的制备及反应条件探究</h1><h1 id="89氢氧化铝的制"><a href="#89氢氧化铝的制" class="headerlink" title="89氢氧化铝的制"></a>89氢氧化铝的制</h1><h1 id="90几种无机离子的检验"><a href="#90几种无机离子的检验" class="headerlink" title="90几种无机离子的检验"></a>90几种无机离子的检验</h1>]]></content>
      <categories>
        <category>高中化学</category>
        <category>实验视频</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>WiFi连接问题——能连的上其他WiFi，但是某个wifi连不上。</title>
    <url>//blog/solution/Wifi.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1.问题描述"></a>1.问题描述</h1><p>我的电脑突然无法连接<code>Edu</code>这个wifi了，但是其他人的电脑设备包括我的手机都能正常连接并使用，因此排除是路由器的问题。</p>
<p>我的电脑昨天还能正常连接这个wifi，今天突然就不行了。</p>
<p>连接WiFi，提示<code>无法连接到该wifi</code></p>
<p>问题已经描述完毕，下面是我的解决方法。</p>
<hr>
<h1 id="2、解决方法"><a href="#2、解决方法" class="headerlink" title="2、解决方法"></a>2、解决方法</h1><h2 id="2-1-打开设备管理器"><a href="#2-1-打开设备管理器" class="headerlink" title="2.1 打开设备管理器"></a>2.1 打开设备管理器</h2><img src=" https://im.gurl.eu.org/file/09484fab4b26f49a6663a.png "  style="zoom:50%;" />

<h2 id="2-2-找到【网络适配器】中的wifi模块"><a href="#2-2-找到【网络适配器】中的wifi模块" class="headerlink" title="2.2 找到【网络适配器】中的wifi模块"></a>2.2 找到【网络适配器】中的wifi模块</h2><img src=" https://im.gurl.eu.org/file/9169269d6aafc445c40f1.png "  style="zoom:50%;" />

<h2 id="2-3-右键，打开属性"><a href="#2-3-右键，打开属性" class="headerlink" title="2.3 右键，打开属性"></a>2.3 右键，打开属性</h2><img src=" https://im.gurl.eu.org/file/07ae550adc81298e1de42.png "  style="zoom:50%;" />

<h2 id="2-4-选择【高级】-选择【802-11-ax-ac-n-abg】-设置“值”为【802-11-a-b-g】"><a href="#2-4-选择【高级】-选择【802-11-ax-ac-n-abg】-设置“值”为【802-11-a-b-g】" class="headerlink" title="2.4 选择【高级】-选择【802.11.ax&#x2F;ac&#x2F;n&#x2F;abg】-设置“值”为【802.11.a&#x2F;b&#x2F;g】"></a>2.4 选择【高级】-选择【802.11.ax&#x2F;ac&#x2F;n&#x2F;abg】-设置“值”为【802.11.a&#x2F;b&#x2F;g】</h2><img src=" https://im.gurl.eu.org/file/e37de8a3d82a9b839ca69.png "  style="zoom:50%;" />



<h2 id="2-4-连接wifi即可。"><a href="#2-4-连接wifi即可。" class="headerlink" title="2.4 连接wifi即可。"></a>2.4 连接wifi即可。</h2><p>至此，我的问题已经解决。</p>
<hr>
<h1 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h1><p>我也不清楚，玄学啊！</p>
<p>参考：<a href="https://blog.csdn.net/HurryBen/article/details/120509784">https://blog.csdn.net/HurryBen/article/details/120509784</a></p>
]]></content>
      <categories>
        <category>常见电脑疑难的解决方案</category>
      </categories>
      <tags>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>桌面图标间距变大，如何修改回去？解决办法</title>
    <url>//blog/solution/deskico.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>修改之前<br><img src=" https://s21.ax1x.com/2024/08/25/pAF7dv6.png "  style="zoom:30%;" /></p>
<p>修改之后如下图</p>
<img src=" https://s21.ax1x.com/2024/08/25/pAF7DbD.png "  style="zoom:50%;" />



<p>一键修改桌面图标间距（推荐）。</p>
<p>链接: <a href="https://caiyun.139.com/m/i?065CtbL96waQC">https://caiyun.139.com/m/i?065CtbL96waQC</a>    提取码:aQ4L  </p>
<p>下载文件后，打开运行</p>
<p>脚本先会自动帮你备份，然后再次回车确认开始修改，最后手动重启电脑即可查看效果。</p>
<hr>
<h2 id="手动修改-解决办法"><a href="#手动修改-解决办法" class="headerlink" title="手动修改-解决办法"></a>手动修改-解决办法</h2><ol>
<li><strong>打开注册表编辑器</strong><ul>
<li>按下<code>Win + R</code>快捷键打开“运行”对话框，输入<code>regedit</code>，然后按回车键。在弹出的用户账户控制提示中点击“是”以打开注册表编辑器。</li>
</ul>
</li>
<li><strong>定位到相应键值</strong><ul>
<li>在注册表编辑器的左侧目录树中，导航至以下路径：<br><code>HKEY_CURRENT_USER\Control Panel\Desktop\WindowMetrics</code></li>
</ul>
</li>
<li><strong>备份注册表</strong></li>
<li><strong>修改图标间距</strong><ul>
<li>在右侧找到名为<code>IconSpacing</code>和<code>IconVerticalSpacing</code>的两个键值。</li>
<li>双击<code>IconSpacing</code>，将数值数据改为<code>-1125</code>，然后同样操作修改<code>IconVerticalSpacing</code>为<code>-1125</code>。</li>
<li>确认更改后关闭注册表编辑器。</li>
</ul>
</li>
<li><strong>注销&#x2F;重启计算机</strong><ul>
<li>完成修改后，注销&#x2F;重启电脑让更改生效。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>常见电脑疑难的解决方案</category>
      </categories>
      <tags>
        <tag>桌面图标</tag>
      </tags>
  </entry>
  <entry>
    <title>深圳某老师与交警精彩的庭审现场视频（2020）</title>
    <url>//blog/epicwebevent/szjsvsjc.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>案号 ：（2020）粤0308行初2761号<br>案由：道路行政强制及行政复议<br>原告 ：王勇 （深圳某学院老师）<br>被告：深圳市公安局交通警察支队龙岗大队、深圳市公安局交通警察局<br>开庭时间：2021年03月30日 09:30<br>法院：深圳市盐田区人民法院<br>庭审地点：行政审判中心第十七法庭（817）</p>
<p>最终结果：交警败诉。</p>
<p><a href="https://mp.weixin.qq.com/s/rr_dHPJtehqf6UACjPNvNQ">https://mp.weixin.qq.com/s/rr_dHPJtehqf6UACjPNvNQ</a></p>
<p>（这个视频刚开始几秒是没有声音的，所以注意音量别调太大）</p>
<p>下面是使用html标签插入的视频</p>
<p><video src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnY6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRWNmTkxFQmpvV3hFb0JMWTJ0SXQyMWtCX1VaNmdBRjhBb3BmYWpuYWN6aDBkdz9uYXY9ZXlKeVpXWmxjbkpoYkVsdVptOGlPbnNpY21WbVpYSnlZV3hCY0hBaU9pSlBibVZFY21sMlpVWnZja0oxYzJsdVpYTnpJaXdpY21WbVpYSnlZV3hCY0hCUWJHRjBabTl5YlNJNklsZGxZaUlzSW5KbFptVnljbUZzVFc5a1pTSTZJblpwWlhjaUxDSnlaV1psY25KaGJGWnBaWGNpT2lKTmVVWnBiR1Z6VEdsdWEwTnZjSGtpZlgwJmU9cVowTVdV.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p>
]]></content>
      <categories>
        <category>时事分享</category>
      </categories>
      <tags>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>敢问路在何方（伴奏视频分享）</title>
    <url>//blog/liferecord/Dare-to-ask-where-the-road-is.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.bilibili.com/video/BV1oJ411M7fL">原视频</a></p>
<p>首先感谢原作者制作了精彩的作品，但是添加了一些片头噪音影响体验。</p>
<p>下面是剪辑去掉了片头，并且把<strong>无损背景音乐</strong>提取出来。</p>
<p>视频中的音乐软件叫做《flstudio》，以后有时间的话真想去学一学。</p>
<p><video src="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnY6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVk5SWIwQ2RXX05CcERCa0NNemdYV0lCc1UtdUo1QTBfUk1kbC1ZaTExdDNIdz9uYXY9ZXlKeVpXWmxjbkpoYkVsdVptOGlPbnNpY21WbVpYSnlZV3hCY0hBaU9pSlBibVZFY21sMlpVWnZja0oxYzJsdVpYTnpJaXdpY21WbVpYSnlZV3hCY0hCUWJHRjBabTl5YlNJNklsZGxZaUlzSW5KbFptVnljbUZzVFc5a1pTSTZJblpwWlhjaUxDSnlaV1psY25KaGJGWnBaWGNpT2lKTmVVWnBiR1Z6VEdsdWEwTnZjSGtpZlgwJmU9U3VPdVcz.mp4" position= "absolute" width="100%" height="100%" controls="controls"></video></p>
<p><a href="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnU6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRVhLWDhLMm4yaGxOaV9JaXZpRE1zVkFCOXIxNUc5aFdiQm50VG9oNE96YXVyZz9uYXY9ZXlKeVpXWmxjbkpoYkVsdVptOGlPbnNpY21WbVpYSnlZV3hCY0hBaU9pSlBibVZFY21sMlpVWnZja0oxYzJsdVpYTnpJaXdpY21WbVpYSnlZV3hCY0hCUWJHRjBabTl5YlNJNklsZGxZaUlzSW5KbFptVnljbUZzVFc5a1pTSTZJblpwWlhjaUxDSnlaV1psY25KaGJGWnBaWGNpT2lKTmVVWnBiR1Z6VEdsdWEwTnZjSGtpZlgwJmU9cXRjaE0x.flac">点我下载无损背景音乐</a></p>
]]></content>
      <categories>
        <category>生活记录</category>
        <category>未来计划</category>
      </categories>
      <tags>
        <tag>视频</tag>
        <tag>音乐</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS学习笔记</title>
    <url>//blog/note/code/CSS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h1 id="CSS-学习笔记"><a href="#CSS-学习笔记" class="headerlink" title="CSS 学习笔记"></a>CSS 学习笔记</h1><h1 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h1><h2 id="CSS-是什么？"><a href="#CSS-是什么？" class="headerlink" title="CSS 是什么？"></a>CSS 是什么？</h2><p>常说前端三件套：<code>HTML</code> 、<code>CSS</code>、<code>javaScript</code> 。可以将这三者的关系视为：</p>
<ul>
<li><code>HTML</code> 一个光溜溜的人。【结构】</li>
<li><code>CSS</code> 人身上穿的衣服。让人外表上看起来更美丽。【表现】</li>
<li><code>JavaScript</code> 让人具有动作、表情、神态。人看起来更有活力。【行为】</li>
</ul>
<p><code>CSS</code> ，全称为 <code>层叠样式表（Cassding Style Sheets）</code> 。<br><code>CSS</code> 也是一种标记语言，用于给 <code>HTML</code> 结构设置样式，例如：文字大小、颜色、宽高等等。</p>
<p><code>CSS</code> 的出现，让前端实现了 <code>结构</code> 与 <code>样式</code> 相分离。</p>
<h2 id="CSS-的语法"><a href="#CSS-的语法" class="headerlink" title="CSS 的语法"></a>CSS 的语法</h2><p><code>CSS</code> 语法规范由两部分组成：</p>
<ul>
<li><strong>选择器</strong> ：找到要添加样式的元素。</li>
<li><strong>声明块</strong> ：设置具体的样式（声明块中可以有多个声明），声明的格式为：<code>属性名: 属性值;</code></li>
</ul>
<blockquote>
<p>备注1：最后一个声明后的分号理论上能省略，但最好还是写上。</p>
<p>备注2：选择器与声明块之间，属性名与属性值之间，均有一个空格，理论上能省略，但最好还是写上。</p>
</blockquote>
<img src=" https://s21.ax1x.com/2024/10/08/pAGD1KA.png "  style="zoom:50%;" />

<ul>
<li>注释的写法：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 给h1元素添加样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="comment">/* 设置文字大小为40px */</span></span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="CSS-的编写位置"><a href="#CSS-的编写位置" class="headerlink" title="CSS 的编写位置"></a>CSS 的编写位置</h2><p><code>CSS</code>的编写位置有三种：元素的行内、html文件的内部、单独外部的CSS文件。</p>
<h3 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h3><ul>
<li><p>写在标签的<code>style</code>属性中，又称为<code>内联样式</code>。</p>
</li>
<li><p>语法：</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">h1</span> style=&quot;<span class="attribute">color</span>:red;<span class="attribute">font-size</span>:<span class="number">60px</span>;&quot;&gt;欢迎来学习前端&lt;/<span class="selector-tag">h1</span>&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<blockquote>
<p>1、行内样式表，只能控制当前标签的样式，对其他标签无效。</p>
<p>2、书写繁琐、样式不能复用。</p>
<p>3、没有体现出：<strong>结构与样式分离</strong> 的思想，不推荐大量使用，只有对当前元素添加简单样式时，才偶尔使用。</p>
</blockquote>
<h3 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h3><ul>
<li>写在<code>html</code>页面内部，将所有的<code>CSS</code>代码提取出来放在<code>&lt;style&gt;</code>标签中。</li>
<li>语法：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<blockquote>
<ol>
<li><p><code>&lt;style&gt;</code> 标签理论上可以放在 HTML 文档的任何地方，但一般都放在 <code>&lt;head&gt; </code>标签中。</p>
</li>
<li><p>此种写法：样式可以复用、代码结构清晰。</p>
</li>
<li><p>并没有实现：结构与样式<strong>完全分离</strong>。</p>
</li>
<li><p>多个 HTML 页面无法复用样式。</p>
</li>
</ol>
</blockquote>
<h3 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h3><ul>
<li>写在单独的<code>.CSS</code>文件中，随后在HTML文件中引入使用。</li>
<li>语法：</li>
</ul>
<p>1、新建一个扩展名为<code>.CSS</code>的样式文件，把所有CSS代码都放入此文件中。(注意这里不要把<code>&lt;style&gt;</code>标签也复制进来了)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、在HTML文件中引入<code>.CSS</code>文件。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;./xxx<span class="selector-class">.css</span>&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意</li>
</ul>
<blockquote>
<ol>
<li><code>&lt;link&gt;</code> 标签要写在&#96;&#96; <head> &#96;标签中。</li>
<li><code>&lt;link&gt;</code> 标签属性说明：</li>
</ol>
<p><code>href </code>：引入的文档来自于哪里。</p>
<p><code>rel </code>：( relation ：关系）说明引入的文档与当前文档之间的关系。</p>
<ol start="3">
<li><p>外部样式的优势：样式可以复用、结构清晰、可触发浏览器的缓存机制，提高访问速度 ，实现了<strong>结构与样式的完全分离</strong>。</p>
</li>
<li><p>实际开发中，<strong>几乎都使用外部样式</strong>，这是<strong>最推荐的使用方式！</strong></p>
</li>
</ol>
</blockquote>
<h2 id="样式表的优先级"><a href="#样式表的优先级" class="headerlink" title="样式表的优先级"></a>样式表的优先级</h2><ul>
<li>优先级规则：行内样式 &gt; 内部样式 &#x3D; 外部样式</li>
</ul>
<blockquote>
<ol>
<li>内部样式、外部样式，这二者的优先级相同，且：后面的 会覆盖 前面的（简记：“后来者居上”）。</li>
<li>同一个样式表中，优先级也和编写顺序有关，且：后面的 会覆盖 前面的（简记：“后来者居上”）。</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>优点</th>
<th>缺点</th>
<th>使用频率</th>
<th>作用范围</th>
</tr>
</thead>
<tbody><tr>
<td>行内样式</td>
<td>优先级最高</td>
<td>1、结构与样式未分离<br />2、代码结构混乱<br />3、样式不能复用<br /></td>
<td>很低</td>
<td>当前标签</td>
</tr>
<tr>
<td>内部样式</td>
<td>1、样式可以复用<br />2、代码结构清晰<br /></td>
<td>1、结构与样式未彻底分离<br />2、样式不能跨页面复用<br /></td>
<td>一般</td>
<td>当前页面</td>
</tr>
<tr>
<td>外部样式</td>
<td>1、样式可多页面复用<br />2、代码结构清晰<br />3、可触发浏览器缓存机制<br />4、结构与样式彻底分离<br /></td>
<td>需要引入才能使用</td>
<td>常用</td>
<td>多个页面</td>
</tr>
</tbody></table>
<h2 id="CSS-代码风格"><a href="#CSS-代码风格" class="headerlink" title="CSS 代码风格"></a>CSS 代码风格</h2><ul>
<li>展开风格</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>紧凑风格——项目上线时再使用，可以减小文件体积。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">color</span>:red;<span class="attribute">font-size</span>:<span class="number">40px</span>;&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>备注</li>
</ul>
<blockquote>
<p>项目上线时，我们会通过工具将【展开风格】的代码，变成【紧凑风格】，这样可以减小文件体积，节约网络流量，同时也能让用户打开网页时速度更快。</p>
</blockquote>
<h1 id="CSS-选择器"><a href="#CSS-选择器" class="headerlink" title="CSS 选择器"></a>CSS 选择器</h1><h2 id="CSS-基本选择器"><a href="#CSS-基本选择器" class="headerlink" title="CSS 基本选择器"></a>CSS 基本选择器</h2><ul>
<li>通配选择器</li>
<li>元素选择器</li>
<li>类选择器</li>
<li>ID选择器</li>
</ul>
<h3 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h3><ul>
<li><p>作用：选中所有的 <code>HTML</code> 元素。</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">    属性名：属性值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有的元素，设置颜色与字体大小 */</span></span><br><span class="line">*&#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>通配选择器一般用的不多。但是在后续清除样式时可以有很大帮助。</p>
</blockquote>
<h3 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h3><ul>
<li><p>作用：为页面中 <strong>某种元素</strong> 统一设置样式。</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">标签名&#123;</span><br><span class="line">    属性名：属性值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 为所有 h1 元素设置颜色与字体大小*/</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 为所有的 p 元素设置颜色与字体大小 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">60px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>元素选择器无法实现同一种元素的差异化设置，例如上述代码中，所有 <code>p</code> 元素的效果都是一样的。</p>
</blockquote>
<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><ul>
<li>作用：根据元素的 <code>class</code> 值，来选中某些元素。</li>
</ul>
<p>这里的<code>class</code>就是元素的类名。</p>
<ul>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">.类名 &#123;</span><br><span class="line">    属性名：属性值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选择所有class值为speak的元素 */</span></span><br><span class="line"><span class="selector-class">.speak</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 选择class值为answer的元素 */</span></span><br><span class="line"><span class="selector-class">.answer</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ol>
<li><p>CSS的类选择器选择元素的<code>class</code>属性时要在<code>class</code>的值前带一个<code>.</code>。</p>
</li>
<li><p><code>class</code>值，是自己创建元素时自己定义的。按照标准：不要使用纯数字、不要使用中文、尽量使用英文与数字的组合，若由多个单词组成，使用 - 做连接，例如： left-menu ，且命名要有意义，做到 “见名知意”。</p>
</li>
<li><p>一个元素中不能写多个<code>class</code>属性，下面是错误示例:</p>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;&lt;!-- 该写法错误，元素的属性不能重复，后写的会失效 --&gt;</span><br><span class="line">&gt;&lt;<span class="selector-tag">h1</span> class=&quot;<span class="attribute">speak</span>&quot; class=&quot;big&quot;&gt;你好啊&lt;/<span class="selector-tag">h1</span>&gt;</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>一个元素的<code>class</code>属性可以有多个值，要使用空格隔开，例如：</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;&lt;!-- 该写法正确，class属性，能写多个值 --&gt;</span><br><span class="line">&gt;&lt;<span class="selector-tag">h1</span> class=&quot;<span class="attribute">speak</span> big&quot;&gt;你好啊&lt;/<span class="selector-tag">h1</span>&gt;</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><ul>
<li><p>作用：根据元素的<code>id</code>属性值来精准的选择某一个元素。</p>
</li>
<li><p>语法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#id</span>值 &#123;</span><br><span class="line">    属性名：属性值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中 id 值为 earthy 的那个元素 */</span></span><br><span class="line"><span class="selector-id">#earthy</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<ul>
<li><code>id</code>属性值：尽量由<strong>字母、数字、下划线、短横线</strong>组成，最好以字母开头，不要包含空格、区分大小写。</li>
<li>一个元素只能有一个<code>id</code>属性，并且<code>id</code>的值要唯一。<code>id</code>的值就类似人的身份证号，具有一 一对应。</li>
<li>一个元素可以同时拥有<code>id</code>、<code>class</code>属性。</li>
</ul>
</blockquote>
<h3 id="基本选择器总结"><a href="#基本选择器总结" class="headerlink" title="基本选择器总结"></a>基本选择器总结</h3><table>
<thead>
<tr>
<th>基本选择器</th>
<th>特点</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>通配选择器</td>
<td>选中所有元素，一般用于清除样式。</td>
<td><code>*&#123;color:red&#125;</code></td>
</tr>
<tr>
<td>元素选择器</td>
<td>选中所有同种标签，但是不能差异化选择。</td>
<td><code>h1 &#123;color:red&#125;</code></td>
</tr>
<tr>
<td>类选择器</td>
<td>选择所有特定类名（<code>class</code>值）的元素——&#x3D;&#x3D;使用频率很高&#x3D;&#x3D;。</td>
<td><code>.say&#123;color:red&#125;</code></td>
</tr>
<tr>
<td>ID 选择器</td>
<td>选中特定 id 值的那个元素。</td>
<td><code>#earthy&#123;color:red&#125;</code></td>
</tr>
</tbody></table>
<h2 id="CSS-复合选择器"><a href="#CSS-复合选择器" class="headerlink" title="CSS 复合选择器"></a>CSS 复合选择器</h2><blockquote>
<ol>
<li>复合选择器建立在基本选择器之上，由多个基础选择器通过不同方式组合而成。</li>
<li>符合选择器可以在复杂结构中快速而准确的选中元素。</li>
</ol>
</blockquote>
<p>1️⃣交集选择器</p>
<p>2️⃣并集选择器</p>
<p>3️⃣后代选择器</p>
<p>4️⃣子元素选择器</p>
<p>……</p>
<h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><ul>
<li><p>作用：选中<strong>同时符合</strong>多个条件的元素。</p>
</li>
<li><p>语法：选择器1选择器2选择器3…选择器n{ }</p>
</li>
<li><p>举例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中：类名为beauty的p元素，此种写法用的非常多！ */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-class">.beauty</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中：类名包含rich和beauty的元素 */</span></span><br><span class="line"><span class="selector-class">.rich</span><span class="selector-class">.beauty</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>并集条件中有标签名时，标签名必须写前面。</li>
<li><code>id</code>选择器通常不作为选择器的条件，因为<code>id</code>一个人就能确定指定元素。</li>
<li>交集选择器中不可能出现两个元素选择器，因为一个元素不可能既是<code>p</code>元素又是<code>h</code>元素。</li>
<li>用的最多的交集选择器是：元素选择器配合类名选择器，例如：<code>p.beauty</code></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="并集选择器"><a href="#并集选择器" class="headerlink" title="并集选择器"></a>并集选择器</h3><ul>
<li><p>作用：选中多个选择器对应的元素，又称：<strong>分组选择器</strong>。</p>
</li>
<li><p>语法：选择器1，选择器2，选择器3，…选择器n { }</p>
<blockquote>
<p>多个选择器通过<code>,</code>连接，此处的<code>，</code>就是：<code>或</code>。</p>
</blockquote>
</li>
<li><p>举例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中id为peiqi，或类名为rich，或类名为beauty的元素 */</span></span><br><span class="line"><span class="selector-id">#peiqi</span>,</span><br><span class="line"><span class="selector-class">.rich</span>,</span><br><span class="line"><span class="selector-class">.beauty</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">background-color</span>: skyblue;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>并集选择器我们一般竖着写。</li>
<li>任何形式的选择器都可以作为并集选择器的一部分。</li>
<li>并集选择器，通常用于集体声明，可以缩小样式表体积。</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="HTML元素间的关系"><a href="#HTML元素间的关系" class="headerlink" title="HTML元素间的关系"></a>HTML元素间的关系</h3><p>1️⃣父元素；2️⃣子元素；3️⃣祖先元素；4️⃣后代元素；5️⃣兄弟元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎阅读我的博客<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>笔记<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>资源<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>思维<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>高中化学<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>父元素</code>：&#x3D;&#x3D;直接&#x3D;&#x3D;包裹某个元素的元素，就是该元素的父元素。</p>
<p><code>子元素</code>：被父元素直接包含的元素。</p>
<p><code>祖先元素</code>：父亲的的父亲….，一直往外找，都是祖先。</p>
<p><code>后代元素</code>：儿子的儿子……，一直往里找，都是后代。</p>
<p><code>兄弟元素</code>：具有相同父元素的元素，互为兄弟元素。</p>
<blockquote>
<p>父元素也算是祖先元素的一种，但一般还是称父元素。</p>
<p>同理，子元素也是后代元素的一种。</p>
</blockquote>
<h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><ul>
<li><p>作用：选定指定元素中，符合要求的后代元素。</p>
</li>
<li><p>语法：选择器1 [空格] 选择器2 [空格]…选择器n { }  (先写祖先，再写后代)</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 选择器之间，用空格隔开，空格可以理解为：&quot; xxx 中的&quot;，其实就是后代的意思。</span><br><span class="line"><span class="number">2</span>. 选择器 <span class="number">1234</span>...<span class="selector-class">.n</span> ，可以是我们之前学的任何一种选择器。</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中ul中的所有li */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中ul中所有li中的a */</span></span><br><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中类名为subject元素中的所有li */</span></span><br><span class="line"><span class="selector-class">.subject</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 选中类名为subject元素中的所有类名为front-end的li */</span></span><br><span class="line"><span class="selector-class">.subject</span> <span class="selector-tag">li</span> <span class="selector-class">.front-end</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>后代选择器，最终选择的是后代，不选中祖先。</li>
<li>儿子、孙子、重孙子，都算是后代。</li>
<li>结构一定要符合之前讲的 HTML 嵌套要求，例如：不能 p 中写 h1 ~ h6 。</li>
</ol>
</blockquote>
<h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><ul>
<li>作用：选中指定元素中，符合要求的子元素。（先写父，再写子）。</li>
</ul>
<blockquote>
<p>子代选择器又称：子元素选择器、子选择器。</p>
</blockquote>
<ul>
<li><p>语法：选择器1&gt;选择器2&gt;选择器3&gt;……选择器n {  }</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器之间，用 &gt; 隔开， &gt; 可以理解为：&quot; xxx 的子代&quot;，其实就是儿子的意思。</span><br><span class="line">选择器 <span class="number">1234</span>...<span class="selector-class">.n</span> ，可以是我们之前学的任何一种选择器。</span><br></pre></td></tr></table></figure>


</li>
<li><p>举例</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* div中的子代a元素 */</span></span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">a</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 类名为persons的元素中的子代a元素 */</span></span><br><span class="line"><span class="selector-class">.persons</span>&gt;<span class="selector-tag">a</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>子代选择器，最终选择的是子代，不是父级。</li>
<li>子、孙子、重孙子、重重孙子 …… 统称后代！，<strong>子</strong>就是指<strong>儿子</strong>。</li>
</ol>
</blockquote>
<h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><ul>
<li><p>相邻兄弟选择器</p>
<ul>
<li>作用：选中指定元素后，符合条件的<strong>相邻兄弟</strong>元素。</li>
</ul>
<blockquote>
<p>所谓相邻，就是<strong>紧挨着</strong>他的下一个，简记：睡在我下铺的兄弟。</p>
</blockquote>
<ul>
<li><p>语法：选择器1+选择器2 {  } 。</p>
</li>
<li><p>示例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中div后相邻的兄弟p元素 */</span></span><br><span class="line"><span class="selector-tag">div</span>+<span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通用兄弟选择器</p>
<ul>
<li><p>作用：选中指定元素后，符合条件的<strong>所有兄弟</strong>元素。（简记：睡在我下铺的所有兄弟）</p>
</li>
<li><p>语法：选择器1~选择器2 {  }</p>
</li>
<li><p>示例</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中div后的所有的兄弟p元素 */</span></span><br><span class="line"><span class="selector-tag">div</span>~<span class="selector-tag">p</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<blockquote>
<p>这两种兄弟选择器，选择的是<strong>下面</strong>的兄弟。</p>
</blockquote>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ul>
<li>作用：选中属性值符合一定要求的元素。</li>
<li>语法：<ol>
<li><code>[属性名]</code> 选中<strong>具有</strong>某个属性的元素。</li>
<li><code>[属性名=&quot;值&quot;]</code> 选中包含某个属性，且属性值<strong>等于</strong>指定值的元素。</li>
<li><code>[属性名^=&quot;值&quot;]</code> 选中包含某个属性，且属性值以指定的值<strong>开头</strong>的元素。</li>
<li><code>[属性名$=&quot;值&quot;]</code> 选中包含某个属性，且属性值以指定的值<strong>结尾</strong>的元素。</li>
<li><code>[属性名*=“值”]</code> 选择包含某个属性，属性值<strong>包含</strong>指定值的元素。</li>
</ol>
</li>
<li>举例</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 选中具有title属性的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title]</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="comment">/* 选中title属性值为atguigu的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title=<span class="string">&quot;atguigu&quot;</span>]</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="comment">/* 选中title属性值以a开头的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title^=<span class="string">&quot;a&quot;</span>]</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="comment">/* 选中title属性值以u结尾的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title$=<span class="string">&quot;u&quot;</span>]</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br><span class="line"><span class="comment">/* 选中title属性值包含g的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[title*=<span class="string">&quot;g&quot;</span>]</span>&#123;<span class="attribute">color</span>:red;&#125;</span><br></pre></td></tr></table></figure>



<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><ul>
<li>作用：选中特殊状态的元素。</li>
</ul>
<blockquote>
<p>如何理解“伪” ? — 虚假的，不是真的。</p>
<p>如何理解“伪类”？ — 像类( class )，但不是类，是元素的一种特殊状态。</p>
</blockquote>
<ul>
<li><p>常用的伪类选择器</p>
<p>一、动态伪类</p>
<p>二、结构伪类</p>
<p>三、否定伪类</p>
<p>四、UI伪类</p>
<p>五、目标伪类（了解）</p>
<p>六、语言伪类（了解）</p>
</li>
</ul>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><h2 id="选择器的优先级（权重）"><a href="#选择器的优先级（权重）" class="headerlink" title="选择器的优先级（权重）"></a>选择器的优先级（权重）</h2><hr>
<h1 id="CSS-三大特性"><a href="#CSS-三大特性" class="headerlink" title="CSS 三大特性"></a>CSS 三大特性</h1><h2 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h2><p>如果发生了样式冲突，那就会根据一定的规则（选择器优先级），进行样式的层叠（覆盖）。</p>
<blockquote>
<p>什么是样式冲突？ ——— 元素的同一个样式名，被设置了不同的值，这就是冲突。</p>
</blockquote>
<h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><h1 id="CSS-常用属性"><a href="#CSS-常用属性" class="headerlink" title="CSS 常用属性"></a>CSS 常用属性</h1><h1 id="CSS-盒子模型"><a href="#CSS-盒子模型" class="headerlink" title="CSS 盒子模型"></a>CSS 盒子模型</h1><h1 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h1><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>DFX工作台脚本-使用步骤</title>
    <url>//blog/note/software-use/DFX-GZT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h1 id="这脚本用来干什么的"><a href="#这脚本用来干什么的" class="headerlink" title="这脚本用来干什么的"></a>这脚本用来干什么的</h1><p>自动完成发放课后作业（1张试卷），给当前【开课中】及【未开课】的学生。</p>
<p>共计发送<code>5次</code>。</p>
<p>预计此脚本，每天能为您节省<code>420秒</code>。</p>
<hr>
<h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><h2 id="安装浏览器插件——油猴（共6步）"><a href="#安装浏览器插件——油猴（共6步）" class="headerlink" title="安装浏览器插件——油猴（共6步）"></a>安装浏览器插件——油猴（共6步）</h2><p>这里以<code>Windows</code>系统自带的<code>Edge</code>浏览器为例。谷歌浏览器的安装步骤类似。</p>
<p>1、下载浏览器——油猴插件</p>
<p><a href="https://dlink.host/sharepoint/aHR0cHM6Ly8ycDQwenAtbXkuc2hhcmVwb2ludC5jb20vOnU6L2cvcGVyc29uYWwvemhvbmd5dWFuXzJwNDB6cF9vbm1pY3Jvc29mdF9jb20vRWMtd3pfdmxZTnBNdHQ0djVUX3FILVVCTDBaZnRuS0lBV1puWmY0U2tHUm41dz9lPXZvYkd0Sw.crx">点我下载</a></p>
<p>2、安装油猴插件</p>
<ul>
<li>①点击<code>Edge</code>浏览器右上角的<code>设置</code>（即图中所示：三个小圆点）</li>
</ul>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hu2gk1f7x4j31e70u0aji.jpg "  style="zoom:50%;" />

<ul>
<li>②点击<code>扩展</code></li>
</ul>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hu2gm10tdcj30ki11i77m.jpg "  style="zoom:30%;" />

<ul>
<li>③点击<code>管理扩展</code></li>
</ul>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hu2gmqrzxvj30wz0ie0va.jpg "  style="zoom:40%;" />

<ul>
<li>④打开<code>开发者人员模式</code>的开关</li>
</ul>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hu2gnbq01wj31mq0u07ag.jpg "  style="zoom:50%;" />

<ul>
<li>⑤打开刚下载的插件所在的文件夹，将刚刚下载的这个插件按住鼠标不松，拖放到浏览器这个界面，浏览器会有提示，再松开鼠标，插件就可以安装了。</li>
</ul>
<img src=" https://dlink.host/wx4.sinaimg.cn/large/007ERWx2ly8hu2go7q0vjj31lc0u0795.jpg "  style="zoom:50%;" />

<ul>
<li>⑥在弹出的新窗口中，点击<code>添加扩展</code></li>
</ul>
<img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hu2gqxp8l9j315l0u0794.jpg "  style="zoom:40%;" />

<p>至此第一步<strong>油猴插件</strong>就安装完毕。</p>
<hr>
<h2 id="安装脚本（共2步）"><a href="#安装脚本（共2步）" class="headerlink" title="安装脚本（共2步）"></a>安装脚本（共2步）</h2><p><a href="https://greasyfork.org/zh-CN/scripts/510404-dfx%E5%B7%A5%E4%BD%9C%E5%8F%B0%E5%8A%A9%E6%89%8B">点我去脚本网址</a></p>
<ul>
<li>①打开上面的脚本网址，界面如下图所示，点击<code>安装此脚本</code></li>
</ul>
<img src=" https://dlink.host/wx2.sinaimg.cn/large/007ERWx2ly8hu2gt7i0i4j31oj0u0tg0.jpg "  style="zoom:50%;" />

<ul>
<li>②在新窗口中，点击<code>安装</code></li>
</ul>
<img src=" https://dlink.host/wx1.sinaimg.cn/large/007ERWx2ly8hu2grnvbtrj31u90u046m.jpg "  style="zoom:50%;" />

<p>至此脚本安装也结束了。</p>
<hr>
<h2 id="启动-使用脚本"><a href="#启动-使用脚本" class="headerlink" title="启动&#x2F;使用脚本"></a>启动&#x2F;使用脚本</h2><ul>
<li><a href="https://we.xdf.cn/main/home">打开高中工作台 </a></li>
</ul>
<p>如下图所示，安装脚本后，网页中会出现一个<code>绿色的小太阳</code>，可以随意拖放，双击<code>绿色小太阳</code>即可启动脚本。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8hu2gx7gzcqj30gz0mljsm.jpg "  style="zoom:30%;" />

<ul>
<li>使用的注意事项</li>
</ul>
<blockquote>
<p>1、脚本启动前，网页必须在“高中工作台”的<a href="https://we.xdf.cn/main/home">首页</a>，然后再双击启动脚本。</p>
<p>因为脚本的第一步是去点击“试卷库”，脚本找不到试卷库，脚本会自动停止。</p>
<p>2、脚本运行中，鼠标只要不要去点击浏览器，随便你去什么事情都可以。</p>
<p>3、如果想运行到中途，终止脚本，刷新网页即可，或者直接关闭网页重新打开都可以。</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记</category>
        <category>software-use</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>Freeplane思维导图软件的使用教程</title>
    <url>//blog/note/software-use/Freeplane-how-to-use.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Freeplane使用教程"><a href="#Freeplane使用教程" class="headerlink" title="Freeplane使用教程"></a>Freeplane使用教程</h1><p><a href="https://sourceforge.net/projects/freeplane/">下载地址</a></p>
<p><strong>Freeplane的核心功能</strong></p>
<img src=" https://pic2.zhimg.com/80/v2-6a04ac285e66cd2fbe4f5d821b205905_1440w.webp " alt="Freeplane的核心功能" style="zoom:50%;" />



]]></content>
      <categories>
        <category>笔记</category>
        <category>软件使用教程</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记（1）基础知识</title>
    <url>//blog/note/code/JavaScript1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考学习链接：<a href="https://zh.javascript.info/">https://zh.javascript.info/</a></p>
<h1 id="关于-JavaScript-的一些基本常识"><a href="#关于-JavaScript-的一些基本常识" class="headerlink" title="关于 JavaScript 的一些基本常识"></a>关于 JavaScript 的一些基本常识</h1><h2 id="如何把代码运行的结果显示出来？"><a href="#如何把代码运行的结果显示出来？" class="headerlink" title="如何把代码运行的结果显示出来？"></a>如何把代码运行的结果显示出来？</h2><ul>
<li>方法一  浏览器弹窗 alert、prompt 和 confirm</li>
</ul>
<p><code>alert</code> 它会显示一条信息，并等待用户按下 “OK”。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>弹出的这个带有信息的小窗口被称为 <strong>模态窗</strong>。“modal” 意味着用户不能与页面的其他部分（例如点击其他按钮等）进行交互，直到他们处理完窗口。在上面示例这种情况下 —— 直到用户点击“确定”按钮。</p>
<p><code>prompt</code> 函数接收两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = <span class="title function_">prompt</span>(title, [<span class="keyword">default</span>]);</span><br></pre></td></tr></table></figure>

<p>浏览器会显示一个带有文本消息的模态窗口，还有 input 框和确定&#x2F;取消按钮。</p>
<ul>
<li><p><code>title</code></p>
<p>显示给用户的文本</p>
</li>
<li><p><code>default</code></p>
<p>可选的第二个参数，指定 input 框的初始值。</p>
</li>
</ul>
<p>访问者可以在提示输入栏中输入一些内容，然后按“确定”键。然后我们在 <code>result</code> 中获取该文本。或者他们可以按取消键或按 Esc 键取消输入，然后我们得到 <code>null</code> 作为 <code>result</code>。</p>
<p><code>prompt</code> 将返回用户在 <code>input</code> 框内输入的文本，如果用户取消了输入，则返回空值 <code>null</code>。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = <span class="title function_">confirm</span>(question);</span><br></pre></td></tr></table></figure>

<p><code>confirm</code> 函数显示一个带有 <code>question</code> 以及确定和取消两个按钮的模态窗口。</p>
<p>点击确定返回 <code>true</code>，点击取消返回 <code>false</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoss = <span class="title function_">confirm</span>(<span class="string">&quot;Are you the boss?&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>( isBoss ); <span class="comment">// 如果“确定”按钮被按下，则显示 true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>方法二  控制台日志 console.log</li>
</ul>
<p>推荐使用方法二。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>+<span class="number">2</span>); <span class="comment">//输出 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你好&quot;</span>); <span class="comment">//输出 你好</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>//</code> ：单行注释，在双斜杠的后面的语句全部被当作注释，机器不会翻译，给人看的。</p>
<p><code>/*   */</code> ：这两个符号之间的内容全部被当作注释。与上面双斜杠不同的是，这个适用于多行注释。</p>
<h2 id="现代模式-严格模式-use-strict"><a href="#现代模式-严格模式-use-strict" class="headerlink" title="现代模式&#x2F;严格模式 use strict"></a>现代模式&#x2F;严格模式 <code>use strict</code></h2><ul>
<li>我暂时不清楚它的用途。等将来懂了再回来填坑。</li>
<li>用法</li>
</ul>
<p>全文启动严格模式：将 <code>&quot;use strict&quot;</code> 语句放在整个 <code>JavaScript</code> 文件的第一行。不放在第一行，是无效的。</p>
<p>严格模式一旦开启，没有回头路，只能手动删除语句才能关闭。</p>
<ul>
<li>备注</li>
</ul>
<p>现代 JavaScript 支持 “class” 和 “module” —— 高级语言结构（本教程后续章节会讲到），它们会自动启用 <code>use strict</code>。因此，如果我们使用它们，则无需添加 <code>&quot;use strict&quot;</code> 指令。</p>
<h2 id="三种特殊值"><a href="#三种特殊值" class="headerlink" title="三种特殊值"></a>三种特殊值</h2><p>在 JavaScript 中，<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都是表示“无”或“不是值”的特殊值，但它们各自有不同的用途和含义：</p>
<ol>
<li><p>**<code>null</code>**：</p>
<ul>
<li><code>null</code> 是一个故意设计的值，用来表示变量的空值（empty value）。</li>
<li>它代表一个空对象指针，即没有任何对象可以指向。</li>
<li>通常用来表示一个变量没有指向任何对象，或者一个函数没有返回任何对象。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>undefined</code>**：</p>
<ul>
<li><code>undefined</code> 表示一个变量已被声明，但没有被赋值。</li>
<li>它表示变量当前没有值。</li>
<li>当函数没有返回值时，也会默认返回 <code>undefined</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVar); <span class="comment">// 输出: undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>**<code>NaN</code>**：</p>
<ul>
<li><code>NaN</code> 表示一个非数值（Not-a-Number）。</li>
<li>它是一个特殊的值，用来表示一个不可能的或未定义的数学运算结果。</li>
<li>任何涉及 <code>NaN</code> 的操作都会返回 <code>NaN</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myVar = <span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myVar); <span class="comment">// 输出: NaN</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>区别</p>
<ul>
<li><p><strong>类型</strong>：</p>
<ul>
<li><code>null</code> 是 <code>Object</code> 类型，尽管它表示空值。</li>
<li><code>undefined</code> 是 <code>Undefined</code> 类型。</li>
<li><code>NaN</code> 是 <code>Number</code> 类型，尽管它表示非数值。</li>
</ul>
</li>
<li><p><strong>使用场景</strong>：</p>
<ul>
<li><code>null</code> 通常用于表示空值或故意设置为“无”的情况。</li>
<li><code>undefined</code> 通常用于表示变量尚未初始化。</li>
<li><code>NaN</code> 用于表示数学运算的无效结果。</li>
</ul>
</li>
<li><p><strong>相等性</strong>：</p>
<ul>
<li><code>null</code> 和 <code>undefined</code> 相等，因为 <code>null == undefined</code> 返回 <code>true</code>。</li>
<li><code>NaN</code> 不等于任何值，包括它自己，即 <code>NaN == NaN</code> 返回 <code>false</code>。</li>
</ul>
</li>
<li><p><strong>转换</strong>：</p>
<ul>
<li>当 <code>null</code> 和 <code>undefined</code> 参与运算时，它们会被转换为 <code>0</code>。</li>
<li><code>NaN</code> 在运算时通常会导致结果为 <code>NaN</code>。</li>
</ul>
</li>
</ul>
<p>检查</p>
<ul>
<li>使用 <code>typeof</code> 运算符可以区分 <code>null</code> 和 <code>undefined</code>，因为 <code>typeof null</code> 返回 <code>&quot;object&quot;</code>（这是一个历史遗留问题），而 <code>typeof undefined</code> 返回 <code>&quot;undefined&quot;</code>。</li>
<li>使用 <code>isNaN()</code> 函数可以检查一个值是否为 <code>NaN</code>，但要注意它会把非数字字符串转换为 <code>NaN</code>，所以最好与 <code>typeof</code> 结合使用，或者使用 <code>Number.isNaN()</code> 方法进行严格检查。</li>
</ul>
<p>在编程时，应该根据具体场景选择合适的值来表示“无”或“未定义”的状态。</p>
<hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>在 JS 中，所有可以由我们自主命名的内容，都可以认为是一个 <strong>标识符</strong>，像 <code>变量名</code> <code>函数名</code> <code>类名</code>…</p>
<p>使用 <code>变量名</code> 需要遵循如下的命名规范：</p>
<p><code>变量名</code> 只能含有 <strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>、**$**，且不能以数字开头。</p>
<p>例如，定义一个变量，名字为 <code>QQ</code>，它的值为 <code>123456</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable constant_">QQ</span> = <span class="string">&quot;123456&quot;</span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>一般使用 <strong>驼峰命名法</strong> 为变量命名</li>
</ul>
<p>第一个单词小写，后面每个单词开头大写，例如 <code>myName</code>、<code>myVeryLongName</code>。</p>
<ul>
<li>在 <code>JavaScript</code> 中，严格区分大小写。</li>
<li>常量命名时，字母一般全部大写。</li>
</ul>
<p>例如，众所周知，圆周率 <code>PI</code> 约等于 <code>3.14</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PI</span> = <span class="string">&quot;3.14&quot;</span> ;</span><br></pre></td></tr></table></figure>

<p>例如定义某人的生日，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">BIRTHDAY</span> = <span class="string">&quot;2000.10.1&quot;</span></span><br></pre></td></tr></table></figure>



<p>有一些英文单词被 <code>JavaScript</code> 官方已经使用，你不能再使用，这种被称作 <code>保留字</code> 。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Lexical_grammar#%E4%BF%9D%E7%95%99%E5%AD%97">保留字 | MDN</a></p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p><code>JavaScript</code> 中共计 <code>8</code> 种数据类型，其中 <code>7</code> 种是原始数据类型，最后 <code>1</code> 种是数据结构（也称作 <code>对象object</code>）。</p>
<h2 id="文本串类型"><a href="#文本串类型" class="headerlink" title="文本串类型"></a>文本串类型</h2><h3 id="引号-（quotes）"><a href="#引号-（quotes）" class="headerlink" title="引号 （quotes）"></a>引号 （quotes）</h3><p>​	在 js 中的文本串，可以被 <code>单引号</code>、<code>双引号</code>、<code>反引号</code> 进行插入使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wenben = <span class="string">&#x27;你好，世界&#x27;</span> ;	<span class="comment">//单引号插入文本</span></span><br><span class="line"><span class="keyword">let</span> wenben1 = <span class="string">&quot;你好啊，世界&quot;</span> ; <span class="comment">// 双引号插入文本</span></span><br><span class="line"><span class="keyword">let</span> wenben2 = <span class="string">`你好，世界啊`</span> ; <span class="comment">// 反引号插入文本</span></span><br></pre></td></tr></table></figure>

<p>其中，单引号和双引号的作用一模一样。<strong>反引号</strong> 可以把语法类似这种的 <code>$&#123; 代码 &#125;</code> 代码插入文本串中进行运行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`我的名字是 <span class="subst">$&#123; <span class="number">660</span> +<span class="number">6</span> &#125;</span>`</span>);  <span class="comment">//输出 我的名字是 666</span></span><br></pre></td></tr></table></figure>

<p><strong>反引号</strong> 还能允许文本串自带 <strong>换行</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`</span></span><br><span class="line"><span class="string">你好，</span></span><br><span class="line"><span class="string">世界。</span></span><br><span class="line"><span class="string">学习使我快乐。</span></span><br><span class="line"><span class="string">`</span>);	</span><br><span class="line"><span class="comment">//输出的文字照样带换行的效果</span></span><br></pre></td></tr></table></figure>

<p>单引号和双引号来自语言创建的古老时代，当时没有考虑到多行字符串的需要。反引号出现较晚，因此更通用。</p>
<h3 id="特殊字符-转义字符"><a href="#特殊字符-转义字符" class="headerlink" title="特殊字符  &#x2F; 转义字符"></a>特殊字符  &#x2F; 转义字符</h3><p>所有的特殊字符都以反斜杠字符 <code>\</code> 开始。它也被称为“转义字符”。</p>
<p>反斜杠 <code>\</code> 在 JavaScript 中用于正确读取 <strong>字符串</strong>，然后消失。内存中的字符串没有 <code>\</code>。</p>
<p>所以要想显示转义字符的效果，记得使用引号将转义字符括住。</p>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\n</code></td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left"><code>\&#39;</code>, <code>\&quot;</code></td>
<td align="left">引号</td>
</tr>
<tr>
<td align="left"><code>\\</code></td>
<td align="left">反斜线</td>
</tr>
<tr>
<td align="left"><code>\t</code></td>
<td align="left">制表符</td>
</tr>
<tr>
<td align="left"><code>\xXX</code></td>
<td align="left">具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>&#39;\x7A&#39;</code> 和 <code>&#39;z&#39;</code> 相同。</td>
</tr>
<tr>
<td align="left"><code>\uXXXX</code></td>
<td align="left">以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 Unicode 字符，例如 <code>\u00A9</code> —— 是版权符号 <code>©</code> 的 Unicode。它必须正好是 4 个十六进制数字。</td>
</tr>
<tr>
<td align="left"><code>\u&#123;X…XXXXXX&#125;</code>（1 到 6 个十六进制字符）</td>
<td align="left">具有给定 UTF-32 编码的 Unicode 符号。一些罕见的字符用两个 Unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello\nWorld&quot;</span>); <span class="comment">// Hello 和 World 中间的 \n 相当于换行</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello&#x27;</span> + <span class="string">&#x27;\n&#x27;</span> + <span class="string">&#x27;World&#x27;</span>);<span class="comment">// Hello 和 World 中间的 \n 相当于换行。加号用于连接字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello\&quot;World&quot;</span>); <span class="comment">// Hello 和 World中间的 \&quot; 相当于引号&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello\&#x27;World&quot;</span>); <span class="comment">// Hello 和 World中间的 \&#x27; 相当于引号&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello\\World&quot;</span>); <span class="comment">// Hello 和 World中间的 \\ 相当于反斜线\</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello\tWorld&quot;</span>);   <span class="comment">// Hello 和 World中间的 \t 相当于制表符,相当于按下了一次tab键</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\x7A&#x27;</span>); <span class="comment">// 十六进制 Unicode 字符，输出 z</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u00A9&#x27;</span>);  <span class="comment">// UTF-16 编码的十六进制 Unicode 字符，输出 ©</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u&#123;1F60D&#125;&#x27;</span>); <span class="comment">// UTF-32 编码的十六进制 Unicode 字符，输出 😍</span></span><br></pre></td></tr></table></figure>



<h3 id="字符串长度-length"><a href="#字符串长度-length" class="headerlink" title="字符串长度 length"></a>字符串长度 length</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wenben = <span class="string">&quot;abcde&quot;</span> ;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wenben.<span class="property">length</span>);  <span class="comment">//输出 5</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你好世界&quot;</span>.<span class="property">length</span>) <span class="comment">//输出 4</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你好\n世界&quot;</span>.<span class="property">length</span>)  ; <span class="comment">// 输出 5， 因为换行符(\n)占一个字符</span></span><br></pre></td></tr></table></figure>



<h3 id="访问字符"><a href="#访问字符" class="headerlink" title="访问字符"></a>访问字符</h3><p>代码格式 <code>string[i]</code>，代表访问字符串 string 的第 <code>i+1</code> 个字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wenben = <span class="string">&quot;你好世界&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wenben[<span class="number">0</span>]); <span class="comment">//输出 &quot;你&quot;    0 代表第一个文本，1 代表第二个文本，以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(wenben[<span class="number">3</span>]);  <span class="comment">//输出 &quot;界&quot;    3 代表第四位的文本</span></span><br></pre></td></tr></table></figure>



<p>遍历文本 <code>对字符串中的每一个字符进行逐个访问的过程</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wenben = <span class="string">&quot;你好世界&quot;</span> ;</span><br><span class="line"><span class="comment">//下面使用两种方法进行依次输出 变量【wenben】中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; wenben.<span class="property">length</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(wenben[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接下来换另一种方法进行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法 2</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> text <span class="keyword">of</span> wenben )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="property">log</span> (text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会发现方法 2 更简洁。是的，在 JavaScript 中常用 <code>for ... of </code> 循环来遍历字符串、数组等。</p>
<h3 id="字符串是不可变的"><a href="#字符串是不可变的" class="headerlink" title="字符串是不可变的"></a>字符串是不可变的</h3><p>在 JavaScript 中，字符串不可更改。改变字符是不可能的。</p>
<p>我们证明一下为什么不可能：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>; <span class="comment">// error</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str[<span class="number">0</span>] ); <span class="comment">// 无法运行</span></span><br></pre></td></tr></table></figure>
<p>通常的解决方法是创建一个新的字符串，并将其分配给 str 而不是以前的字符串。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hi&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;h&#x27;</span> + str[<span class="number">1</span>];  <span class="comment">// 替换字符串</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str ); <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>
<p>在接下来的章节，我们将看到更多相关示例。</p>
<h3 id="字母大小写转换"><a href="#字母大小写转换" class="headerlink" title="字母大小写转换"></a>字母大小写转换</h3><p><code>[toLowerCase()</code>] 和 <code> [toUpperCase()]</code> 方法可以改变字符串中英文字母的大小写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> wenben = <span class="string">&quot;你好,世jie&quot;</span> ;</span><br><span class="line"><span class="keyword">let</span> wenben1 = <span class="string">&quot;NiHao,shiJie&quot;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;你好,世jie&#x27;</span>.<span class="title function_">toUpperCase</span>() ); <span class="comment">// 你好, 世 JIE</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;NiHao,shiJie&#x27;</span>.<span class="title function_">toLowerCase</span>() ); <span class="comment">// nihao, shijie</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( wenben.<span class="title function_">toUpperCase</span>() ); <span class="comment">// 你好, 世 JIE</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( wenben1.<span class="title function_">toLowerCase</span>() ); <span class="comment">// nihao, shijie</span></span><br></pre></td></tr></table></figure>





<h3 id="在字符串查找是否包含另一个字符串"><a href="#在字符串查找是否包含另一个字符串" class="headerlink" title="在字符串查找是否包含另一个字符串"></a>在字符串查找是否包含另一个字符串</h3><p>此功能又称为 <strong>”在字符串中查找子字符串“</strong>。</p>
<p>在 JavaScript 中，有很多方法能实现这个功能。</p>
<ul>
<li>老旧方法    str.indexOf(substring, pos)</li>
</ul>
<p>它从给定位置 <code>pos</code> 开始(默认从左向右)，在 <code>str</code> 中查找 <code>substr</code>，如果没有找到，则返回 <code>-1</code>，否则返回匹配成功的位置。</p>
<p>第二个参数 pos 是可选的，不加 pos，默认从头开始匹配，返回第一次匹配成功的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;这是一个测试字符串，测试一下，看看是否能找到所有的测试。&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> substring = <span class="string">&quot;测试&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> index = str.<span class="title function_">indexOf</span>(substring);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(index); <span class="comment">// 输出第一次找到“测试”的位置   4</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;这是一个测试字符串，测试一下，看看是否能找到所有的测试。&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> substring = <span class="string">&quot;测试&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> index = str.<span class="title function_">indexOf</span>(substring);</span><br><span class="line"><span class="keyword">let</span> indices = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (index !== -<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">  indices.<span class="title function_">push</span>(index);</span><br><span class="line">  index = str.<span class="title function_">indexOf</span>(substring, index + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(indices); <span class="comment">// 输出所有找到的子字符串的位置   输出 (3) [4, 10, 25]</span></span><br></pre></td></tr></table></figure>

<p>还有一个类似的方法 <code>str.lastIndexOf(substr, position)</code>，它从字符串的末尾开始搜索到开头。</p>
<p>它会以相反的顺序列出这些事件。</p>
<ul>
<li><strong>现代方法</strong> <code>includes，startsWith，endsWith</code></li>
</ul>
<p>现代的方法 <code>str.includes(substr, pos)</code> 根据 <code>str</code> 中是否包含 <code>substr</code> 来返回 <code>true/false</code>。<code>pos</code> 为可选参数</p>
<p>如果我们 <strong>需要检测匹配，但不需要它的位置</strong>，那么这是正确的选择：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Widget with id&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Widget&quot;</span>) );    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span>.<span class="title function_">includes</span>(<span class="string">&quot;Bye&quot;</span>) );      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>string.startWith(substr)</code> 检测文本串 <code>string</code> 的字符，是否以子文本串 <code>substr</code> 开头 。</p>
<p><code>string.endWith(substr)</code> 检测文本串 <code>string</code> 的字符，是否以子文本串 <code>substr</code> 结尾 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">startsWith</span>(<span class="string">&quot;Wid&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;Wid&quot; 开始</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Widget&quot;</span>.<span class="title function_">endsWith</span>(<span class="string">&quot;get&quot;</span>) ); <span class="comment">// true，&quot;Widget&quot; 以 &quot;get&quot; 结束</span></span><br></pre></td></tr></table></figure>



<h3 id="获取子字符串"><a href="#获取子字符串" class="headerlink" title="获取子字符串"></a>获取子字符串</h3><p>JavaScript 中有三种获取字符串的方法：<code>substring</code>、<code>substr</code> 和 <code>slice</code>。</p>
<p>方法一 <code>str.slice(start [, end])</code>  【推荐使用】<br>返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">5</span>) ); <span class="comment">// &#x27;strin&#x27;，从 0 到 5 的子字符串（不包括 5）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">1</span>) ); <span class="comment">// &#x27;s&#x27;，从 0 到 1，但不包括 1，所以只有在 0 处的字符</span></span><br></pre></td></tr></table></figure>
<p>如果没有第二个参数，<code>slice</code> 会一直运行到字符串末尾：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(<span class="number">2</span>) ); <span class="comment">// 从第二个位置直到结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//start/end 也有可能是负值。它们的意思是起始位置从字符串结尾计算：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从右边的第四个位置开始，在右边的第一个位置结束</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(-<span class="number">4</span>, -<span class="number">1</span>) ); <span class="comment">// &#x27;gif&#x27;</span></span><br></pre></td></tr></table></figure>

<p>方法二 <code>str.substring(start [, end])</code></p>
<p>返回字符串从 <code>start</code> 到（但不包括）<code>end</code> 的部分。</p>
<p>这与 <code>slice</code> 几乎相同，但它允许 <code>start</code> 大于 <code>end</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这些对于 substring 是相同的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">substring</span>(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">substring</span>(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;ring&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……但对 slice 是不同的：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(<span class="number">2</span>, <span class="number">6</span>) ); <span class="comment">// &quot;ring&quot;（一样）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">slice</span>(<span class="number">6</span>, <span class="number">2</span>) ); <span class="comment">// &quot;&quot;（空字符串）</span></span><br></pre></td></tr></table></figure>
<p>不支持负参数（不像 slice），它们被视为 0。</p>
<p>方法三 <code>str.substr(start [, length])</code><br>返回字符串从 start 开始的给定 length 的部分。</p>
<p>与以前的方法相比，这个允许我们指定 length 而不是结束位置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">substr</span>(<span class="number">2</span>, <span class="number">4</span>) ); <span class="comment">// &#x27;ring&#x27;，从位置 2 开始，获取 4 个字符</span></span><br><span class="line">第一个参数可能是负数，从结尾算起：</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;stringify&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( str.<span class="title function_">substr</span>(-<span class="number">4</span>, <span class="number">2</span>) ); <span class="comment">// &#x27;gi&#x27;，从第 4 位获取 2 个字符</span></span><br></pre></td></tr></table></figure>
<p>我们回顾一下这些方法，以免混淆：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>选择方式</th>
<th>负值参数</th>
</tr>
</thead>
<tbody><tr>
<td>slice(start, end）<br />【推荐使用】</td>
<td>从 start 到 end（不含 end）</td>
<td>允许</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>从 start 到 end（不含 end）</td>
<td>负值被视为 0</td>
</tr>
<tr>
<td>substr(start, length)</td>
<td>从 start 开始获取长为 length 的字符串</td>
<td>允许 start 为负数</td>
</tr>
</tbody></table>
<p>使用哪一个？<br>它们都可用于获取子字符串。正式一点来讲，substr 有一个小缺点：它不是在 JavaScript 核心规范中描述的，而是在附录 B 中。附录 B 的内容主要是描述因历史原因而遗留下来的仅浏览器特性。因此，理论上非浏览器环境可能无法支持 substr，但实际上它在别的地方也都能用。</p>
<p>相较于其他两个变体，slice 稍微灵活一些，它允许以负值作为参数并且写法更简短。</p>
<p>因此仅仅记住这三种方法中的 slice 就足够了。</p>
<hr>
<h2 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h2><h3 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h3><p><code>12345</code> 可以表示为 <code>1.2345e4</code> ，这里的 <code>e4</code> 相当于 <strong>10 的 4 次方</strong>。</p>
<p><code>0.008314</code> 可以表示为 <code>8.314e-3</code> 。</p>
<h3 id="数字进制转换"><a href="#数字进制转换" class="headerlink" title="数字进制转换"></a>数字进制转换</h3><p>常见的进制有：2 进制，10 进制，16 进制，32 进制。</p>
<p>进制的范围：<code>2</code> 到 <code>36</code> 。默认 <code>10</code>，毕竟大家都是人类，学的都是十进制 。</p>
<p>为什么进制最大是 36 进制呢？</p>
<p>因为 0~9 在加上 26 个英文字母一共 36，在进制中，大小写是等效的。</p>
<p>给定一个数字 <code>num</code> ，想把它转成另一个进制 <code>base</code> ，需要使用方法 <code>toString</code> 。</p>
<p><code>num.toString(base)</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">123456789</span>;</span><br><span class="line"><span class="keyword">let</span> number2 = number.<span class="title function_">toString</span>(<span class="number">36</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="property">log</span> (number2);              <span class="comment">//输出  21i3v9</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//当然下面这句也能实现目的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;------这里是分割线--------&quot;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">123456789.</span>.<span class="title function_">toString</span>(<span class="number">36</span>));  <span class="comment">//输出  21i3v9</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>请注意 <code>123456789..toString(36)</code> 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 <code>toString</code>，那么我们需要在它后面放置两个点 <code>..</code>。</p>
<p>如果我们放置一个点：<code>123456789.toString(36)</code>，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。</p>
<p>也可以写成 <code>(123456789).toString(36)</code>。</p>
</blockquote>
<h3 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h3><p>函数 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed">toFixed(n)</a> 将数字精确到到小数点后 <code>n</code> 位进行四舍五入，并以字符串形式返回结果。</p>
<p>我们可以使用一元加号或 <code>Number()</code> 调用，将其转换为数字，例如 <code>+ num.toFixed(5)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个具有 5 位小数的数字。</span></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保留小数点后 9 位，若位数不足自动添 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toFixed</span>(<span class="number">9</span>));     <span class="comment">//输出 3.141590000</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toFixed</span>(<span class="number">2</span>));     <span class="comment">//输出 3.14</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//括号中什么都不写，则默认括号里面是 0，即四舍五入保留整数部分。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toFixed</span>());      <span class="comment">//输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toFixed</span>(<span class="number">3</span>));     <span class="comment">//输出 3.142</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(number.<span class="title function_">toFixed</span>(<span class="number">0</span>));     <span class="comment">//输出 3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>当然 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">数字函数</a> 中支持更多对数字进行的操作。</p>
<h3 id="检测变量是不是数字"><a href="#检测变量是不是数字" class="headerlink" title="检测变量是不是数字"></a>检测变量是不是数字</h3><p><strong>isFinite 和 isNaN</strong></p>
<p><code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code>：</p>
<ul>
<li><code>isNaN</code> 函数用来检查其参数是否是非数值（NaN）。</li>
<li>如果参数是 NaN，或者在将参数转换为数值时无法转换（例如字符串），则返回 <code>true</code>。</li>
<li><code>isNaN</code> 会先尝试将传入的参数转换为数字，如果转换失败，才判断为 NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span>;</span><br><span class="line">b = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">c = <span class="string">&quot;123ww&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>)); <span class="comment">//true   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(a));   <span class="comment">//false  因为字符串不能转换为数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(b));   <span class="comment">//false  因为字符串不能转换为数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(c));   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//NaN 与任何值比较都是返回 NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span>===<span class="title class_">NaN</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<p>**<code>isFinite</code>**：</p>
<ul>
<li><code>isFinite</code> 函数用来检查其参数是否是一个有限数值。</li>
<li>如果参数是有限数值，即不是无穷大（Infinity 或 -Infinity），也不是 NaN，则返回 <code>true</code>。</li>
<li><code>isFinite</code> 不会尝试将参数转换为数字，它只检查参数本身的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(-<span class="title class_">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="title class_">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="number">0</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// false，因为是非数值</span></span><br><span class="line"><span class="built_in">isFinite</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// false，因为是非数值</span></span><br><span class="line"><span class="comment">//想看输出值，记得加 console.log</span></span><br></pre></td></tr></table></figure>

<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><strong>检查范围</strong>：<ul>
<li><code>isNaN</code> 专门用来检查 NaN。</li>
<li><code>isFinite</code> 用来检查数值是否有限，即不是无穷大或 NaN。</li>
</ul>
</li>
<li><strong>类型转换</strong>：<ul>
<li><code>isNaN</code> 会进行类型转换，尝试将参数转换为数值。</li>
<li><code>isFinite</code> 不会进行类型转换，只检查传入的原始值。</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>当你需要确定一个值是否是 NaN 时，使用 <code>isNaN</code>。</li>
<li>当你需要确定一个值是否是有限数值时，使用 <code>isFinite</code>。</li>
</ul>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>isNaN</code> 函数在没有参数的情况下会返回 <code>false</code>，这是与其他全局函数（如 <code>typeof</code> 和 <code>isFinite</code>）不同的行为。</li>
<li>由于 <code>isNaN</code> 的类型转换特性，如果你想严格检查一个值是否为 NaN，应该使用 <code>Number.isNaN()</code> 方法。</li>
</ul>
<p>在实际编程中，选择 <code>isNaN</code> 还是 <code>isFinite</code> 取决于你要解决的问题和你要检查的值的类型。</p>
<ul>
<li>请注意，在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</li>
</ul>
<hr>
<h3 id="提取文本串中开头的数字"><a href="#提取文本串中开头的数字" class="headerlink" title="提取文本串中开头的数字"></a>提取文本串中开头的数字</h3><p>现实生活中，我们经常会有带有单位的值，例如 CSS 中的 <code>&quot;100px&quot;</code> 或 <code>&quot;12pt&quot;</code>。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 <code>&quot;19￥&quot;</code>，并希望从中提取出一个数值。</p>
<p>这就是 <code>parseInt</code> 和 <code>parseFloat</code> 的作用。</p>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>parseInt</code> 和 <code>parseFloat</code> 都不会自动转换字符串中的数据类型。如果字符串的第一个字符不能被转换，它们会立即返回 <code>NaN</code>。</li>
<li>如果没有提供基数给 <code>parseInt</code>，它将尝试根据字符串来判断基数。例如，如果字符串以 <code>&quot;0x&quot;</code> 开头，它将尝试将字符串解析为十六进制数。</li>
<li>如果使用 <code>parseInt</code> 解析字符串时提供了基数，但字符串不符合该基数的数值格式，它会返回解析到的错误结果或 <code>NaN</code>。</li>
<li><code>parseFloat</code> 不能解析科学记数法表示的数字，而 <code>parseInt</code> 可以。</li>
<li>它们都会忽略字符串前面的空格，直到找到第一个非数字字符为止。</li>
</ul>
<p>在实际使用中，你应该根据需要转换的数值类型来选择合适的函数。如果你需要整数，使用 <code>parseInt</code>；如果你需要浮点数，使用 <code>parseFloat</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>);        <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10.00&quot;</span>);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;10.95&quot;</span>);      <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;34 45 66&quot;</span>);   <span class="comment">// 34</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;   60   &quot;</span>);  <span class="comment">// 60</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;40 years&quot;</span>, <span class="number">10</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;Days10&quot;</span>, <span class="number">10</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;11&quot;</span>, <span class="number">2</span>);      <span class="comment">// 3，因为 &quot;11&quot; 是二进制表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10&quot;</span>);       <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10.00&quot;</span>);     <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10.95&quot;</span>);     <span class="comment">// 10.95</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;34.45 66&quot;</span>);  <span class="comment">// 34.45</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;   60.123   &quot;</span>); <span class="comment">// 60.123</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;40 years&quot;</span>); <span class="comment">// 40</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;Days10&quot;</span>, <span class="number">10</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>





<h3 id="数字函数"><a href="#数字函数" class="headerlink" title="数字函数"></a>数字函数</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math">数字函数</a> </p>
<p>学生生涯中常见的基础函数，都覆盖到了。</p>
<p>例如随机数、三角函数、幂函数、对数、标准圆周率等等。</p>
<hr>
<h3 id="变量的数据类型转换"><a href="#变量的数据类型转换" class="headerlink" title="变量的数据类型转换"></a>变量的数据类型转换</h3><ul>
<li>转换成字符串</li>
<li>转换成数字</li>
<li>转换成布尔</li>
</ul>
<p>大多数情况下，运算符和函数会自动将赋予它们的值转换为正确的类型。</p>
<p>比如，<code>console.log</code> 会自动将任何值都转换为字符串以进行显示。算术运算符会将值转换为数字。</p>
<p>在某些情况下，我们需要将值主动地转换为我们期望的类型。</p>
<h4 id="转换成字符串"><a href="#转换成字符串" class="headerlink" title="转换成字符串"></a><strong>转换成字符串</strong></h4><p>我们也可以显式地调用 <code>String(value)</code> 来将 <code>value</code> 转换为字符串类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> value); <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line">value = <span class="title class_">String</span>(value); <span class="comment">// 现在，值是一个字符串形式的 &quot;true&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> value); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>

<p>字符串转换最明显。<code>false</code> 变成 <code>&quot;false&quot;</code>，<code>null</code> 变成 <code>&quot;null&quot;</code> 等。</p>
<h4 id="转换成数字"><a href="#转换成数字" class="headerlink" title="转换成数字"></a><strong>转换成数字</strong></h4><p>在算术函数和表达式中，会自动进行 number 类型转换。</p>
<p>比如，当把除法 <code>/</code> 用于非 number 类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;6&quot;</span> / <span class="string">&quot;2&quot;</span> ); <span class="comment">// 3, string 类型的值被自动转换成 number 类型后进行计算</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <code>Number(value)</code> 显式地将这个 <code>value</code> 转换为 number 类型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> str); <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="title class_">Number</span>(str); <span class="comment">// 变成 number 类型 123</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>当我们从 string 类型源（如文本表单）中读取一个值，但期望输入一个数字时，通常需要进行显式转换。</p>
<p>如果该字符串不是一个有效的数字，转换的结果会是 <code>NaN</code>。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title class_">Number</span>(<span class="string">&quot;an arbitrary string instead of a number&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// NaN，转换失败</span></span><br></pre></td></tr></table></figure>

<p>number 类型转换规则：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">变成……</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
</tr>
<tr>
<td align="left"><code>true 和 false</code></td>
<td align="left"><code>1</code> and <code>0</code></td>
</tr>
<tr>
<td align="left"><code>string</code></td>
<td align="left">去掉首尾空白字符（空格、换行符 <code>\n</code>、制表符 <code>\t</code> 等）后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 <code>0</code>。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 <code>NaN</code>。</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Number</span>(<span class="string">&quot;   123   &quot;</span>) ); <span class="comment">// 123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Number</span>(<span class="string">&quot;123z&quot;</span>) );      <span class="comment">// NaN（从字符串“读取”数字，读到 &quot;z&quot; 时出现错误）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Number</span>(<span class="literal">true</span>) );        <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Number</span>(<span class="literal">false</span>) );       <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>请注意 <code>null</code> 和 <code>undefined</code> 在这有点不同：<code>null</code> 变成数字 <code>0</code>，<code>undefined</code> 变成 <code>NaN</code>。</p>
<p>大多数数学运算符都执行这种转换，我们将在下一节中进行介绍。</p>
<h4 id="转换成布尔（boolean）类型"><a href="#转换成布尔（boolean）类型" class="headerlink" title="转换成布尔（boolean）类型"></a><strong>转换成布尔（boolean）类型</strong></h4><p>它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换。</p>
<p>转换规则如下：</p>
<ul>
<li>直观上为“空”的值（如 <code>0</code>、空字符串、<code>null</code>、<code>undefined</code> 和 <code>NaN</code>）将变为 <code>false</code>。</li>
<li>其他值变成 <code>true</code>。</li>
</ul>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="number">1</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="number">0</span>) ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="string">&quot;hello&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="string">&quot;&quot;</span>) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>请注意：包含 0 的字符串 <code>&quot;0&quot;</code> 是 <code>true</code></strong></p>
<p>一些编程语言（比如 PHP）视 <code>&quot;0&quot;</code> 为 <code>false</code>。但在 JavaScript 中，非空的字符串总是 <code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="string">&quot;0&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="string">&quot; &quot;</span>) ); <span class="comment">// 空格，也是 true（任何非空字符串都是 true）</span></span><br></pre></td></tr></table></figure>



<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>有三种常用的类型转换：转换为 string 类型、转换为 number 类型和转换为 boolean 类型。</p>
<p><strong>字符串转换</strong> —— 转换发生在输出内容的时候，也可以通过 <code>String(value)</code> 进行显式转换。原始类型值的 string 类型转换通常是很明显的。</p>
<p><strong>数字型转换</strong> —— 转换发生在进行算术操作时，也可以通过 <code>Number(value)</code> 进行显式转换。</p>
<p>数字型转换遵循以下规则：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">变成……</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>undefined</code></td>
<td align="left"><code>NaN</code></td>
</tr>
<tr>
<td align="left"><code>null</code></td>
<td align="left"><code>0</code></td>
</tr>
<tr>
<td align="left"><code>true / false</code></td>
<td align="left"><code>1 / 0</code></td>
</tr>
<tr>
<td align="left"><code>string</code></td>
<td align="left">“按原样读取”字符串，两端的空白字符（空格、换行符 <code>\n</code>、制表符 <code>\t</code> 等）会被忽略。空字符串变成 <code>0</code>。转换出错则输出 <code>NaN</code>。</td>
</tr>
</tbody></table>
<p><strong>布尔型转换</strong> —— 转换发生在进行逻辑操作时，也可以通过 <code>Boolean(value)</code> 进行显式转换。</p>
<p>布尔型转换遵循以下规则：</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">变成……</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>&quot;&quot;</code></td>
<td align="left"><code>false</code></td>
</tr>
<tr>
<td align="left">其他值</td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<p>上述的大多数规则都容易理解和记忆。人们通常会犯错误的值得注意的例子有以下几个：</p>
<ul>
<li>对 <code>undefined</code> 进行数字型转换时，输出结果为 <code>NaN</code>，而非 <code>0</code>。</li>
<li>对 <code>&quot;0&quot;</code> 和只有空格的字符串（比如：<code>&quot; &quot;</code>）进行布尔型转换时，输出结果为 <code>true</code>。</li>
</ul>
<p><a href="https://zh.javascript.info/type-conversions">https://zh.javascript.info/type-conversions</a></p>
<hr>
<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><h2 id="术语：“一元运算符”，“二元运算符”，“运算元”"><a href="#术语：“一元运算符”，“二元运算符”，“运算元”" class="headerlink" title="术语：“一元运算符”，“二元运算符”，“运算元”"></a>术语：“一元运算符”，“二元运算符”，“运算元”</h2><p>在正式开始前，我们先简单浏览一下常用术语。</p>
<ul>
<li><p><strong>运算元</strong> —— 运算符应用的对象。比如说乘法运算 <code>5 * 2</code>，有两个运算元：左运算元 <code>5</code> 和右运算元 <code>2</code>。有时候人们也称其为“参数”而不是“运算元”。</p>
</li>
<li><p>如果一个运算符对应的只有一个运算元，那么它是 <strong>一元运算符</strong>。比如说一元负号运算符 <code>-</code>，它的作用是对数字进行正负转换：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">x = -x;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( x ); <span class="comment">// -1，一元负号运算符生效</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个运算符拥有两个运算元，那么它是 <strong>二元运算符</strong>。<br>例如，减号还存在二元运算符形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( y - x ); <span class="comment">// 2，二元运算符减号做减运算</span></span><br></pre></td></tr></table></figure>

<p>严格地说，在上面的示例中，我们使用一个相同的符号表征了两个不同的运算符：①负号运算符，即反转符号的一元运算符；②减法运算符，是从另一个数减去一个数的二元运算符。</p>
</li>
</ul>
<h2 id="数学运算-1"><a href="#数学运算-1" class="headerlink" title="数学运算"></a>数学运算</h2><p>支持以下数学运算：</p>
<ul>
<li>加法 <code>+</code>,</li>
<li>减法 <code>-</code>,</li>
<li>乘法 <code>*</code>,</li>
<li>除法 <code>/</code>,</li>
<li>取余 <code>%</code>,</li>
<li>求幂 <code>**</code>.</li>
</ul>
<p>前四个都很简单，而 <code>%</code> 和 <code>**</code> 则需要说一说。</p>
<h3 id="取余"><a href="#取余" class="headerlink" title="取余 %"></a>取余 %</h3><p>取余运算符是 <code>%</code>，尽管它看起来很像百分数，但实际并无关联。</p>
<p><code>a % b</code> 的结果是 <code>a</code> 整除 <code>b</code> 的 余数。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">13</span> % <span class="number">2</span> ); <span class="comment">// 输出 1，   13 除以 2 的余数</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">20</span> % <span class="number">3</span> ); <span class="comment">// 输出 2，   20 除以 3 的余数</span></span><br></pre></td></tr></table></figure>

<h3 id="求幂"><a href="#求幂" class="headerlink" title="求幂 **"></a>求幂 **</h3><p>求幂运算 <code>a ** b</code> ，将 <code>a</code> 提升至 <code>a</code> 的 <code>b</code> 次幂。</p>
<p>在数学运算中我们将其表示为 a <sup> b </sup>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> ** <span class="number">2</span> ); <span class="comment">// 2 ² = 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> ** <span class="number">3</span> ); <span class="comment">// 2 ³ = 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> ** <span class="number">4</span> ); <span class="comment">// 2 ⁴ = 16</span></span><br></pre></td></tr></table></figure>

<p>就像在数学运算中一样，幂运算也适用于非整数。</p>
<p>例如，平方根是指数为 ½ 的幂运算：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">4</span> ** (<span class="number">1</span>/<span class="number">2</span>) ); <span class="comment">// 2     （1/2 次方与平方根相同)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">8</span> ** (<span class="number">1</span>/<span class="number">3</span>) ); <span class="comment">// 2     （1/3 次方与立方根相同)</span></span><br></pre></td></tr></table></figure>

<h2 id="用二元运算符-连接字符串"><a href="#用二元运算符-连接字符串" class="headerlink" title="用二元运算符 +         连接字符串"></a>用二元运算符 +         连接字符串</h2><p>通常，加号 <code>+</code> 用于求和。</p>
<p>但是如果加号 <code>+</code> 被应用于字符串，它将合并（连接）各个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&quot;my&quot;</span> + <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s); <span class="comment">// mystring</span></span><br></pre></td></tr></table></figure>

<p>注意：只要任意一个运算元是字符串，那么另一个运算元也将被转化为字符串。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> ); <span class="comment">// &quot;12&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> + <span class="string">&#x27;1&#x27;</span> ); <span class="comment">// &quot;21&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> + <span class="string">&#x27;天&#x27;</span> ); <span class="comment">// &quot;2 天&quot;</span></span><br></pre></td></tr></table></figure>

<p>你看，第一个运算元和第二个运算元，哪个是字符串并不重要，只要其中任意一个是字符串，那么由 <code>+</code> 连接的两个运算元都会默认转换成字符串拼接起来。</p>
<p>下面是一个更复杂的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> + <span class="number">2</span> + <span class="string">&#x27;1&#x27;</span> ); <span class="comment">// &quot;41&quot;，不是 &quot;221&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这里，运算符 <code>+</code> 是按顺序工作（加法默认是从左到右）。第一个 <code>+</code> 将两个数字相加，所以返回 <code>4</code>，然后下一个 <code>+</code> 将字符串 <code>1</code> 加入其中，所以就是 <code>4 + &#39;1&#39; = &#39;41&#39;</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span> + <span class="number">2</span> + <span class="number">2</span>); <span class="comment">// &quot;122&quot;，不是 &quot;14&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里，第一个操作数是一个字符串，所以编译器将其他两个操作数也视为了字符串。<code>2</code> 被与 <code>&#39;1&#39;</code> 连接到了一起，也就是像 <code>&#39;1&#39; + 2 = &quot;12&quot;</code> 然后 <code>&quot;12&quot; + 2 = &quot;122&quot;</code> 这样。</p>
<p>二元 <code>+</code> 是唯一一个以这种方式支持字符串的运算符。<br>其他算术运算符只对数字起作用，并且总是将其运算元转换为数字。</p>
<p>下面是减法和除法运算的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">6</span> - <span class="string">&#x27;2&#x27;</span> ); <span class="comment">// 4，将 &#x27;2&#x27; 转换为数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;6&#x27;</span> / <span class="string">&#x27;2&#x27;</span> ); <span class="comment">// 3，将两个运算元都转换为数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">12</span> - <span class="string">&quot;string&quot;</span>); <span class="comment">// NaN  带有非数字的文本串无法转为数字</span></span><br></pre></td></tr></table></figure>

<h2 id="数字转化，一元运算符"><a href="#数字转化，一元运算符" class="headerlink" title="数字转化，一元运算符 +"></a>数字转化，一元运算符 +</h2><p>加号 <code>+</code> 有两种形式。一种是上面我们刚刚讨论的二元运算符，还有一种是一元运算符。</p>
<p>一元运算符加号，或者说，加号 <code>+</code> 应用于单个值，对数字没有任何作用。<br>但是如果运算元不是数字，加号 <code>+</code> 则会将其转化为数字。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对数字无效（因为数学里面学过，在数字前面加正号没啥用）</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( +x ); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = -<span class="number">2</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( +y ); <span class="comment">// -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转化非数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( +<span class="literal">true</span> ); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( +<span class="string">&quot;&quot;</span> );   <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&quot;11KB&quot;</span>); <span class="comment">// NaN  带有非数字的文本串无法转为数字</span></span><br></pre></td></tr></table></figure>

<p>它的效果和 <code>Number(...)</code> 相同，但是更加简短。</p>
<p>我们经常会有将字符串转化为数字的需求。比如，如果我们正在从 HTML 表单中取值，通常得到的都是字符串。如果我们想对它们求和，该怎么办？</p>
<p>二元运算符加号会把它们合并成字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> oranges = <span class="string">&quot;3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( apples + oranges ); <span class="comment">// &quot;23&quot;，二元运算符加号合并字符串</span></span><br></pre></td></tr></table></figure>

<p>如果我们想把它们当做数字对待，我们需要转化它们，然后再求和：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apples = <span class="string">&quot;2&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> oranges = <span class="string">&quot;3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二元运算符加号起作用之前，所有的值都被转化为了数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( +apples + +oranges ); <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//如果你害怕眼花，可以加括号进行区分，括号的运算是最优先的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( (+apples) + (+oranges) ); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更长的写法</span></span><br><span class="line"><span class="comment">// console.log( Number(apples) + Number(oranges) ); // 5</span></span><br></pre></td></tr></table></figure>
<p>一元运算符加号首先起作用，它们将字符串转为数字，然后二元运算符加号对它们进行求和。</p>
<p>为什么一元运算符先于二元运算符作用于运算元？<br>这是由于它们拥有 <strong>更高的优先级</strong>。</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>如果一个表达式拥有多个运算符，执行的顺序则由 <strong>优先级</strong> 决定。换句话说，所有的运算符中都隐含着优先级顺序。</p>
<p>我们知道在表达式 <code>1 + 2 * 2</code> 中，乘法先于加法计算。<br>这就是一个优先级问题。乘法比加法拥有 <strong>更高的优先级</strong>。</p>
<p>圆括号拥有 <strong>最高优先级</strong> ，所以如果我们对现有的运算顺序不满意，我们可以使用圆括号来修改运算顺序，就像这样：<code>(1 + 2) * 2</code>。</p>
<p><strong>不要觉得加多了括号丑，对于新手，为了减轻学习压力以及避免优先级错误，就应该多用括号。</strong><br><strong>因为括号的优先级是最高的，你只要用了括号，下面这张表中的运算优先级你都可以不用去记。</strong></p>
<p>在 JavaScript 中有众多运算符。每个运算符都有对应的优先级数字。数字越大，越先执行。如果优先级相同，则按照由左至右的顺序执行。</p>
<p>这是一个摘抄自 Mozilla 的 <a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">优先级表</a>（你没有必要把这全记住，但要记住一元运算符优先级高于二元运算符）：</p>
<table>
<thead>
<tr>
<th align="left">优先级</th>
<th align="left">名称</th>
<th align="left">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">一元加号</td>
<td align="left"><code>+</code></td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">一元负号</td>
<td align="left"><code>-</code></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">求幂</td>
<td align="left"><code>**</code></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">乘号</td>
<td align="left"><code>*</code></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">除号</td>
<td align="left"><code>/</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">加号</td>
<td align="left"><code>+</code></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">减号</td>
<td align="left"><code>-</code></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">赋值符</td>
<td align="left"><code>=</code></td>
</tr>
<tr>
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
</tbody></table>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>我们知道赋值符号 <code>=</code> 也是一个运算符。从优先级表中可以看到它的优先级非常低，只有 <code>2</code>。</p>
<p>当我们赋值时，比如 <code>x = 2 * 2 + 1</code>，所有的计算先执行，然后 <code>=</code> 才执行，将计算结果存储到 <code>x</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">2</span> * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( x ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="赋值-返回一个值"><a href="#赋值-返回一个值" class="headerlink" title="赋值 &#x3D; 返回一个值"></a>赋值 &#x3D; 返回一个值</h3><p><code>=</code> 是一个运算符，而不是一个有着“魔法”作用的语言结构。</p>
<p>在 JavaScript 中，所有运算符都会返回一个值。这对于 <code>+</code> 和 <code>-</code> 来说是显而易见的，但对于 <code>=</code> 来说也是如此。</p>
<p>语句 <code>x = value</code> 将值 <code>value</code> 写入 <code>x</code> 。</p>
<p>下面是一个在复杂语句中使用赋值的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span> - (a = b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( c ); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子，<code>(a = b + 1)</code> 的结果是给 <code>a</code> 赋值为 <code>3</code>。然后该值被用于进一步的运算。</p>
<p>不过，请不要写这样的代码。这样的技巧绝对不会使代码变得更清晰或可读。</p>
<h3 id="链式赋值（Chaining-assignments）"><a href="#链式赋值（Chaining-assignments）" class="headerlink" title="链式赋值（Chaining assignments）"></a>链式赋值（Chaining assignments）</h3><p>另一个有趣的特性是链式赋值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a, b, c;</span><br><span class="line"></span><br><span class="line">a = b = c = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( b ); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( c ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>链式赋值从右到左进行计算。<br>首先，对最右边的表达式 <code>2 + 2</code> 求值，<br>然后将其赋给左边的变量：<code>c</code>、<code>b</code> 和 <code>a</code>。<br>最后，所有的变量共享一个值。</p>
<p>同样，出于可读性，最好将这种代码分成几行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">c = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line">b = c;</span><br><span class="line">a = c;</span><br></pre></td></tr></table></figure>

<p>这样可读性更强，尤其是在快速浏览代码的时候。</p>
<h2 id="原地修改"><a href="#原地修改" class="headerlink" title="原地修改"></a>原地修改</h2><p>我们经常需要对一个变量做运算，并将新的结果存储在同一个变量中。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">n = n + <span class="number">5</span>;</span><br><span class="line">n = n * <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用运算符 <code>+=</code> 和 <code>*=</code> 来缩写这种表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">n += <span class="number">5</span>; <span class="comment">// 现在 n = 7（等同于 n = n + 5）</span></span><br><span class="line">n *= <span class="number">2</span>; <span class="comment">// 现在 n = 14（等同于 n = n * 2）</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( n ); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>

<p>所有算术和位运算符都有简短的“修改并赋值”运算符：<code>/=</code> 和 <code>-=</code> 等。</p>
<p>这类运算符的优先级与普通赋值运算符的优先级相同，所以它们在大多数其他运算之后执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">n *= <span class="number">3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( n ); <span class="comment">// 16 （右边部分先被计算，等同于 n *= 8）</span></span><br></pre></td></tr></table></figure>

<h2 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增&#x2F;自减"></a>自增&#x2F;自减</h2><p>对一个数进行加一、减一是最常见的数学运算符之一。</p>
<p>所以，对此有一些专门的运算符：</p>
<ul>
<li><p><strong>自增</strong> <code>++</code> 将变量与 1 相加：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">2</span>;</span><br><span class="line">counter++;      <span class="comment">// 和 counter = counter + 1 效果一样，但是更简洁</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( counter ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>自减</strong> <code>--</code> 将变量与 1 相减：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">5</span>;</span><br><span class="line">counter--;      <span class="comment">// 和 counter = counter - 1 效果一样，但是更简洁</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( counter ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>重要：</strong></p>
<p>自增&#x2F;自减只能应用于变量。试一下，将其应用于普通数字（比如 <code>5++</code>）则会报错。</p>
<p>运算符 <code>++</code> 和 <code>--</code> 可以置于变量前，也可以置于变量后。</p>
<ul>
<li>当运算符置于变量后，被称为“后置形式”：<code>counter++</code>。</li>
<li>当运算符置于变量前，被称为“前置形式”：<code>++counter</code>。</li>
</ul>
<p>两者都做同一件事：将变量 <code>counter</code> 与 <code>1</code> 相加。</p>
<p>那么它们有区别吗？有，但只有当我们使用 <code>++/--</code> 的返回值时才能看到区别。</p>
<p>详细点说。我们知道，所有的运算符都有返回值。自增&#x2F;自减也不例外。前置形式返回一个新的值，但后置返回原来的值（做加法&#x2F;减法之前的值）。</p>
<p>为了直观看到区别，看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = ++counter; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p><code>(*)</code> 所在的行是前置形式 <code>++counter</code>，对 <code>counter</code> 做自增运算，返回的是新的值 <code>2</code>。因此 <code>console.log</code> 显示的是 <code>2</code>。</p>
<p>下面让我们看看后置形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> a = counter++; <span class="comment">// (*) 将 ++counter 改为 counter++</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><code>(*)</code> 所在的行是后置形式 <code>counter++</code>，它同样对 <code>counter</code> 做加法，但是返回的是 <strong>旧值</strong>（做加法之前的值）。因此 <code>console.log</code> 显示的是 <code>1</code>。</p>
<p>总结：</p>
<ul>
<li><p>如果自增&#x2F;自减的值不会被使用，那么两者形式没有区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line">counter++;</span><br><span class="line">++counter;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( counter ); <span class="comment">// 2，以上两行作用相同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想要对变量进行自增操作，<strong>并且</strong> 需要立刻使用自增后的值，那么我们需要使用前置形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( ++counter ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们想要将一个数加一，但是我们想使用其自增之前的值，那么我们需要使用后置形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( counter++ ); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>自增&#x2F;自减和其它运算符的对比</strong></p>
<p><code>++/--</code> 运算符同样可以在表达式内部使用。它们的优先级比绝大部分的算数运算符要高。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> * ++counter ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>与下方例子对比：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> * counter++ ); <span class="comment">// 2，因为 counter++ 返回的是“旧值”</span></span><br></pre></td></tr></table></figure>

<p>尽管从技术层面上来说可行，但是这样的写法会降低代码的可阅读性。在一行上做多个操作 —— 这样并不好。</p>
<p>当阅读代码时，快速的视觉“纵向”扫描会很容易漏掉 <code>counter++</code>，这样的自增操作并不明显。</p>
<p>我们建议用“一行一个行为”的模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> * counter );</span><br><span class="line">counter++;</span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>了解即可，前端开发过程中用的很少。<br>位运算符把运算元当做 32 位整数，并在它们的二进制表现形式上操作。</p>
<p>这些运算符不是 JavaScript 特有的。大部分的编程语言都支持这些运算符。</p>
<p>下面是位运算符：</p>
<ul>
<li>按位与 ( <code>&amp;</code> )</li>
<li>按位或 ( <code>|</code> )</li>
<li>按位异或 ( <code>^</code> )</li>
<li>按位非 ( <code>~</code> )</li>
<li>左移 ( <code>&lt;&lt;</code> )</li>
<li>右移 ( <code>&gt;&gt;</code> )</li>
<li>无符号右移 ( <code>&gt;&gt;&gt;</code> )</li>
</ul>
<p>这些运算符很少被使用，一般是我们需要在最低级别（位）上操作数字时才使用。我们不会很快用到这些运算符，因为在 Web 开发中很少使用它们，但在某些特殊领域中，例如密码学，它们很有用。当你需要了解它们的时候，可以阅读 MDN 上的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#bitwise_operators">位操作符</a> 章节。</p>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符 <code>,</code> 是最少见最不常使用的运算符之一。有时候它会被用来写更简短的代码，因此为了能够理解代码，我们需要了解它。</p>
<p>逗号运算符能让我们处理多个表达式，使用 <code>,</code> 将它们分开。每个表达式都运行了，但是只有最后一个的结果会被返回。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = (<span class="number">1</span> + <span class="number">2</span>, <span class="number">3</span> + <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a ); <span class="comment">// 7（3 + 4 的结果）</span></span><br></pre></td></tr></table></figure>

<p>这里，第一个表达式 <code>1 + 2</code> 运行了，但是它的结果被丢弃了。随后计算 <code>3 + 4</code>，并且该计算结果被返回。</p>
<p><strong>逗号运算符的优先级非常低</strong></p>
<p>请注意逗号运算符的优先级非常低，比 <code>=</code> 还要低，因此上面你的例子中圆括号非常重要。</p>
<p>如果没有圆括号：<code>a = 1 + 2, 3 + 4</code> 会先执行 <code>+</code>，将数值相加得到 <code>a = 3, 7</code>，然后赋值运算符 <code>=</code> 执行 <code>a = 3</code>，然后逗号之后的数值 <code>7</code> 不会再执行，它被忽略掉了。相当于 <code>(a = 1 + 2), 3 + 4</code>。</p>
<p>为什么我们需要这样一个运算符，它只返回最后一个值呢？</p>
<p>有时候，人们会使用它把几个行为放在一行上来进行复杂的运算。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一行上有三个运算符</span></span><br><span class="line"><span class="keyword">for</span> (a = <span class="number">1</span>, b = <span class="number">3</span>, c = a * b; a &lt; <span class="number">10</span>; a++) </span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的技巧在许多 JavaScript 框架中都有使用，这也是为什么我们提到它。但是通常它并不能提升代码的可读性，使用它之前，我们要想清楚。</p>
<hr>
<h1 id="值的比较"><a href="#值的比较" class="headerlink" title="值的比较"></a>值的比较</h1><p>我们知道，在数学中有很多用于比较大小的运算符。</p>
<p>在 JavaScript 中，它们的编写方式如下：</p>
<ul>
<li>大于 &#x2F; 小于：<code>a &gt; b</code>，<code>a &lt; b</code>。</li>
<li>大于等于 &#x2F; 小于等于：<code>a &gt;= b</code>，<code>a &lt;= b</code>。</li>
<li>检查两个值的相等：<code>a == b</code>，请注意双等号 <code>==</code> 表示相等性检查，而单等号 <code>a = b</code> 表示赋值。</li>
<li>检查两个值不相等：不相等在数学中的符号是 <code>≠</code>，但在 JavaScript 中写成 <code>a != b</code>。</li>
</ul>
<h2 id="比较的结果是-Boolean-类型"><a href="#比较的结果是-Boolean-类型" class="headerlink" title="比较的结果是 Boolean 类型"></a>比较的结果是 Boolean 类型</h2><p>所有比较运算符均返回布尔值：</p>
<ul>
<li><code>true</code> —— 表示“yes（是）”，“correct（正确）”或“the truth（真）”。</li>
<li><code>false</code> —— 表示“no（否）”，“wrong（错误）”或“not the truth（非真）”。</li>
</ul>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> &gt; <span class="number">1</span> );  <span class="comment">// true（正确）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> == <span class="number">1</span> ); <span class="comment">// false（错误）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">2</span> != <span class="number">1</span> ); <span class="comment">// true（正确）</span></span><br></pre></td></tr></table></figure>

<p>和其他类型的值一样，比较的结果可以被赋值给任意变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="number">5</span> &gt; <span class="number">4</span>; <span class="comment">// 把比较的结果赋值给 result</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><p>在比较字符串的大小时，JavaScript 会使用“字典（dictionary）”或“词典（lexicographical）”顺序进行判定。</p>
<p>换言之，字符串是按字符（母）逐个进行比较的。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Z&#x27;</span> &gt; <span class="string">&#x27;A&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Glow&#x27;</span> &gt; <span class="string">&#x27;Glee&#x27;</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Bee&#x27;</span> &gt; <span class="string">&#x27;Be&#x27;</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>字符串的比较算法非常简单：</p>
<ol>
<li>首先比较两个字符串的首位字符大小。</li>
<li>如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。</li>
<li>否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。</li>
<li>重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。</li>
<li>如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。</li>
</ol>
<p>在上面的第一个例子中，<code>&#39;Z&#39; &gt; &#39;A&#39;</code> 比较在算法的第 1 步就得到了结果。</p>
<p>在第二个例子中，字符串 <code>Glow</code> 与 <code>Glee</code> 的比较则需要更多步骤，因为需要逐个字符进行比较：</p>
<ol>
<li><code>G</code> 和 <code>G</code> 相等。</li>
<li><code>l</code> 和 <code>l</code> 相等。</li>
<li><code>o</code> 比 <code>e</code> 大，算法停止，第一个字符串大于第二个。</li>
</ol>
<p><strong>非真正的字典顺序，而是 Unicode 编码顺序</strong></p>
<p>在上面的算法中，比较大小的逻辑与字典或电话簿中的排序很像，但也不完全相同。</p>
<p>比如说，字符串比较对字母大小写是敏感的。大写的 <code>&quot;A&quot;</code> 并不等于小写的 <code>&quot;a&quot;</code>。哪一个更大呢？实际上小写的 <code>&quot;a&quot;</code> 更大。这是因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大。我们会在 <a href="https://zh.javascript.info/string">字符串</a> 这章讨论更多关于字符串的细节。</p>
<h2 id="不同类型间的比较"><a href="#不同类型间的比较" class="headerlink" title="不同类型间的比较"></a>不同类型间的比较</h2><p>当对不同类型的值进行比较时，JavaScript 会首先将其转化为数字（number）再判定大小。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;2&#x27;</span> &gt; <span class="number">1</span> ); <span class="comment">// true，字符串 &#x27;2&#x27; 会被转化为数字 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;01&#x27;</span> == <span class="number">1</span> ); <span class="comment">// true，字符串 &#x27;01&#x27; 会被转化为数字 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;2wwww&#x27;</span> &gt; <span class="number">1</span> ); <span class="comment">//false，</span></span><br></pre></td></tr></table></figure>
<p>‘2wwww’ 不是一个有效的数字格式，它会被转换成 NaN，在 JavaScript 中，NaN 与任何值（包括它自己）的比较都是不相等的。</p>
<p>对于布尔类型值，<code>true</code> 会被转化为 <code>1</code>、<code>false</code> 转化为 <code>0</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> == <span class="number">1</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> == <span class="number">0</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>一个有趣的现象</strong></p>
<p>有时候，以下两种情况会同时发生：</p>
<ul>
<li>若直接比较两个值，其结果是相等的。</li>
<li>若把两个值转为布尔值，它们可能得出完全相反的结果，即一个是 <code>true</code>，一个是 <code>false</code>。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(a) ); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">&quot;0&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(b) ); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a == b); <span class="comment">// true!</span></span><br></pre></td></tr></table></figure>

<p>对于 JavaScript 而言，这种现象其实挺正常的。因为 JavaScript 会把待比较的值转化为数字后再做比较（因此 <code>&quot;0&quot;</code> 变成了 <code>0</code>）。若只是将一个变量转化为 <code>Boolean</code> 值，则会使用其他的类型转换规则。</p>
<h2 id="严格相等"><a href="#严格相等" class="headerlink" title="严格相等"></a>严格相等</h2><p>普通的相等性检查 <code>==</code> 存在一个问题，它不能区分出 <code>0</code> 和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>也同样无法区分空字符串和 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;&#x27;</span> == <span class="literal">false</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>这是因为在比较不同类型的值时，处于相等判断符号 <code>==</code> 两侧的值会先被转化为数字。空字符串和 <code>false</code> 也是如此，转化后它们都为数字 0。</p>
<p>如果我们需要区分 <code>0</code> 和 <code>false</code>，该怎么办？</p>
<p><strong>严格相等运算符 <code>===</code> 在进行比较时不会做任何的类型转换。</strong></p>
<p>换句话说，如果 <code>a</code> 和 <code>b</code> 属于不同的数据类型，那么 <code>a === b</code> 不会做任何的类型转换而立刻返回 <code>false</code>。</p>
<p>让我们试试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> === <span class="literal">false</span> ); <span class="comment">// false，因为被比较值的数据类型不同</span></span><br></pre></td></tr></table></figure>

<p>同样的，与“不相等”符号 <code>!=</code> 类似，“严格不相等”表示为 <code>!==</code>。</p>
<p>严格相等的运算符虽然写起来稍微长一些，但是它能够很清楚地显示代码意图，降低你犯错的可能性。</p>
<h2 id="对-null-和-undefined-进行比较"><a href="#对-null-和-undefined-进行比较" class="headerlink" title="对 null 和 undefined 进行比较"></a>对 null 和 undefined 进行比较</h2><p>当使用 <code>null</code> 或 <code>undefined</code> 与其他值进行比较时，其返回结果常常出乎你的意料。</p>
<ul>
<li><p>当使用严格相等 <code>===</code> 比较二者时</p>
<p>它们不相等，因为它们属于不同的类型。<br><code>console.log( null === undefined ); // false</code></p>
</li>
<li><p>当使用非严格相等 <code>==</code> 比较二者时<br>JavaScript 存在一个特殊的规则，会判定它们相等。它们俩就像“一对恋人”，仅仅等于对方而不等于其他任何的值（只在非严格相等下成立）。<br><code>console.log( null == undefined ); // true</code></p>
</li>
<li><p>当使用数学式或其他比较方法 <code>&lt; &gt; &lt;= &gt;=</code> 时：<br><code>null/undefined</code> 会被转化为数字：<code>null</code> 被转化为 <code>0</code>，<code>undefined</code> 被转化为 <code>NaN</code>。</p>
</li>
</ul>
<p>下面让我们看看，这些规则会带来什么有趣的现象。同时更重要的是，我们需要从中学会如何远离这些特性带来的“陷阱”。</p>
<h3 id="奇怪的结果：null-vs-0"><a href="#奇怪的结果：null-vs-0" class="headerlink" title="奇怪的结果：null vs 0"></a>奇怪的结果：null vs 0</h3><p>通过比较 <code>null</code> 和 0 可得：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> &gt; <span class="number">0</span> );  <span class="comment">//  （1）false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> == <span class="number">0</span> ); <span class="comment">//  （2）false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> &gt;= <span class="number">0</span> ); <span class="comment">//  （3）true</span></span><br></pre></td></tr></table></figure>

<p>为什么会出现这种反常结果，这是因为相等性检查 <code>==</code> 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。<br>进行值的比较时，<code>null</code> 会被转化为数字，因此它被转化为了 <code>0</code>。这就是为什么（3）中 <code>null &gt;= 0</code> 返回值是 true，（1）中 <code>null &gt; 0</code> 返回值是 false。</p>
<p>另一方面，<code>undefined</code> 和 <code>null</code> 在相等性检查 <code>==</code> 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 <code>null == 0</code> 会返回 false。</p>
<h3 id="特立独行的-undefined"><a href="#特立独行的-undefined" class="headerlink" title="特立独行的 undefined"></a>特立独行的 undefined</h3><p><code>undefined</code> 不应该被与其他值进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">undefined</span> &gt; <span class="number">0</span> ); <span class="comment">// false (1)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">undefined</span> &lt; <span class="number">0</span> ); <span class="comment">// false (2)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">undefined</span> == <span class="number">0</span> ); <span class="comment">// false (3)</span></span><br></pre></td></tr></table></figure>

<p>为何它看起来如此厌恶 0？返回值都是 false！</p>
<p>原因如下：</p>
<ul>
<li><code>(1)</code> 和 <code>(2)</code> 都返回 <code>false</code> 是因为 <code>undefined</code> 在比较中被转换为了 <code>NaN</code>，而 <code>NaN</code> 是一个特殊的数值型值，它与任何值进行比较都会返回 <code>false</code>。</li>
<li><code>(3)</code> 返回 <code>false</code> 是因为这是一个相等性检查，而 <code>undefined</code> 只与 <code>null</code> 相等，不会与其他值相等。</li>
</ul>
<h3 id="避免问题"><a href="#避免问题" class="headerlink" title="避免问题"></a>避免问题</h3><p>我们为何要研究上述示例？我们需要时刻记得这些古怪的规则吗？不，其实不需要。虽然随着代码写得越来越多，我们对这些规则也都会烂熟于胸，但是我们需要更为可靠的方法来避免潜在的问题：</p>
<ul>
<li>除了严格相等 <code>===</code> 外，其他但凡是有 <code>undefined/null</code> 参与的比较，我们都需要格外小心。</li>
<li>除非你非常清楚自己在做什么，否则永远不要使用 <code>&gt;= &gt; &lt; &lt;=</code> 去比较一个可能为 <code>null/undefined</code> 的变量。对于取值可能是 <code>null/undefined</code> 的变量，请按需要分别检查它的取值情况。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>比较运算符始终返回布尔值。</li>
<li>字符串的比较，会按照“词典”顺序逐字符地比较大小。</li>
<li>当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。</li>
<li>在非严格相等 <code>==</code> 下，<code>null</code> 和 <code>undefined</code> 相等且各自不等于任何其他的值。</li>
<li>在使用 <code>&gt;</code> 或 <code>&lt;</code> 进行比较时，需要注意变量可能为 <code>null/undefined</code> 的情况。比较好的方法是单独检查变量是否等于 <code>null/undefined</code>。</li>
</ul>
<hr>
<h1 id="条件分支：if-和-‘-’"><a href="#条件分支：if-和-‘-’" class="headerlink" title="条件分支：if 和 ‘?’"></a>条件分支：if 和 ‘?’</h1><p>有时我们需要根据不同条件执行不同的操作。</p>
<p>我们可以使用 <code>if</code> 语句和条件运算符 <code>?</code>（也称为“问号”运算符）来实现。</p>
<h2 id="“if”-语句"><a href="#“if”-语句" class="headerlink" title="“if” 语句"></a>“if” 语句</h2><p><code>if(...)</code> 语句计算括号里的条件表达式，如果计算结果是 <code>true</code>，就会执行对应的代码块。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="number">2024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">2024</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;没错，今年正是2024年&#x27;</span> );</span><br></pre></td></tr></table></figure>

<p>在上面这个例子中，条件是一个简单的相等性检查（<code>year == 2024</code>），但它还可以更复杂。</p>
<p>如果有多个语句要执行，我们必须将要执行的代码块封装在大括号内：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="number">2024</span>;</span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">2024</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;正确!&quot;</span> );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;你真聪明!&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议每次使用 if 语句都用大括号 <code>&#123;&#125;</code> 来包装代码块，即使只有一条语句。这样可以提高代码可读性。</p>
<h2 id="布尔转换"><a href="#布尔转换" class="headerlink" title="布尔转换"></a>布尔转换</h2><p><code>if (…)</code> 语句会计算圆括号内的表达式，并将计算结果转换为布尔型。</p>
<p>让我们回顾一下 <a href="https://zh.javascript.info/type-conversions">类型转换</a> 一章中的转换规则：</p>
<ul>
<li>数字 <code>0</code>、空字符串 <code>&quot;&quot;</code>、<code>null</code>、<code>undefined</code> 和 <code>NaN</code> 都会被转换成 <code>false</code>。因为它们被称为“假值（falsy）”。</li>
<li>其他值被转换为 <code>true</code>，所以它们被称为“真值（truthy）”。</li>
</ul>
<p>所以，下面这个条件下的代码永远不会执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">// 0 是假值（falsy）</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……但下面的条件 —— 始终有效：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; <span class="comment">// 1 是真值（truthy）</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以将预先计算的布尔值传入 <code>if</code> 语句，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="number">2024</span>;</span><br><span class="line"><span class="keyword">let</span> cond = (year == <span class="number">2024</span>); <span class="comment">// 相等运算符的结果是 true 或 false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cond) </span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="“else”-语句"><a href="#“else”-语句" class="headerlink" title="“else” 语句"></a>“else” 语句</h2><p><code>if</code> 语句有时会包含一个可选的 “else” 块。如果判断条件不成立，就会执行它内部的代码。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="number">2025</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year == <span class="number">2024</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;年份不对哦&#x27;</span> );</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;只要不等于2024，都会看到这句话&#x27;</span> ); <span class="comment">// 2024 以外的任何值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多个条件：“else-if”"><a href="#多个条件：“else-if”" class="headerlink" title="多个条件：“else if”"></a>多个条件：“else if”</h2><p>有时我们需要测试一个条件的几个变体。我们可以通过使用 <code>else if</code> 子句实现。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> year = <span class="number">2022</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year &lt; <span class="number">2024</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Too early...&#x27;</span> );</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (year &gt; <span class="number">2024</span>) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Too late&#x27;</span> );</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Exactly!&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，JavaScript 先检查 <code>year &lt; 2024</code>。如果条件不符合，就会转到下一个条件 <code>year &gt; 2024</code>。如果这个条件也不符合，则会显示最后一个 <code>console.log</code>。</p>
<p>可以有更多的 <code>else if</code> 块。结尾的 <code>else</code> 是可选的。</p>
<h2 id="条件运算符-‘-’"><a href="#条件运算符-‘-’" class="headerlink" title="条件运算符 ‘?’"></a>条件运算符 ‘?’</h2><p>有时我们需要根据一个条件去赋值一个变量。</p>
<p>如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> accessAllowed;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">18</span>) </span><br><span class="line">&#123;</span><br><span class="line">  accessAllowed = <span class="literal">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">  accessAllowed = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(accessAllowed);</span><br></pre></td></tr></table></figure>

<p>所谓的“条件”或“问号”运算符让我们可以更简短地达到目的。</p>
<p>这个运算符通过问号 <code>?</code> 表示。有时它被称为三元运算符，被称为“三元”是因为该运算符中有三个操作数。实际上它是 JavaScript 中唯一一个有这么多操作数的运算符。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = condition ? value1 : value2;</span><br></pre></td></tr></table></figure>

<p>计算（condition）结果，如果结果为真，则返回 <code>value1</code>，否则返回 <code>value2</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age =<span class="number">24</span>;</span><br><span class="line"><span class="keyword">let</span> accessAllowed = (age &gt; <span class="number">18</span>) ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>技术上讲，我们可以省略 <code>age &gt; 18</code> 外面的括号。问号运算符的优先级较低，所以它会在比较运算符 <code>&gt;</code> 后执行。</p>
<p>下面这个示例会执行和前面那个示例相同的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 比较运算符 &quot;age &gt; 18&quot; 首先执行</span></span><br><span class="line"><span class="comment">//（不需要将其包含在括号中）</span></span><br><span class="line"><span class="keyword">let</span> accessAllowed = age &gt; <span class="number">18</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>但括号可以使代码可读性更强，所以我们建议使用它们。</p>
<p><strong>请注意：</strong></p>
<p>在上面的例子中，你可以不使用问号运算符，因为比较本身就返回 <code>true/false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码同样可以实现</span></span><br><span class="line"><span class="keyword">let</span> accessAllowed = age &gt; <span class="number">18</span>;</span><br></pre></td></tr></table></figure>

<h2 id="多个-‘-’"><a href="#多个-‘-’" class="headerlink" title="多个 ‘?’"></a>多个 ‘?’</h2><p>使用一系列问号 <code>?</code> 运算符可以返回一个取决于多个条件的值。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> message = (age &lt; <span class="number">3</span>) ? <span class="string">&#x27;小宝贝!&#x27;</span> :</span><br><span class="line">  (age &lt; <span class="number">18</span>) ? <span class="string">&#x27;小孩子&#x27;</span> :</span><br><span class="line">  (age &lt; <span class="number">100</span>) ? <span class="string">&#x27;你肯定成年了&#x27;</span> :</span><br><span class="line">  <span class="string">&#x27;洪福齐天！&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( message );</span><br></pre></td></tr></table></figure>

<ol>
<li>第一个问号检查 <code>age &lt; 3</code>。</li>
<li>如果为真 — 返回 <code>&#39;Hi, baby!&#39;</code>。否则，会继续执行冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 18</code>。</li>
<li>如果为真 — 返回 <code>&#39;Hello!&#39;</code>。否则，会继续执行下一个冒号 <code>&quot;:&quot;</code> 后的表达式，检查 <code>age &lt; 100</code>。</li>
<li>如果为真 — 返回 <code>&#39;Greetings!&#39;</code>。否则，会继续执行最后一个冒号 <code>&quot;:&quot;</code> 后面的表达式，返回 <code>&#39;What an unusual age!&#39;</code>。</li>
</ol>
<p>这是使用 <code>if..else</code> 实现上面的逻辑的写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">3</span>) &#123;</span><br><span class="line">  message = <span class="string">&#x27;小宝贝!&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">  message = <span class="string">&#x27;小孩子&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">100</span>) &#123;</span><br><span class="line">  message = <span class="string">&#x27;你肯定成年了&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  message = <span class="string">&#x27;洪福齐天！&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‘-’-的非常规使用"><a href="#‘-’-的非常规使用" class="headerlink" title="‘?’ 的非常规使用"></a>‘?’ 的非常规使用</h2><p>有时可以使用问号 <code>?</code> 来代替 <code>if</code> 语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;今年是哪一年？&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> year = <span class="number">2022</span> ;</span><br><span class="line">(year == <span class="string">&#x27;2024&#x27;</span>) ?</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;答对了!&#x27;</span>) : <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误，今年是2024年哦&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>根据条件 <code>year ==&#39;2024&#39;</code>，要么执行 <code>?</code> 后面的第一个表达式并显示对应内容，要么执行第二个表达式并显示对应内容。</p>
<p>在这里我们不是把结果赋值给变量。而是根据条件执行不同的代码。</p>
<p><strong>不建议这样使用问号运算符。</strong></p>
<p>这种写法比 <code>if</code> 语句更短，对一些程序员很有吸引力。但它的可读性差。</p>
<p>下面是使用 <code>if</code> 语句实现相同功能的代码，进行下比较：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;今年是哪一年？&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> year = <span class="number">2022</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (year == <span class="string">&#x27;2024&#x27;</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;答对了!&#x27;</span>) ;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误，今年是2024年哦&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为我们的眼睛垂直扫描代码。所以，跨越几行的代码块比长而水平的代码更易于理解。</p>
<p>问号 <code>?</code> 的作用是根据条件返回其中一个值。请正确使用它。当需要执行不同的代码分支时，请使用 <code>if</code>。</p>
<hr>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><p>JavaScript 中有四个逻辑运算符：<code>||</code>（或），<code>&amp;&amp;</code>（与），<code>!</code>（非），<code>??</code>（空值合并运算符）。本文我们先介绍前三个，在下一篇文章中再详细介绍 <code>??</code> 运算符。</p>
<p>虽然它们被称为“逻辑”运算符，但这些运算符却可以被应用于任意类型的值，而不仅仅是布尔值。它们的结果也同样可以是任意类型。</p>
<h2 id="（或）"><a href="#（或）" class="headerlink" title="||（或）"></a>||（或）</h2><p>两个竖线符号表示“或”运算符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = a || b;</span><br></pre></td></tr></table></figure>

<p>在传统的编程中，逻辑 <code>或</code> 仅能够操作布尔值。如果参与运算的任意一个参数为 <code>true</code>，返回的结果就为 <code>true</code>，否则返回 <code>false</code>。</p>
<p>在 JavaScript 中，逻辑运算符更加灵活强大。但是，首先让我们看一下操作数是布尔值的时候发生了什么。</p>
<p>下面是四种可能的逻辑组合：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> || <span class="literal">true</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> || <span class="literal">true</span> );  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> || <span class="literal">false</span> );  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> || <span class="literal">false</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>正如我们所见，除了两个操作数都是 <code>false</code> 的情况，结果都是 <code>true</code>。</p>
<p>如果操作数不是布尔值，那么它将会被转化为布尔值来参与运算。</p>
<p>例如，数字 <code>1</code> 被作为 <code>true</code> 处理，数字 <code>0</code> 则被作为 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span> || <span class="number">0</span>) &#123; <span class="comment">// 工作原理相当于 if( true || false )</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;truthy!&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数情况下，逻辑或 <code>||</code> 会被用在 <code>if</code> 语句中，用来测试是否有 <strong>任何</strong> 给定的条件为 <code>true</code>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hour = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hour &lt; <span class="number">10</span> || hour &gt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;超市的门是关着的。&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以传入更多的条件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hour = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> isWeekend = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hour &lt; <span class="number">10</span> || hour &gt; <span class="number">18</span> || isWeekend) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;超市的门是关着的。&#x27;</span> ); <span class="comment">// 是周末</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="或运算寻找第一个真值"><a href="#或运算寻找第一个真值" class="headerlink" title="或运算寻找第一个真值"></a>或运算寻找第一个真值</h2><p>上文提到的逻辑处理多少有些传统了。下面让我们看看 JavaScript 的“附加”特性。</p>
<p>拓展的算法如下所示。</p>
<p>给定多个参与或运算的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = value1 || value2 || value3;</span><br></pre></td></tr></table></figure>

<p>或运算符 <code>||</code> 做了如下的事情：</p>
<ul>
<li>从左到右依次计算操作数。</li>
<li>处理每一个操作数时，都将其转化为布尔值。如果结果是 <code>true</code>，就停止计算，返回这个操作数的初始值。</li>
<li>如果所有的操作数都被计算过（也就是，转换结果都是 <code>false</code>），则返回最后一个操作数。</li>
</ul>
<p>返回的值是操作数的初始形式，不会做布尔转换。</p>
<p>换句话说，一个或运算 <code>||</code> 的链，将返回第一个真值，如果不存在真值，就返回该链的最后一个值。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">1</span> || <span class="number">0</span> ); <span class="comment">// 1（1 是真值）</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> || <span class="number">1</span> ); <span class="comment">// 1（1 是第一个真值）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> || <span class="number">0</span> || <span class="number">1</span> ); <span class="comment">// 1（第一个真值）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> || <span class="number">0</span> || <span class="string">&#x27;你好&#x27;</span> ); <span class="comment">// 你好</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">undefined</span> || <span class="literal">null</span> || <span class="number">0</span> ); <span class="comment">// 0（都是假值，返回最后一个值）</span></span><br></pre></td></tr></table></figure>

<p>与“纯粹的、传统的、仅仅处理布尔值的或运算”相比，这个规则就引起了一些很有趣的用法。</p>
<ol>
<li><p><strong>获取变量列表或者表达式中的第一个真值。</strong></p>
<p>例如，我们有变量 <code>firstName</code>、<code>lastName</code> 和 <code>nickName</code>，都是可选的（即可以是 undefined，也可以是假值）。</p>
<p>我们用或运算 <code>||</code> 来选择有数据的那一个，并显示出来（如果没有设置，则用 <code>&quot;Anonymous&quot;</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;超级虎哥&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( firstName || lastName || nickName || <span class="string">&quot;孙悟空&quot;</span>); <span class="comment">// 超级虎哥</span></span><br></pre></td></tr></table></figure>

<p>如果所有变量的值都为假，结果就是 <code>&quot;孙悟空&quot;</code>。</p>
</li>
<li><p><strong>短路求值（Short-circuit evaluation）。</strong></p>
<p>或运算符 <code>||</code> 的另一个用途是所谓的“短路求值”。</p>
<p>这指的是，<code>||</code> 对其参数进行处理，直到达到第一个真值，然后立即返回该值，而无需处理其他参数。</p>
<p>如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这一特性的重要性就变得显而易见了。</p>
<p>在下面这个例子中，只会打印第二条信息：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> || <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这条信息不会打印&quot;</span>);</span><br><span class="line"><span class="literal">false</span> || <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;打印出来了&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在第一行中，或运算符 <code>||</code> 在遇到 <code>true</code> 时立即停止运算，所以 <code>console.log</code> 没有运行。</p>
<p>有时，人们利用这个特性，只在左侧的条件为假时才执行命令。</p>
</li>
</ol>
<h2 id="（与）"><a href="#（与）" class="headerlink" title="&amp;&amp;（与）"></a>&amp;&amp;（与）</h2><p>两个 &amp; 符号表示 <code>&amp;&amp;</code> 与运算符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = a &amp;&amp; b;</span><br></pre></td></tr></table></figure>

<p>在传统的编程中，当两个操作数都是真值时，与运算返回 <code>true</code>，否则返回 <code>false</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> &amp;&amp; <span class="literal">true</span> );   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> &amp;&amp; <span class="literal">true</span> );  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">true</span> &amp;&amp; <span class="literal">false</span> );  <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">false</span> &amp;&amp; <span class="literal">false</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>带有 <code>if</code> 语句的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> hour = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> minute = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hour == <span class="number">12</span> &amp;&amp; minute == <span class="number">30</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;当前时间是 12:30&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像或运算一样，与运算的操作数可以是任意类型的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span> &amp;&amp; <span class="number">0</span>) &#123; <span class="comment">// 作为 true &amp;&amp; false 来执行</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;这条信息不会输出，因为条件是false。&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="与运算寻找第一个假值"><a href="#与运算寻找第一个假值" class="headerlink" title="与运算寻找第一个假值"></a>与运算寻找第一个假值</h2><p>给出多个参加与运算的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = value1 &amp;&amp; value2 &amp;&amp; value3;</span><br></pre></td></tr></table></figure>

<p>与运算 <code>&amp;&amp;</code> 做了如下的事：</p>
<ul>
<li>从左到右依次计算操作数。</li>
<li>在处理每一个操作数时，都将其转化为布尔值。如果结果是 <code>false</code>，就停止计算，并返回这个操作数的初始值。</li>
<li>如果所有的操作数都被计算过（例如都是真值），则返回最后一个操作数。</li>
</ul>
<p>换句话说，与运算返回第一个假值，如果没有假值就返回最后一个值。</p>
<p>上面的规则和或运算很像。区别就是与运算返回第一个假值，而或运算返回第一个真值。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果第一个操作数是真值，</span></span><br><span class="line"><span class="comment">// 与运算返回第二个操作数：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">1</span> &amp;&amp; <span class="number">0</span> ); <span class="comment">// 0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">1</span> &amp;&amp; <span class="number">5</span> ); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果第一个操作数是假值，</span></span><br><span class="line"><span class="comment">// 与运算将直接返回它。第二个操作数会被忽略</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="literal">null</span> &amp;&amp; <span class="number">5</span> ); <span class="comment">// null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">0</span> &amp;&amp; <span class="string">&quot;no matter what&quot;</span> ); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>我们也可以在一行代码上串联多个值。查看第一个假值是如何被返回的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="number">3</span> ); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>如果所有的值都是真值，最后一个值将会被返回：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="number">1</span> &amp;&amp; <span class="number">2</span> &amp;&amp; <span class="number">3</span> ); <span class="comment">// 3，最后一个值</span></span><br></pre></td></tr></table></figure>

<p><strong>与运算 <code>&amp;&amp;</code> 在 或运算 <code>||</code> 之前进行</strong></p>
<p>与运算 <code>&amp;&amp;</code> 的优先级 比 或运算 <code>||</code> 要高。</p>
<p>所以代码 <code>a &amp;&amp; b || c &amp;&amp; d</code> 跟 <code>&amp;&amp;</code> 表达式加了括号完全一样：<code>(a &amp;&amp; b) || (c &amp;&amp; d)</code>。</p>
<p><strong>不要用 <code>||</code> 或 <code>&amp;&amp;</code> 来取代 <code>if</code></strong></p>
<p>有时候，有人会将与运算符 <code>&amp;&amp;</code> 作为“简化 <code>if</code>”的一种方式。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">(x &gt; <span class="number">0</span>) &amp;&amp; <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;大于零&#x27;</span> );</span><br></pre></td></tr></table></figure>

<p><code>&amp;&amp;</code> 右边的代码只有运算抵达到那里才能被执行。也就是，当且仅当 <code>(x &gt; 0)</code> 为真。</p>
<p>所以我们基本可以类似地得到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;大于零!&#x27;</span> );</span><br></pre></td></tr></table></figure>

<p>虽然使用 <code>&amp;&amp;</code> 写出的变体看起来更短，但 <code>if</code> 更明显，并且往往更具可读性。因此，我们建议根据每个语法结构的用途来使用：如果我们想要 <code>if</code>，就使用 <code>if</code>；如果我们想要逻辑与，就使用 <code>&amp;&amp;</code>。</p>
<h2 id="（非）"><a href="#（非）" class="headerlink" title="!（非）"></a>!（非）</h2><p>感叹符号 <code>!</code> 表示布尔非运算符。</p>
<p>语法相当简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = !value;</span><br></pre></td></tr></table></figure>

<p>逻辑非运算符接受一个参数，并按如下运作：</p>
<ol>
<li>将操作数转化为布尔类型：<code>true/false</code>。</li>
<li>返回相反的值。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( !<span class="literal">true</span> ); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( !<span class="number">0</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>两个非运算 <code>!!</code> 有时候用来将某个值转化为布尔类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( !!<span class="string">&quot;non-empty string&quot;</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( !!<span class="literal">null</span> ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>也就是，第一个非运算将该值转化为布尔类型并取反，第二个非运算再次取反。最后我们就得到了一个任意值到布尔值的转化。</p>
<p>有一个略显冗长的方式也可以实现同样的效果 —— 一个内建的 <code>Boolean</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="string">&quot;non-empty string&quot;</span>) ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Boolean</span>(<span class="literal">null</span>) ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="非运算符-的优先级在所有逻辑运算符里面最高，所以它总是在-和-之前执行。https-zh-javascript-info-logical-operators"><a href="#非运算符-的优先级在所有逻辑运算符里面最高，所以它总是在-和-之前执行。https-zh-javascript-info-logical-operators" class="headerlink" title="非运算符 ! 的优先级在所有逻辑运算符里面最高，所以它总是在 &amp;&amp; 和 || 之前执行。https://zh.javascript.info/logical-operators"></a>非运算符 <code>!</code> 的优先级在所有逻辑运算符里面最高，所以它总是在 <code>&amp;&amp;</code> 和 <code>||</code> 之前执行。<br><a href="https://zh.javascript.info/logical-operators">https://zh.javascript.info/logical-operators</a></h2><hr>
<h1 id="空值合并运算符-‘-‘"><a href="#空值合并运算符-‘-‘" class="headerlink" title="空值合并运算符 ‘ ?? ‘"></a>空值合并运算符 ‘ ?? ‘</h1><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.</p>
<p>空值合并运算符（nullish coalescing operator）的写法为两个问号 <code>??</code>。</p>
<p>由于它对待 <code>null</code> 和 <code>undefined</code> 的方式类似，所以在本文中我们将使用一个特殊的术语对其进行表示。为简洁起见，当一个值既不是 <code>null</code> 也不是 <code>undefined</code> 时，我们将其称为“已定义的（defined）”。</p>
<p><code>a ?? b</code> 的结果是：</p>
<ul>
<li>如果 <code>a</code> 是已定义的，则结果为 <code>a</code>，</li>
<li>如果 <code>a</code> 不是已定义的，则结果为 <code>b</code>。</li>
</ul>
<p>换句话说，如果第一个参数不是 <code>null/undefined</code>，则 <code>??</code> 返回第一个参数。否则，返回第二个参数。</p>
<p>空值合并运算符并不是什么全新的东西。它只是一种获得两者中的第一个“已定义的”值的不错的语法。</p>
<p>我们可以使用我们已知的运算符重写 <code>result = a ?? b</code>，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">result = (a !== <span class="literal">null</span> &amp;&amp; a !== <span class="literal">undefined</span>) ? a : b;</span><br></pre></td></tr></table></figure>

<p>现在你应该清楚了 <code>??</code> 的作用。让我们来看看它的使用场景吧。</p>
<p><code>??</code> 的常见使用场景是提供默认值。</p>
<p>例如，在这里，如果 <code>user</code> 的值不为 <code>null/undefined</code> 则显示 <code>user</code>，否则显示 <code>匿名</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user ?? <span class="string">&quot;匿名&quot;</span>); <span class="comment">// 匿名（user 未定义）</span></span><br></pre></td></tr></table></figure>

<p>在下面这个例子中，我们将一个名字赋值给了 <code>user</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user ?? <span class="string">&quot;匿名&quot;</span>); <span class="comment">// John（user 已定义）</span></span><br></pre></td></tr></table></figure>

<p>我们还可以使用 <code>??</code> 序列从一系列的值中选择出第一个非 <code>null/undefined</code> 的值。</p>
<p>假设我们在变量 <code>firstName</code>、<code>lastName</code> 或 <code>nickName</code> 中存储着一个用户的数据。如果用户决定不填写相应的值，则所有这些变量的值都可能是未定义的。</p>
<p>我们想使用这些变量之一显示用户名，如果这些变量的值都是 <code>null/undefined</code>，则显示 “匿名”。</p>
<p>让我们使用 <code>??</code> 运算符来实现这一需求：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;Supercoder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示第一个已定义的值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName ?? lastName ?? nickName ?? <span class="string">&quot;匿名&quot;</span>); <span class="comment">// Supercoder</span></span><br></pre></td></tr></table></figure>

<h2 id="与-比较"><a href="#与-比较" class="headerlink" title="与 || 比较"></a>与 || 比较</h2><p>或运算符 <code>||</code> 可以以与 <code>??</code> 运算符相同的方式使用。像我们在 <a href="https://zh.javascript.info/logical-operators#or-finds-the-first-truthy-value">上一章</a> 所讲的那样。</p>
<p>例如，在上面的代码中，我们可以用 <code>||</code> 替换掉 <code>??</code>，也可以获得相同的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> lastName = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nickName = <span class="string">&quot;Supercoder&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示第一个真值：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(firstName || lastName || nickName || <span class="string">&quot;Anonymous&quot;</span>); <span class="comment">// Supercoder</span></span><br></pre></td></tr></table></figure>

<p>纵观 JavaScript 发展史，或 <code>||</code> 运算符先于 <code>??</code> 出现。它自 JavaScript 诞生就存在了，因此开发者长期将其用于这种目的。</p>
<p>另一方面，空值合并运算符 <code>??</code> 是最近才被添加到 JavaScript 中的，它的出现是因为人们对 <code>||</code> 不太满意。</p>
<p>它们之间重要的区别是：</p>
<ul>
<li><code>||</code> 返回第一个 <strong>真</strong> 值。</li>
<li><code>??</code> 返回第一个 <strong>已定义的</strong> 值。</li>
</ul>
<p>换句话说，<code>||</code> 无法区分 <code>false</code>、<code>0</code>、空字符串 <code>&quot;&quot;</code> 和 <code>null/undefined</code>。它们都一样 —— 假值（falsy values）。如果其中任何一个是 <code>||</code> 的第一个参数，那么我们将得到第二个参数作为结果。</p>
<p>不过在实际中，我们可能只想在变量的值为 <code>null/undefined</code> 时使用默认值。也就是说，当该值确实未知或未被设置时。</p>
<p>例如，考虑下面这种情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> height = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(height || <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(height ?? <span class="number">100</span>); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>height || 100</code> 首先会检查 <code>height</code>  是否为一个假值，它是 <code>0</code>  ，确实是假值。</p>
<ul>
<li>所以，<code>||</code> 运算的结果为第二个参数，<code>100</code>。</li>
</ul>
</li>
<li><p><code>height ?? 100</code>  首先会检查 <code>height</code>  是否为 <code>null/undefined</code>  ，发现它不是。</p>
<ul>
<li>所以，结果为 <code>height</code> 的原始值，<code>0</code>。</li>
</ul>
</li>
</ul>
<p>实际上，高度 <code>0</code> 通常是一个有效值，它不应该被替换为默认值。所以 <code>??</code> 运算得到的是正确的结果。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p><code>??</code> 运算符的优先级与 <code>||</code> 相同，它们的优先级都为 <code>3</code>，详见：<a href="https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table">MDN</a>。</p>
<p>这意味着，就像 <code>||</code> 一样，空值合并运算符在 <code>=</code> 和 <code>?</code> 运算前计算，但在大多数其他运算（例如 <code>+</code> 和 <code>*</code>）之后计算。</p>
<p>所以我们可能需要在这样的表达式中添加括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> height = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> width = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重要：使用括号</span></span><br><span class="line"><span class="keyword">let</span> area = (height ?? <span class="number">100</span>) * (width ?? <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(area); <span class="comment">// 5000</span></span><br></pre></td></tr></table></figure>

<p>否则，如果我们省略了括号，则由于 <code>*</code> 的优先级比 <code>??</code> 高，它会先执行，进而导致错误的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有括号</span></span><br><span class="line"><span class="keyword">let</span> area = height ?? <span class="number">100</span> * width ?? <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……实际的计算顺序如下（不符合我们的期望）：</span></span><br><span class="line"><span class="keyword">let</span> area = height ?? (<span class="number">100</span> * width) ?? <span class="number">50</span>;</span><br></pre></td></tr></table></figure>

<h3 id="与-或-一起使用"><a href="#与-或-一起使用" class="headerlink" title="?? 与 &amp;&amp; 或 || 一起使用"></a>?? 与 &amp;&amp; 或 || 一起使用</h3><p>出于安全原因，JavaScript 禁止将 <code>??</code> 运算符与 <code>&amp;&amp;</code> 和 <code>||</code> 运算符一起使用，除非使用括号明确指定了优先级。</p>
<p>下面的代码会触发一个语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span> &amp;&amp; <span class="number">2</span> ?? <span class="number">3</span>; <span class="comment">// Syntax error</span></span><br></pre></td></tr></table></figure>

<p>这个限制无疑是值得商榷的，它被添加到语言规范中是为了避免人们从 <code>||</code> 切换到 <code>??</code> 时的编程错误。</p>
<p>可以明确地使用括号来解决这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = (<span class="number">1</span> &amp;&amp; <span class="number">2</span>) ?? <span class="number">3</span>; <span class="comment">// 正常工作了</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>空值合并运算符 <code>??</code> 提供了一种从列表中选择第一个“已定义的”值的简便方式。</p>
<p>它被用于为变量分配默认值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当 height 的值为 null 或 undefined 时，将 height 的值设置为 100</span></span><br><span class="line">height = height ?? <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>??</code> 运算符的优先级非常低，仅略高于 <code>?</code> 和 <code>=</code>，因此在表达式中使用它时请考虑添加括号。</p>
</li>
<li><p>如果没有明确添加括号，不能将其与 <code>||</code> 或 <code>&amp;&amp;</code> 一起使用。</p>
</li>
</ul>
<hr>
<h1 id="循环：while-和-for"><a href="#循环：while-和-for" class="headerlink" title="循环：while 和 for"></a>循环：while 和 for</h1><p>我们经常需要重复执行一些操作。<strong>循环</strong> 是一种重复运行同一代码的方法。</p>
<p><strong>for…of 和 for…in 循环</strong></p>
<p>本文仅涵盖了基础的循环：<code>while</code>，<code>do..while</code> 和 <code>for(..; ..; ..)</code>。</p>
<p>如果你阅读本文是为了寻找其他类型的循环，那么：</p>
<ul>
<li>用于遍历对象属性的 <code>for..in</code> 循环请见：<a href="https://zh.javascript.info/object#forin">for…in</a>。</li>
<li>用于遍历数组和可迭代对象的循环分别请见：<a href="https://zh.javascript.info/array#xun-huan">for…of</a> 和 <a href="https://zh.javascript.info/iterable">iterables</a>。</li>
</ul>
<h2 id="“while”-循环"><a href="#“while”-循环" class="headerlink" title="“while” 循环"></a>“while” 循环</h2><p><code>while</code> 循环的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">  <span class="comment">// 代码</span></span><br><span class="line">  <span class="comment">// 所谓的“循环体”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>condition</code> 为真时，执行循环体的 <code>code</code>。</p>
<p>例如，以下将循环输出当 <code>i &lt; 3</code> 时的 <code>i</code> 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">3</span>) &#123; <span class="comment">// 依次显示 0、1 和 2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环体的单次执行（一次循环）叫作 <strong>一次迭代</strong>。上面示例中的循环进行了三次迭代。</p>
<p>如果上述示例中没有 <code>i++</code>，那么循环（理论上）会永远重复执行下去。实际上，浏览器提供了阻止这种循环的方法，我们可以通过终止进程，来停掉服务器端的 JavaScript。</p>
<p>任何表达式或变量都可以是循环条件，而不仅仅是比较。在 <code>while</code> 中的循环条件会被计算，计算结果会被转化为布尔值。</p>
<p>例如，<code>while (i != 0)</code> 可简写为 <code>while (i)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (i) &#123; <span class="comment">// 当 i 变成 0 时，条件为假，循环终止</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">  i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单行循环体不需要大括号</strong></p>
<p>如果循环体只有一条语句，则可以省略大括号 <code>&#123;…&#125;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (i) <span class="variable language_">console</span>.<span class="title function_">log</span>(i--);</span><br></pre></td></tr></table></figure>

<h2 id="“do…while”-循环"><a href="#“do…while”-循环" class="headerlink" title="“do…while” 循环"></a>“do…while” 循环</h2><p>使用 <code>do..while</code> 语法可以将条件检查移至循环体 <strong>下面</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>

<p>循环首先执行一次循环体，然后再检查条件，当条件为真时，重复执行循环体。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">  i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>这种形式的语法很少使用，除非你希望不管条件是否为真，循环体 <strong>至少执行一次</strong>。通常我们更倾向于使用另一个形式：<code>while(…) &#123;…&#125;</code>。</p>
<h2 id="“for”-循环"><a href="#“for”-循环" class="headerlink" title="“for” 循环"></a>“for” 循环</h2><p><code>for</code> 循环更加复杂，但它是最常使用的循环形式。</p>
<p><code>for</code> 循环看起来就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (begin; condition; step) &#123;</span><br><span class="line">  <span class="comment">// ……循环体……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过示例来了解一下这三个部分的含义。<br>下述循环从 <code>i</code> 等于 <code>0</code> 到 <code>3</code>（但不包括 <code>3</code>）运行 <code>console.log(i)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 结果为 0、1、2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们逐个部分分析 <code>for</code> 循环：</p>
<table>
<thead>
<tr>
<th align="left">语句段</th>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">begin</td>
<td align="left"><code>let i = 0</code></td>
<td align="left">进入循环时执行一次。</td>
</tr>
<tr>
<td align="left">condition</td>
<td align="left"><code>i &lt; 3</code></td>
<td align="left">在每次循环迭代之前检查，如果为 false，停止循环。</td>
</tr>
<tr>
<td align="left">body（循环体）</td>
<td align="left"><code>console.log(i)</code></td>
<td align="left">条件为真时，重复运行。</td>
</tr>
<tr>
<td align="left">step</td>
<td align="left"><code>i++</code></td>
<td align="left">在每次循环体迭代后执行。</td>
</tr>
</tbody></table>
<p>一般循环算法的工作原理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开始运行</span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step)</span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step)</span><br><span class="line">→ (如果 condition 成立 → 运行 body 然后运行 step)</span><br><span class="line">→ ...</span><br></pre></td></tr></table></figure>

<p>所以，<code>begin</code> 执行一次，然后进行迭代：每次检查 <code>condition</code> 后，执行 <code>body</code> 和 <code>step</code>。</p>
<p>如果你这是第一次接触循环，那么回到这个例子，在一张纸上重现它逐步运行的过程，可能会对你有所帮助。</p>
<p>以下是在这个示例中发生的事：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for (let i = 0; i &lt; 3; i++) console.log(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始</span></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="comment">// 如果条件为真，运行下一步</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); i++ &#125;</span><br><span class="line"><span class="comment">// 如果条件为真，运行下一步</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); i++ &#125;</span><br><span class="line"><span class="comment">// 如果条件为真，运行下一步</span></span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">3</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(i); i++ &#125;</span><br><span class="line"><span class="comment">// ……结束，因为现在 i == 3</span></span><br></pre></td></tr></table></figure>

<p><strong>内联变量声明</strong></p>
<p>这里“计数”变量 <code>i</code> 是在循环中声明的。这叫做“内联”变量声明。这样的变量只在循环中可见。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 错误，没有这个变量。</span></span><br></pre></td></tr></table></figure>

<p>除了定义一个变量，我们也可以使用现有的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 使用现有的变量</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">//3，可见，因为是在循环之外声明的</span></span><br></pre></td></tr></table></figure>

<h3 id="省略语句段"><a href="#省略语句段" class="headerlink" title="省略语句段"></a>省略语句段</h3><p><code>for</code> 循环的任何语句段都可以被省略。</p>
<p>例如，如果我们在循环开始时不需要做任何事，我们就可以省略 <code>begin</code> 语句段。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>; <span class="comment">// 我们已经声明了 i 并对它进行了赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 不再需要 &quot;begin&quot; 语句段</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( i ); <span class="comment">// 0, 1, 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以移除 <code>step</code> 语句段：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; i &lt; <span class="number">3</span>;) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( i++ );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该循环与 <code>while (i &lt; 3)</code> 等价。</p>
<p>实际上我们可以删除所有内容，从而创建一个无限循环：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">  <span class="comment">// 无限循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意 <code>for</code> 的两个 <code>;</code> 必须存在，否则会出现语法错误。<br>可以结合无限循环来等待 setTimeout 的异步执行，等到异步执行完成后，返回一个条件，让无限循环结束（即跳出循环）。</p>
<h2 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h2><p>通常条件为假时，循环会终止。</p>
<p>但我们随时都可以使用 <code>break</code> 指令强制退出。</p>
<p>例如，下面这个循环要求用户输入一系列数字，在输入的内容不是数字时“终止”循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = +<span class="title function_">prompt</span>(<span class="string">&quot;请输入数字&quot;</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">break</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">  sum += value;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Sum: &#x27;</span> + sum );</span><br></pre></td></tr></table></figure>

<p>如果用户输入空行或取消输入，在 <code>(*)</code> 行的 <code>break</code> 指令会被激活。它立刻终止循环，将控制权传递给循环后的第一行，即，<code>console.log</code>。</p>
<p>根据需要，”无限循环 + <code>break</code>“ 的组合非常适用于不必在循环开始&#x2F;结束时检查条件，但需要在中间甚至是主体的多个位置进行条件检查的情况。</p>
<h2 id="继续下一次迭代"><a href="#继续下一次迭代" class="headerlink" title="继续下一次迭代"></a>继续下一次迭代</h2><p><code>continue</code> 指令是 <code>break</code> 的“轻量版”。它不会停掉整个循环。而是停止当前这一次迭代，并强制启动新一轮循环（如果条件允许的话）。</p>
<p>如果我们完成了当前的迭代，并且希望继续执行下一次迭代，我们就可以使用它。</p>
<p>下面这个循环使用 <code>continue</code> 来只输出奇数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果为真，跳过循环体的剩余部分。</span></span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 1，然后 3，5，7，9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于偶数的 <code>i</code> 值，<code>continue</code> 指令会停止本次循环的继续执行，将控制权传递给下一次 <code>for</code> 循环的迭代（使用下一个数字）。因此 <code>console.log</code> 仅被奇数值调用。</p>
<p><strong><code>continue</code> 指令利于减少嵌套</strong></p>
<p>显示奇数的循环可以像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( i );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从技术角度看，它与上一个示例完全相同。当然，我们可以将代码包装在 <code>if</code> 块而不使用 <code>continue</code>。</p>
<p>但在副作用方面，它多创建了一层嵌套（大括号内的 <code>console.log</code> 调用）。如果 <code>if</code> 中代码有多行，则可能会降低代码整体的可读性。</p>
<p><strong>禁止 <code>break/continue</code> 在 ‘?’ 的右边</strong></p>
<p>请注意非表达式的语法结构不能与三元运算符 <code>?</code> 一起使用。特别是 <code>break/continue</code> 这样的指令是不允许这样使用的。</p>
<p>例如，我们使用如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……用问号重写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(i &gt; <span class="number">5</span>) ? <span class="variable language_">console</span>.<span class="title function_">log</span>(i) : <span class="keyword">continue</span>; <span class="comment">// continue 不允许在这个位置</span></span><br></pre></td></tr></table></figure>

<p>……代码会停止运行，并显示有语法错误。</p>
<p>这是不（建议）使用问号 <code>?</code> 运算符替代 <code>if</code> 语句的另一个原因。</p>
<h2 id="break-continue-标签"><a href="#break-continue-标签" class="headerlink" title="break&#x2F;continue 标签"></a>break&#x2F;continue 标签</h2><p>有时候我们需要一次从多层嵌套的循环中跳出来。</p>
<p>例如，下述代码中我们的循环使用了 <code>i</code> 和 <code>j</code>，从 <code>(0,0)</code> 到 <code>(3,3)</code> 提示坐标 <code>(i, j)</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> input = <span class="title function_">prompt</span>(<span class="string">`Value at coords (<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我想从这里退出并直接执行 console.log(&#x27;Done!&#x27;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>我们需要提供一种方法，以在用户取消输入时来停止这个过程。</p>
<p>在 <code>input</code> 之后的普通 <code>break</code> 只会打破内部循环。这还不够 —— 标签可以实现这一功能！</p>
<p><strong>标签</strong> 是在循环之前带有冒号的标识符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">labelName</span>: <span class="keyword">for</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>break &lt;labelName&gt;</code> 语句跳出循环至标签处：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">outer</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> input = <span class="title function_">prompt</span>(<span class="string">`Value at coords (<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>)`</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是空字符串或被取消，则中断并跳出这两个循环。</span></span><br><span class="line">    <span class="keyword">if</span> (!input) <span class="keyword">break</span> outer; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用得到的值做些事……</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Done!&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>break outer</code> 向上寻找名为 <code>outer</code> 的标签并跳出当前循环。</p>
<p>因此，控制权直接从 <code>(*)</code> 转至 <code>console.log(&#39;Done!&#39;)</code>。</p>
<p>我们还可以将标签移至单独一行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">outer</span>:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>continue</code> 指令也可以与标签一起使用。在这种情况下，执行跳转到标记循环的下一次迭代。</p>
<p><strong>标签并不允许“跳到”所有位置</strong></p>
<p>标签不允许我们跳到代码的任意位置。</p>
<p>例如，这样做是不可能的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span> label;  <span class="comment">// 跳转至下面的 label 处（无效）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">label</span>: <span class="keyword">for</span> (...)</span><br></pre></td></tr></table></figure>

<p><code>break</code> 指令必须在代码块内。从技术上讲，任何被标记的代码块都有效，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="attr">label</span>: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">break</span> label; <span class="comment">// 有效</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>……尽管 99.9% 的情况下 <code>break</code> 都被用在循环内，就像在上面那些例子中我们看到的那样。</p>
<p><code>continue</code> 只有在循环内部才可行。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><p>我们学习了三种循环：</p>
<ul>
<li><code>while</code> —— 每次迭代之前都要检查条件。</li>
<li><code>do..while</code> —— 每次迭代后都要检查条件。</li>
<li><code>for (;;)</code> —— 每次迭代之前都要检查条件，可以使用其他设置。</li>
</ul>
<p>通常使用 <code>while(true)</code> 来构造“无限”循环。这样的循环和其他循环一样，都可以通过 <code>break</code> 指令来终止。</p>
<p>如果我们不想在当前迭代中做任何事，并且想要转移至下一次迭代，那么可以使用 <code>continue</code> 指令。</p>
<p><code>break/continue</code> 支持循环前的标签。<br>标签是 <code>break/continue</code> 跳出嵌套循环以转到外部的唯一方法。</p>
<h2 id="https-zh-javascript-info-while-for"><a href="#https-zh-javascript-info-while-for" class="headerlink" title="https://zh.javascript.info/while-for"></a><a href="https://zh.javascript.info/while-for">https://zh.javascript.info/while-for</a></h2><hr>
<h1 id="“switch”-语句"><a href="#“switch”-语句" class="headerlink" title="“switch” 语句"></a>“switch” 语句</h1><p><code>switch</code> 语句可以替代多个 <code>if</code> 判断。</p>
<p><code>switch</code> 语句为多分支选择的情况提供了一个更具描述性的方式。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>switch</code> 语句有至少一个 <code>case</code> 代码块和一个可选的 <code>default</code> 代码块。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;value1&#x27;</span>:  <span class="comment">// if (x === &#x27;value1&#x27;)</span></span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">break</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;value2&#x27;</span>:  <span class="comment">// if (x === &#x27;value2&#x27;)</span></span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">break</span>]</span><br><span class="line"></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">break</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>比较 <code>x</code> 值与第一个 <code>case</code>（也就是 <code>value1</code>）是否严格相等，然后比较第二个 <code>case</code>（<code>value2</code>）以此类推。</li>
<li>如果相等，<code>switch</code> 语句就执行相应 <code>case</code> 下的代码块，直到遇到最靠近的 <code>break</code> 语句（或者直到 <code>switch</code> 语句末尾）。</li>
<li>如果没有符合的 case，则执行 <code>default</code> 代码块（如果 <code>default</code> 存在）。</li>
</ul>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p><code>switch</code> 的例子（高亮的部分是执行的 <code>case</code> 部分）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太小啦！&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;没错!正是我&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太大了&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;额，什么鬼东西&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>switch</code> 从第一个 <code>case</code> 分支开始将 <code>a</code> 的值与 <code>case</code> 后的值进行比较，第一个 <code>case</code> 后的值为 <code>3</code> 匹配失败。</p>
<p>然后比较 <code>4</code>。匹配，所以从 <code>case 4</code> 开始执行直到遇到最近的 <code>break</code>。</p>
<p><strong>如果没有 <code>break</code>，程序将不经过任何检查就会继续执行下一个 <code>case</code>。</strong></p>
<p>无 <code>break</code> 的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太小啦！&#x27;</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;没错!正是我&#x27;</span> );</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太大了&#x27;</span> );</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;额，什么鬼东西&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中我们会看到连续执行的三个 <code>console.log</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太小啦&#x27;</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;太大了&#x27;</span> );</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;额，什么鬼东西&quot;</span> );</span><br></pre></td></tr></table></figure>

<p><strong>任何表达式都可以成为 <code>switch/case</code> 的参数</strong></p>
<p><code>switch</code> 和 <code>case</code> 都允许任意表达式。</p>
<p>比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;1&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (+a) &#123;</span><br><span class="line">  <span class="keyword">case</span> b + <span class="number">1</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里会被运行, 因为 +a 是 1, 刚好等于 b+1&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里将不会被运行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>+a</code> 返回 <code>1</code>，这个值跟 <code>case</code> 中 <code>b + 1</code> 相比较，然后执行对应的代码。</p>
<h2 id="“case”-分组"><a href="#“case”-分组" class="headerlink" title="“case” 分组"></a>“case” 分组</h2><p>共享同一段代码的几个 <code>case</code> 分支可以被分为一组：</p>
<p>比如，如果我们想让 <code>case 3</code> 和 <code>case 5</code> 执行同样的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (a) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我是4！你看清楚a是几？&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// (*) 下面这两个 case 被分在一组</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;错误!&#x27;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Why don&#x27;t you take a math class?&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The result is strange. Really.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在 <code>3</code> 和 <code>5</code> 都显示相同的信息。</p>
<p><code>switch/case</code> 有通过 case 进行“分组”的能力，其实是 switch 语句没有 <code>break</code> 时的副作用。因为没有 <code>break</code>，<code>case 3</code> 会从 <code>(*)</code> 行执行到 <code>case 5</code>。</p>
<h2 id="类型很关键"><a href="#类型很关键" class="headerlink" title="类型很关键"></a><a href="https://zh.javascript.info/switch#lei-xing-hen-guan-jian">类型很关键</a></h2><p>强调一下，这里的相等是严格相等。被比较的值必须是相同的类型才能进行匹配。</p>
<p>比如，我们来看下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arg = <span class="title function_">prompt</span>(<span class="string">&quot;Enter a value?&quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> (arg) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;One or zero&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Two&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Never executes!&#x27;</span> );</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;An unknown value&#x27;</span> )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>prompt</code> 对话框输入 <code>0</code>、<code>1</code>，第一个 <code>console.log</code> 弹出。</li>
<li>输入 <code>2</code>，第二个 <code>console.log</code> 弹出。</li>
<li>但是输入 <code>3</code>，因为 <code>prompt</code> 的结果是字符串类型的 <code>&quot;3&quot;</code>，不严格相等 <code>===</code> 于数字类型的 <code>3</code>，所以 <code>case 3</code> 不会执行！因此 <code>case 3</code> 部分是一段无效代码。所以会执行 <code>default</code> 分支。</li>
</ol>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>我们经常需要在脚本的许多地方执行很相似的操作。</p>
<p>例如，当访问者登录、注销或者在其他地方时，我们需要显示一条好看的信息。</p>
<p>函数是程序的主要“构建模块”。函数使该段代码可以被调用很多次，而不需要写重复的代码。</p>
<p>我们已经看到了内建函数的示例，如 <code>alert(message)</code>、<code>prompt(message, default)</code> 和 <code>confirm(question)</code>。但我们也可以创建自己的函数。</p>
<h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><p>使用 <strong>函数声明</strong> 创建函数。</p>
<p>看起来就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello everyone!&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>function</code> 关键字首先出现，然后是 函数名，然后是括号之间的 参数 列表（用逗号分隔，在上述示例中为空，我们将在接下来的示例中看到），最后是花括号之间的代码（即“函数体”）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">parameter1, parameter2, ... parameterN</span>) &#123;</span><br><span class="line">  ...body...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们的新函数可以通过名称调用：<code>showMessage()</code>。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Hello everyone!&#x27;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>();</span><br><span class="line"><span class="title function_">showMessage</span>();</span><br></pre></td></tr></table></figure>
<p>调用 <code>showMessage()</code> 执行函数的代码。这里我们会看到显示两次消息。</p>
<p>这个例子清楚地演示了函数的主要目的之一：<strong>避免代码重复</strong>。</p>
<p>如果我们需要更改消息或其显示方式，只需在一个地方修改代码：输出它的函数。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在函数中声明的变量只在该函数内部可见。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&quot;Hello, I&#x27;m JavaScript!&quot;</span>; <span class="comment">// 局部变量</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( message );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(); <span class="comment">// Hello, I&#x27;m JavaScript!</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( message ); <span class="comment">// &lt;-- 错误！变量是函数的局部变量</span></span><br></pre></td></tr></table></figure>
<h2 id="外部变量"><a href="#外部变量" class="headerlink" title="外部变量"></a>外部变量</h2><p>函数也可以访问外部变量，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&#x27;Hello, &#x27;</span> + userName;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(); <span class="comment">// Hello, John</span></span><br></pre></td></tr></table></figure>
<p>函数对外部变量拥有全部的访问权限。函数也可以修改外部变量。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  userName = <span class="string">&quot;Bob&quot;</span>; <span class="comment">// (1) 改变外部变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&#x27;Hello, &#x27;</span> + userName;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( userName ); <span class="comment">// John 在函数调用之前</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( userName ); <span class="comment">// Bob，值被函数修改了</span></span><br></pre></td></tr></table></figure>
<p>只有在没有局部变量的情况下才会使用外部变量。</p>
<p>如果在函数内部声明了同名变量，那么函数会 遮蔽 外部变量。例如，在下面的代码中，函数使用局部的 userName，而外部变量被忽略：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userName = <span class="string">&#x27;John&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> userName = <span class="string">&quot;Bob&quot;</span>; <span class="comment">// 声明一个局部变量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">&#x27;Hello, &#x27;</span> + userName; <span class="comment">// Bob</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数会创建并使用它自己的 userName</span></span><br><span class="line"><span class="title function_">showMessage</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( userName ); <span class="comment">// John，未被更改，函数没有访问外部变量。</span></span><br></pre></td></tr></table></figure>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>任何函数之外声明的变量，例如上述代码中的外部变量 <code>userName</code>，都被称为 <strong>全局</strong> 变量。</p>
<p>全局变量在任意函数中都是可见的（除非被局部变量遮蔽）。</p>
<p><em>减少全局变量</em> 的使用是一种很好的做法。现代的代码有很少甚至没有全局变量。大多数变量存在于它们的函数中。但是有时候，全局变量能够用于存储项目级别的数据。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>我们可以通过参数将任意数据传递给函数。</p>
<p>在如下示例中，函数有两个参数：from 和 text。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text</span>) &#123; <span class="comment">// 参数：from 和 text</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">from</span> + <span class="string">&#x27;: &#x27;</span> + text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&#x27;阿祖&#x27;</span>, <span class="string">&#x27;你好!&#x27;</span>); <span class="comment">// 阿祖: 你好! (*)</span></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&#x27;阿祖&#x27;</span>, <span class="string">&quot;吃饭了没?&quot;</span>); <span class="comment">// 阿祖: 吃饭了没? (**)</span></span><br></pre></td></tr></table></figure>
<p>当函数在 (*) 和 (**) 行中被调用时，给定值被复制到了局部变量 <code>from</code> 和 <code>text</code>。然后函数使用它们进行计算。</p>
<p>这里还有一个例子：我们有一个变量 <code>from</code>，并将它传递给函数。请注意：函数会修改 <code>from</code>，但在函数外部看不到更改，因为函数修改的是复制的变量值副本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">from</span> = <span class="string">&#x27;*&#x27;</span> + <span class="keyword">from</span> + <span class="string">&#x27;*&#x27;</span>; <span class="comment">// 让 &quot;from&quot; 看起来更优雅</span></span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">from</span> + <span class="string">&#x27;: &#x27;</span> + text );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">from</span> = <span class="string">&quot;阿祖&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="keyword">from</span>, <span class="string">&quot;你好&quot;</span>); <span class="comment">// *阿祖*: 你好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &quot;from&quot; 值相同，函数修改了一个局部的副本。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">from</span> ); <span class="comment">// 阿祖</span></span><br></pre></td></tr></table></figure>
<p>当一个值被作为函数参数 <code>（parameter）</code> 传递时，它也被称为 参数 <code>（argument）</code>。</p>
<p>换一种方式，我们把这些术语搞清楚：</p>
<p>函数参数（parameter）是函数声明中括号内列出的变量（它是函数声明时的术语）。<br>参数（argument）是调用函数时传递给函数的值（它是函数调用时的术语）。<br>我们声明函数时列出它们的函数参数 <code>（parameters）</code>，然后调用它们传递参数 <code>（arguments）</code>。</p>
<p>在上面的例子中，我们可以说：“函数 <code>showMessage</code> 被声明，并且带有两个参数 <code>（parameters）</code>，随后它被调用，两个参数 <code>（arguments）</code> 分别为 <code>from</code> 和 “Hello””。</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>如果一个函数被调用，但有参数 <code>（argument）</code> 未被提供，那么相应的值就会变成 <code>undefined</code>。</p>
<p>例如，之前提到的函数 <code>showMessage(from, text)</code> 可以只使用一个参数 <code>（argument）</code> 调用：</p>
<p><code>showMessage(&quot;Ann&quot;);</code><br>那不是错误，这样调用将输出 “<em>Ann</em>: undefined”。因为参数 <code>text</code> 的值未被传递，所以变成了 <code>undefined</code>。</p>
<p>我们可以使用 <code>=</code> 为函数声明中的参数指定所谓的“默认”（如果对应参数的值未被传递则使用）值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text = <span class="string">&quot;这里是默认的第二项值&quot;</span></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">from</span> + <span class="string">&quot;: &quot;</span> + text );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(<span class="string">&quot;阿祖&quot;</span>); <span class="comment">// 阿祖: 这里是默认的第二项值</span></span><br></pre></td></tr></table></figure>
<p>现在因为 <code> text</code> 参数未被传递，它将会得到默认值 “这里是默认的第二项值”。</p>
<p>这里 “这里是默认的第二项值” 是一个字符串，但它可以是更复杂的表达式，并且只会在缺少参数时才会被计算和分配。所以，这也是可能的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text = anotherFunction()</span>) &#123;</span><br><span class="line">  <span class="comment">// anotherFunction() 仅在没有给定 text 时执行</span></span><br><span class="line">  <span class="comment">// 其运行结果将成为 text 的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认参数的计算"><a href="#默认参数的计算" class="headerlink" title="默认参数的计算"></a>默认参数的计算</h2><p>在 <code>JavaScript</code> 中，每次函数在没带个别参数的情况下被调用，默认参数会被计算出来。</p>
<p>在上面的例子中，如果传递了参数 <code>text</code>，那么 <code>anotherFunction()</code> 就不会被调用。</p>
<p>如果没传递参数 <code>text</code>，那么 <code>anotherFunction()</code> 就会被调用。</p>
<p>在 <code>JavaScript</code> 老代码中的默认参数<br>几年前，<code>JavaScript</code> 不支持默认参数的语法。所以人们使用其他方式来设置默认参数。</p>
<p>如今，我们会在旧代码中看到它们。</p>
<p>例如，显式地检查 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (text === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    text = <span class="string">&#x27;未给第二项默认值&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">from</span> + <span class="string">&quot;: &quot;</span> + text );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>……或者使用 || 运算符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params"><span class="keyword">from</span>, text</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 text 的值为假值，则分配默认值</span></span><br><span class="line">  <span class="comment">// 这样赋值 text == &quot;&quot; 与 text 无值相同</span></span><br><span class="line">  text = text || <span class="string">&#x27;未给第二项默认值&#x27;</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后备的默认参数<br>有些时候，将参数默认值的设置放在函数执行（相较更后期）而不是函数声明时，也行得通。</p>
<p>我们可以通过将参数与 <code>undefined</code> 进行比较，来检查该参数是否在函数执行期间被传递进来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (text === <span class="literal">undefined</span>) &#123; <span class="comment">// 如果参数未被传递进来</span></span><br><span class="line">    text = <span class="string">&#x27;是个空值&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(text);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showMessage</span>(); <span class="comment">// 是个空值</span></span><br></pre></td></tr></table></figure>
<p>……或者我们可以使用 || 运算符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMessage</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 text 为 undefined 或者为假值，那么将其赋值为 &#x27;empty&#x27;</span></span><br><span class="line">  text = text || <span class="string">&#x27;empty&#x27;</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现代 <code>JavaScript</code> 引擎支持 空值合并运算符 <code>??</code>，它在大多数假值（例如 0）应该被视为“正常值”时更具优势：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showCount</span>(<span class="params">count</span>) &#123;</span><br><span class="line">  <span class="comment">// 如果 count 为 undefined 或 null，则提示 &quot;unknown&quot;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(count ?? <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">showCount</span>(<span class="number">0</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title function_">showCount</span>(<span class="literal">null</span>); <span class="comment">// unknown</span></span><br><span class="line"><span class="title function_">showCount</span>(); <span class="comment">// unknown</span></span><br></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>函数可以将一个值返回到调用代码中作为结果。</p>
<p>最简单的例子是将两个值相加的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( result ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>指令 <code>return</code> 可以在函数的任意位置。当执行到达时，函数停止，并将值返回给调用代码（分配给上述代码中的 <code>result</code>）。</p>
<p>在一个函数中可能会出现很多次 <code>return</code>。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">checkAge</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">confirm</span>(<span class="string">&#x27;Got a permission from the parents?&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&#x27;How old are you?&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( <span class="title function_">checkAge</span>(age) ) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Access granted&#x27;</span> );</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&#x27;Access denied&#x27;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只使用 <code>return</code> 但没有返回值也是可行的。但这会导致函数立即退出。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showMovie</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="title function_">checkAge</span>(age) ) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Showing you the movie&quot;</span> ); <span class="comment">// (*)</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述代码中，如果 <code>checkAge(age)</code> 返回 <code> false</code>，那么 <code>showMovie</code> 将不会运行到 <code>console.log</code>。</p>
<p>空值的 <code>return</code> 或没有 <code>return</code> 的函数返回值为 <code>undefined</code><br>如果函数无返回值，它就会像返回 <code>undefined</code> 一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doNothing</span>(<span class="params"></span>) &#123; <span class="comment">/* 没有代码 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">doNothing</span>() === <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>空值的 <code>return</code> 和 <code>return undefined</code> 等效：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">doNothing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">doNothing</span>() === <span class="literal">undefined</span> ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>不要在 <code>return</code> 与返回值之间添加新行<br>对于 <code>return</code> 的长表达式，可能你会很想将其放在单独一行，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line"> (some + long + expression + or + whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b))</span><br></pre></td></tr></table></figure>
<p>但这不行，因为 <code>JavaScript</code> 默认会在 <code> return</code> 之后加上分号。上面这段代码和下面这段代码运行流程相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"> (some + long + expression + or + whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b))</span><br></pre></td></tr></table></figure>
<p>因此，实际上它的返回值变成了空值。</p>
<p>如果我们想要将返回的表达式写成跨多行的形式，那么应该在 <code> return</code> 的同一行开始写此表达式。或者至少按照如下的方式放上左括号：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line">  some + long + expression</span><br><span class="line">  + or +</span><br><span class="line">    whatever * <span class="title function_">f</span>(a) + <span class="title function_">f</span>(b)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>然后它就能像我们预想的那样正常运行了。</p>
<h2 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h2><p>函数就是行为 <code>（action）</code>。所以它们的名字通常是动词。它应该简短且尽可能准确地描述函数的作用。这样读代码的人就能清楚地知道这个函数的功能。</p>
<p>一种普遍的做法是用动词前缀来开始一个函数，这个前缀模糊地描述了这个行为。团队内部必须就前缀的含义达成一致。</p>
<p>例如，以 <code>&quot;show&quot;</code> 开头的函数通常会显示某些内容。</p>
<p>函数以 XX 开始……</p>
<p><code>&quot;get…&quot;</code> —— 返回一个值，<br><code>&quot;calc…&quot;</code> —— 计算某些内容，<br><code>&quot;create…&quot;</code> —— 创建某些内容，<br><code>&quot;check…&quot;</code> —— 检查某些内容并返回 <code>boolean</code> 值，等。<br>这类名字的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showMessage</span>(..)     <span class="comment">// 显示信息</span></span><br><span class="line"><span class="title function_">getAge</span>(..)          <span class="comment">// 返回 age（gets it somehow）</span></span><br><span class="line"><span class="title function_">calcSum</span>(..)         <span class="comment">// 计算求和并返回结果</span></span><br><span class="line"><span class="title function_">createForm</span>(..)      <span class="comment">// 创建表单（通常会返回它）</span></span><br><span class="line"><span class="title function_">checkPermission</span>(..) <span class="comment">// 检查权限并返回 true/false</span></span><br></pre></td></tr></table></figure>
<p>有了前缀，只需瞥一眼函数名，就可以了解它的功能是什么，返回什么样的值。</p>
<p>一个函数 —— 一个行为<br>一个函数应该只包含函数名所指定的功能，而不是做更多与函数名无关的功能。</p>
<p>两个独立的行为通常需要两个函数，即使它们通常被一起调用（在这种情况下，我们可以创建第三个函数来调用这两个函数）。</p>
<p>有几个违反这一规则的例子：</p>
<p><code>getAge</code> —— 如果它通过 <code>console.log</code> 将 <code>age</code> 显示出来，那就有问题了（只应该是获取）。<br><code>createForm</code> —— 如果它包含修改文档的操作，例如向文档添加一个表单，那就有问题了（只应该创建表单并返回）。<br><code>checkPermission</code> —— 如果它显示 <code>access granted/denied</code> 消息，那就有问题了（只应执行检查并返回结果）。<br>这些例子假设函数名前缀具有通用的含义。你和你的团队可以自定义这些函数名前缀的含义，但是通常都没有太大的不同。无论怎样，你都应该对函数名前缀的含义、带特定前缀的函数可以做什么以及不可以做什么有深刻的了解。所有相同前缀的函数都应该遵守相同的规则。并且，团队成员应该形成共识。</p>
<p>非常短的函数命名<br>常用的函数有时会有非常短的名字。</p>
<p>例如，<code>jQuery</code> 框架用 <code>$</code> 定义一个函数。<code>LoDash</code> 库的核心函数用 <code>_</code> 命名。</p>
<p>这些都是例外，一般而言，函数名应简明扼要且具有描述性。</p>
<h2 id="函数-注释"><a href="#函数-注释" class="headerlink" title="函数 &#x3D;&#x3D; 注释"></a>函数 &#x3D;&#x3D; 注释</h2><p>函数应该简短且只有一个功能。如果这个函数功能复杂，那么把该函数拆分成几个小的函数是值得的。有时候遵循这个规则并不是那么容易，但这绝对是件好事。</p>
<p>一个单独的函数不仅更容易测试和调试 —— 它的存在本身就是一个很好的注释！</p>
<p>例如，比较如下两个函数 <code>showPrimes(n)</code>。它们的功能都是输出到 <code>n</code> 的 素数。</p>
<p>第一个变体使用了一个标签：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showPrimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="attr">nextPrime</span>: <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i % j == <span class="number">0</span>) <span class="keyword">continue</span> nextPrime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( i ); <span class="comment">// 一个素数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个变体使用附加函数 <code>isPrime(n)</code> 来检验素数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">showPrimes</span>(<span class="params">n</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title function_">isPrime</span>(i)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);  <span class="comment">// 一个素数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isPrime</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个变体更容易理解，不是吗？我们通过函数名 <code>（isPrime）</code> 就可以看出函数的行为，而不需要通过代码。人们通常把这样的代码称为 <strong>自描述</strong>。</p>
<p>因此，即使我们不打算重用它们，也可以创建函数。函数可以让代码结构更清晰，可读性更强。</p>
<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>函数声明方式如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">name</span>(<span class="params">parameters, delimited, by, comma</span>) &#123;</span><br><span class="line">  <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>作为参数传递给函数的值，会被复制到函数的局部变量。</p>
</li>
<li><p>函数可以访问外部变量。但它只能从内到外起作用。函数外部的代码看不到函数内的局部变量。</p>
</li>
<li><p>函数可以返回值。如果没有返回值，则其返回的结果是 undefined。</p>
</li>
<li><p>为了使代码简洁易懂，建议在函数中主要使用局部变量和参数，而不是外部变量。</p>
</li>
<li><p>与不获取参数但将修改外部变量作为副作用的函数相比，获取参数、使用参数并返回结果的函数更容易理解。</p>
</li>
<li><p>函数命名：</p>
</li>
<li><p>函数名应该清楚地描述函数的功能。当我们在代码中看到一个函数调用时，一个好的函数名能够让我们马上知道这个函数的功能是什么，会返回什么。</p>
</li>
<li><p>一个函数是一个行为，所以函数名通常是动词。</p>
</li>
<li><p>目前有许多优秀的函数名前缀，如 create…、show…、get…、check… 等等。使用它们来提示函数的作用吧。</p>
</li>
</ul>
<p>函数是脚本的主要构建块。现在我们已经介绍了基本知识，现在我们就可以开始创建和使用函数了。但这只是学习和使用函数的开始。我们将继续学习更多函数的相关知识，更深入地研究它们的先进特征。</p>
<hr>
<h1 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h1><p>在 <code>JavaScript</code> 中，函数不是“神奇的语言结构”，而是一种特殊的值。</p>
<p>我们在前面章节使用的语法称为 函数声明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种创建函数的语法称为 <strong>函数表达式</strong>。</p>
<p>它允许我们在任何表达式的中间创建一个新函数。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这里我们可以看到变量 <code>sayHi</code> 得到了一个值，新函数 <code>function() &#123; console.log(&quot;Hello&quot;)</code>; }。</p>
<p>由于函数创建发生在赋值表达式的上下文中（在 &#x3D; 的右侧），因此这是一个 <strong>函数表达式</strong>。</p>
<p>请注意，在上述代码中 <code>function</code> 关键字后面没有函数名。函数表达式允许省略函数名。</p>
<p>这里我们立即将它赋值给变量，所以上面的两个代码示例的含义是一样的：<br>“创建一个函数并将其放入变量 <code>sayHi</code> 中”。</p>
<p>在更多更高阶的情况下，稍后我们会遇到，可以创建一个函数并立即调用，或者安排稍后执行，而不是存储在任何地方，因此保持匿名。</p>
<p><strong>函数是一个值</strong><br>重申一次：无论函数是如何创建的，函数都是一个值。上面的两个示例都在 <code>sayHi</code> 变量中存储了一个函数。</p>
<p>我们还可以用 <code>console.log</code> 显示这个变量的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( sayHi ); <span class="comment">// 显示函数代码</span></span><br></pre></td></tr></table></figure>
<p>注意，最后一行代码并不会运行函数，因为 <code>sayHi</code> 后没有括号。在某些编程语言中，只要提到函数的名称都会导致函数的调用执行，但 <code>JavaScript</code> 可不是这样。</p>
<p>在 <code>JavaScript</code> 中，函数是一个值，所以我们可以把它当成值对待。上面代码显示了一段字符串值，即函数的源码。</p>
<p>的确，在某种意义上说一个函数是一个特殊值，我们可以像 <code>sayHi()</code> 这样调用它。</p>
<p>但它依然是一个值，所以我们可以像使用其他类型的值一样使用它。</p>
<p>我们可以复制函数到其他变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;   <span class="comment">// (1) 创建</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;    <span class="comment">// (2) 复制</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>(); <span class="comment">// Hello     // (3) 运行复制的值（正常运行）！</span></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// Hello    //     这里也能运行</span></span><br></pre></td></tr></table></figure>
<p>解释一下上段代码发生的细节：</p>
<p>(1) 行声明创建了函数，并把它放入到变量 <code>sayHi</code>。<br>(2) 行将 <code>sayHi</code> 复制到了变量 <code>func</code>。请注意：<code>sayHi</code> 后面没有括号。如果有括号，<code>func = sayHi()</code> 会把 <code>sayHi()</code> 的调用结果写进 <code>func</code>  ，而不是 <code>sayHi 函数</code> 本身。<br>现在函数可以通过 <code>sayHi()</code> 和 <code>func()</code> 两种方式进行调用。<br>我们也可以在第一行中使用函数表达式来声明 <code>sayHi</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="comment">// (1) 创建</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;Hello&quot;</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = sayHi;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>这两种声明的函数是一样的。</p>
<p>为什么这里末尾会有个分号？<br>你可能想知道，为什么函数表达式结尾有一个分号 <code>;</code>，而函数声明没有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>答案很简单：这里函数表达式是在赋值语句 <code>let sayHi = ...;</code> 中以 <code>function(…) &#123;…&#125;</code> 的形式创建的。建议在语句末尾加上分号 <code>;</code> ，它不是函数语法的一部分。</p>
<p>分号用于更简单的赋值，例如 <code>let sayHi = 5;</code>，它也用于函数赋值。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>让我们多举几个例子，看看如何将函数作为值来传递以及如何使用函数表达式。</p>
<p>我们写一个包含三个参数的函数 <code>ask(question, yes, no)</code>：</p>
<p><code>question</code>  关于问题的文本<br><code>yes</code> 当回答为 “Yes” 时，要运行的脚本<br><code>no</code> 当回答为 “No” 时，要运行的脚本<br>函数需要提出 <code>question（问题）</code>，并根据用户的回答，调用 <code>yes()</code> 或 <code>no()</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ask</span>(<span class="params">question, yes, no</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">confirm</span>(question)) <span class="title function_">yes</span>()</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">no</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showOk</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;You agreed.&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">showCancel</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;You canceled the execution.&quot;</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：函数 showOk 和 showCancel 被作为参数传入到 ask</span></span><br><span class="line"><span class="title function_">ask</span>(<span class="string">&quot;Do you agree?&quot;</span>, showOk, showCancel);</span><br></pre></td></tr></table></figure>
<p>在实际开发中，这样的函数是非常有用的。实际开发与上述示例最大的区别是，实际开发中的函数会通过更加复杂的方式与用户进行交互，而不是通过简单的 <code>confirm</code>。在浏览器中，这样的函数通常会绘制一个漂亮的提问窗口。但这是另外一件事了。</p>
<p><code>ask</code> 的两个参数值 <code>showOk</code> 和 <code>showCancel</code> 可以被称为 <strong>回调函数</strong> 或简称 <strong>回调</strong>。</p>
<p>主要思想是我们传递一个函数，并期望在稍后必要时将其“回调”。在我们的例子中，<code>showOk</code> 是回答 “yes” 的回调，<code>showCancel</code> 是回答 “no” 的回调。</p>
<p>我们可以使用函数表达式来编写一个等价的、更简洁的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">ask</span>(<span class="params">question, yes, no</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">confirm</span>(question)) <span class="title function_">yes</span>()</span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">no</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">ask</span>(</span><br><span class="line">  <span class="string">&quot;Do you agree?&quot;</span>,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You agreed.&quot;</span>); &#125;,</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;You canceled the execution.&quot;</span>); &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这里直接在 <code>ask(...)</code> 调用内进行函数声明。这两个函数没有名字，所以叫 <strong>匿名函数</strong>。这样的函数在 <code>ask</code> 外无法访问（因为没有对它们分配变量），不过这正是我们想要的。</p>
<p>这样的代码在我们的脚本中非常常见，这正符合 <code>JavaScript</code> 语言的思想。</p>
<p>一个函数是表示一个“行为”的值。字符串或数字等常规值代表 <code>数据</code>。</p>
<p>函数可以被视为一个 <code>行为（action）</code>。</p>
<p>我们可以在变量之间传递它们，并在需要时运行。</p>
<h2 id="函数表达式-vs-函数声明"><a href="#函数表达式-vs-函数声明" class="headerlink" title="函数表达式 vs 函数声明"></a>函数表达式 vs 函数声明</h2><p>让我们来总结一下函数声明和函数表达式之间的主要区别。</p>
<ul>
<li>首先是语法：如何通过代码对它们进行区分。</li>
</ul>
<p>函数声明：在主代码流中声明为单独的语句的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数表达式：在一个表达式中或另一个语法结构中创建的函数。下面这个函数是在赋值表达式 &#x3D; 右侧创建的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>更细微的差别是，<code>JavaScript</code> 引擎会在 什么时候 创建函数。</li>
</ul>
<p>函数表达式是在代码执行到达时被创建，并且仅从那一刻起可用。</p>
<p>一旦代码执行到赋值表达式 let sum &#x3D; function… 的右侧，此时就会开始创建该函数，并且可以从现在开始使用（分配，调用等）。</p>
<p>函数声明则不同。</p>
<p>在函数声明被定义之前，它就可以被调用。</p>
<p>例如，一个全局函数声明对整个脚本来说都是可见的，无论它被写在这个脚本的哪个位置。</p>
<p>这是内部算法的缘故。当 <code>JavaScript</code> 准备 运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数。我们可以将其视为“初始化阶段”。</p>
<p>在处理完所有函数声明后，代码才被执行。所以运行时能够使用这些函数。</p>
<p>例如下面的代码会正常工作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// Hello, John</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数声明 <code>sayHi</code> 是在 <code>JavaScript</code> 准备运行脚本时被创建的，在这个脚本的任何位置都可见。</p>
<p>……如果它是一个函数表达式，它就不会工作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">sayHi</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sayHi = <span class="keyword">function</span>(<span class="params">name</span>) &#123;  <span class="comment">// (*) no magic any more</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span> );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>函数表达式在代码执行到它时才会被创建。只会发生在 (*) 行。为时已晚。</p>
<ul>
<li>函数声明的另外一个特殊的功能是它们的块级作用域。</li>
</ul>
<p>严格模式下，当一个函数声明在一个代码块内时，它在该代码块内的任何位置都是可见的。但在代码块外不可见。</p>
<p>例如，想象一下我们需要依赖于在代码运行过程中获得的变量 <code>age</code> 声明一个函数 <code>welcome()</code>。并且我们计划在之后的某个时间使用它。</p>
<p>如果我们使用函数声明，则以下代码无法像预期那样工作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有条件地声明一个函数</span></span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">welcome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">welcome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……稍后使用</span></span><br><span class="line"><span class="title function_">welcome</span>(); <span class="comment">// Error: welcome is not defined</span></span><br></pre></td></tr></table></figure>
<p>这是因为函数声明只在它所在的代码块中可见。</p>
<p>下面是另一个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="number">16</span>; <span class="comment">// 拿 16 作为例子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">  <span class="title function_">welcome</span>();               <span class="comment">// \   (运行)</span></span><br><span class="line">                           <span class="comment">//  |</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">welcome</span>(<span class="params"></span>) &#123;     <span class="comment">//  |</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);       <span class="comment">//  |  函数声明在声明它的代码块内任意位置都可用</span></span><br><span class="line">  &#125;                        <span class="comment">//  |</span></span><br><span class="line">                           <span class="comment">//  |</span></span><br><span class="line">  <span class="title function_">welcome</span>();               <span class="comment">// /   (运行)</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">welcome</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在这里，我们在花括号外部调用函数，我们看不到它们内部的函数声明。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>(); <span class="comment">// Error: welcome is not defined</span></span><br></pre></td></tr></table></figure>
<p>我们怎么才能让 <code>welcome</code> 在 <code>if</code> 外可见呢？</p>
<p>正确的做法是使用函数表达式，并将 <code>welcome</code> 赋值给在 if 外声明的变量，并具有正确的可见性。</p>
<p>下面的代码可以如愿运行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line"></span><br><span class="line">  welcome = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">  welcome = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>(); <span class="comment">// 现在可以了</span></span><br></pre></td></tr></table></figure>
<p>或者我们可以使用问号运算符 ? 来进一步对代码进行简化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome = (age &lt; <span class="number">18</span>) ?</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>); &#125; :</span><br><span class="line">  <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greetings!&quot;</span>); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>(); <span class="comment">// 现在可以了</span></span><br></pre></td></tr></table></figure>
<ul>
<li>什么时候选择函数声明与函数表达式？<br>根据经验，当我们需要声明一个函数时，优先考虑函数声明语法。它能够为组织代码提供更多的灵活性。因为我们可以在声明这些函数之前调用这些函数。</li>
</ul>
<p>这对代码可读性也更好，因为在代码中查找 <code>function f(…) &#123;…&#125;</code> 比 <code>let f = function(…) &#123;…&#125;</code> 更容易。函数声明更“醒目”。</p>
<p>……但是，如果由于某种原因而导致函数声明不适合我们（我们刚刚看过上面的例子），那么应该使用函数表达式。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>函数是值。它们可以在代码的任何地方被分配，复制或声明。</p>
</li>
<li><p>如果函数在主代码流中被声明为单独的语句，则称为“函数声明”。</p>
</li>
<li><p>如果该函数是作为表达式的一部分创建的，则称其“函数表达式”。</p>
</li>
<li><p>在执行代码块之前，内部算法会先处理函数声明。所以函数声明在其被声明的代码块内的任何位置都是可见的。</p>
</li>
<li><p>函数表达式在执行流程到达时创建。</p>
</li>
<li><p>在大多数情况下，当我们需要声明一个函数时，最好使用函数声明，因为函数在被声明之前也是可见的。这使我们在代码组织方面更具灵活性，通常也会使得代码可读性更高。</p>
</li>
<li><p>所以，仅当函数声明不适合对应的任务时，才应使用函数表达式。在本章中，我们已经看到了几个例子，以后还会看到更多的例子。</p>
</li>
</ul>
<hr>
<h1 id="箭头函数，基础知识"><a href="#箭头函数，基础知识" class="headerlink" title="箭头函数，基础知识"></a>箭头函数，基础知识</h1><p>创建函数还有另外一种非常简单的语法，并且这种方法通常比函数表达式更好。</p>
<p>它被称为 <strong>“箭头函数”</strong>，因为它看起来像这样：</p>
<p><code>let func = (arg1, arg2, ..., argN) =&gt; expression;</code><br>这里创建了一个函数 <code>func</code>，它接受参数 <code>arg1..argN</code>，然后使用参数对右侧的 <code>expression</code> 求值并返回其结果。</p>
<p>换句话说，它是下面这段代码的更短的版本：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argN</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> expression;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>让我们来看一个具体的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这个箭头函数是下面这个函数的更短的版本：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">let sum = function(a, b) &#123;</span></span><br><span class="line"><span class="comment">  return a + b;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>可以看到 <code>(a, b) =&gt; a + b</code> 表示一个函数接受两个名为 <code>a</code> 和 <code>b</code> 的参数。在执行时，它将对表达式 <code>a + b</code> 求值，并返回计算结果。</p>
<p>如果我们只有一个参数，还可以省略掉参数外的圆括号，使代码更短。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">double</span> = n =&gt; n * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 差不多等同于：let double = function(n) &#123; return n * 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">double</span>(<span class="number">3</span>) ); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>如果没有参数，括号则是空的（但括号必须保留）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sayHi</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>
<p>箭头函数可以像函数表达式一样使用。</p>
<p>例如，动态创建一个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age = <span class="title function_">prompt</span>(<span class="string">&quot;What is your age?&quot;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> welcome = (age &lt; <span class="number">18</span>) ?</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello!&#x27;</span>) :</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Greetings!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">welcome</span>();</span><br></pre></td></tr></table></figure>
<p>一开始，箭头函数可能看起来并不熟悉，也不容易读懂，但一旦我们看习惯了之后，这种情况很快就会改变。</p>
<p>箭头函数对于简单的单行行为 <code>（action）</code> 来说非常方便，尤其是当我们懒得打太多字的时候。</p>
<h2 id="多行的箭头函数"><a href="#多行的箭头函数" class="headerlink" title="多行的箭头函数"></a>多行的箭头函数</h2><p>到目前为止，我们看到的箭头函数非常简单。它们从 <code>=&gt;</code> 的左侧获取参数，计算并返回右侧表达式的计算结果。</p>
<p>有时我们需要更复杂一点的函数，比如带有多行的表达式或语句。在这种情况下，我们可以使用花括号将它们括起来。主要区别在于，用花括号括起来之后，需要包含 <code>return</code> 才能返回值（就像常规函数一样）。</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">sum</span> = (<span class="params">a, b</span>) =&gt; &#123;  <span class="comment">// 花括号表示开始一个多行函数</span></span><br><span class="line">  <span class="keyword">let</span> result = a + b;</span><br><span class="line">  <span class="keyword">return</span> result; <span class="comment">// 如果我们使用了花括号，那么我们需要一个显式的 “return”</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title function_">sum</span>(<span class="number">1</span>, <span class="number">2</span>) ); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h2><p>在这里，我们赞扬了箭头函数的简洁性。但还不止这些！</p>
<p>箭头函数还有其他有趣的特性。</p>
<p>为了更深入地学习它们，我们首先需要了解一些 <code>JavaScript</code> 其他方面的知识，因此我们将在后面的 深入理解箭头函数 一章中再继续研究箭头函数。</p>
<p>现在，我们已经可以用箭头函数进行单行行为和回调了。</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>箭头函数对于简单的操作很方便，特别是对于单行的函数。它具体有两种形式：</p>
<ul>
<li><p>不带花括号：<code>(...args) =&gt; expression</code> —— 右侧是一个表达式：函数计算表达式并返回其结果。如果只有一个参数，则可以省略括号，例如 <code>n =&gt; n*2</code>。</p>
</li>
<li><p>带花括号：<code>(...args) =&gt; &#123; body &#125;</code> —— 花括号允许我们在函数中编写多个语句，但是我们需要显式地 <code>return</code> 来返回一些内容。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mindmap</span><br><span class="line">	root(&quot;JavaScript学习笔记&quot;)</span><br><span class="line">		(&quot;JS 基础内容&quot;)</span><br><span class="line">		(&quot;关于 JavaScript 的一些基本常识&quot;)</span><br><span class="line">			(&quot;如何把代码运行的结果显示出来？&quot;)</span><br><span class="line">			(&quot;注释&quot;)</span><br><span class="line">			(&quot;现代模式/严格模式 &quot;)</span><br><span class="line">			(&quot;三种特殊值&quot;)</span><br><span class="line">		(&quot;变量&quot;)</span><br><span class="line">		(&quot;数据类型&quot;)</span><br><span class="line">			(&quot;文本串类型&quot;)</span><br><span class="line">				(&quot;引号 （quotes）&quot;)</span><br><span class="line">				(&quot;特殊字符  / 转义字符&quot;)</span><br><span class="line">				(&quot;字符串长度 length&quot;)</span><br><span class="line">				(&quot;访问字符&quot;)</span><br><span class="line">				(&quot;字母大小写转换&quot;)</span><br><span class="line">				(&quot;在字符串查找是否包含另一个字符串&quot;)</span><br><span class="line">			(&quot;数字类型&quot;)</span><br><span class="line">				(&quot;科学计数法&quot;)</span><br><span class="line">				(&quot;数字进制转换&quot;)</span><br><span class="line">				(&quot;舍入&quot;)</span><br><span class="line">				(&quot;检测变量是不是数字      &quot;)</span><br><span class="line">				(&quot;区别&quot;)</span><br><span class="line">				(&quot;注意事项&quot;)</span><br><span class="line">				(&quot;提取文本串中开头的数字&quot;)</span><br><span class="line">				(&quot;注意事项&quot;)</span><br><span class="line">				(&quot;数字函数&quot;)</span><br><span class="line">				(&quot;变量的数据类型转换&quot;)</span><br><span class="line">					(&quot;**转换成字符串**&quot;)</span><br><span class="line">					(&quot;**转换成数字**&quot;)</span><br><span class="line">					(&quot;**转换成布尔（boolean）类型**&quot;)</span><br><span class="line">					(&quot;总结&quot;)</span><br><span class="line">		(&quot;数学运算&quot;)</span><br><span class="line">			(&quot;术语：“一元运算符”，“二元运算符”，“运算元”&quot;)</span><br><span class="line">			(&quot;数学运算&quot;)</span><br><span class="line">				(&quot;取余 %&quot;)</span><br><span class="line">				(&quot;求幂 **&quot;)</span><br><span class="line">			(&quot;用二元运算符 +         连接字符串&quot;)</span><br><span class="line">			(&quot;数字转化，一元运算符 +&quot;)</span><br><span class="line">			(&quot;运算符优先级&quot;)</span><br><span class="line">			(&quot;赋值运算符&quot;)</span><br><span class="line">				(&quot;赋值 = 返回一个值&quot;)</span><br><span class="line">				(&quot;链式赋值（Chaining assignments）&quot;)</span><br><span class="line">			(&quot;原地修改&quot;)</span><br><span class="line">			(&quot;自增/自减&quot;)</span><br><span class="line">			(&quot;位运算符&quot;)</span><br><span class="line">			(&quot;逗号运算符&quot;)</span><br><span class="line">		(&quot;值的比较&quot;)</span><br><span class="line">			(&quot;比较的结果是 Boolean 类型&quot;)</span><br><span class="line">			(&quot;字符串比较&quot;)</span><br><span class="line">			(&quot;不同类型间的比较&quot;)</span><br><span class="line">			(&quot;严格相等&quot;)</span><br><span class="line">			(&quot;对 null 和 undefined 进行比较&quot;)</span><br><span class="line">				(&quot;奇怪的结果：null vs 0&quot;)</span><br><span class="line">				(&quot;特立独行的 undefined&quot;)</span><br><span class="line">				(&quot;避免问题&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br><span class="line">		(&quot;条件分支：if 和 &#x27;?&#x27;&quot;)</span><br><span class="line">			(&quot;“if” 语句&quot;)</span><br><span class="line">			(&quot;布尔转换&quot;)</span><br><span class="line">			(&quot;“else” 语句&quot;)</span><br><span class="line">			(&quot;多个条件：“else if”&quot;)</span><br><span class="line">			(&quot;条件运算符 ‘?’&quot;)</span><br><span class="line">			(&quot;多个 ‘?’&quot;)</span><br><span class="line">			(&quot;‘?’ 的非常规使用&quot;)</span><br><span class="line">		(&quot;逻辑运算符&quot;)</span><br><span class="line">			(&quot;||（或）&quot;)</span><br><span class="line">			(&quot;或运算寻找第一个真值&quot;)</span><br><span class="line">			(&quot;&amp;&amp;（与）&quot;)</span><br><span class="line">			(&quot;与运算寻找第一个假值&quot;)</span><br><span class="line">			(&quot;!（非）&quot;)</span><br><span class="line">		(&quot;空值合并运算符 &#x27; ?? &#x27;&quot;)</span><br><span class="line">			(&quot;与 || 比较&quot;)</span><br><span class="line">			(&quot;优先级&quot;)</span><br><span class="line">				(&quot;?? 与 &amp;&amp; 或 || 一起使用&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br><span class="line">		(&quot;循环：while 和 for&quot;)</span><br><span class="line">			(&quot;“while” 循环&quot;)</span><br><span class="line">			(&quot;“do…while” 循环&quot;)</span><br><span class="line">			(&quot;“for” 循环&quot;)</span><br><span class="line">				(&quot;省略语句段&quot;)</span><br><span class="line">			(&quot;跳出循环&quot;)</span><br><span class="line">			(&quot;继续下一次迭代&quot;)</span><br><span class="line">			(&quot;break/continue 标签&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br><span class="line">		(&quot;switch 语句&quot;)</span><br><span class="line">			(&quot;语法&quot;)</span><br><span class="line">			(&quot;举个例子&quot;)</span><br><span class="line">			(&quot;“case” 分组&quot;)</span><br><span class="line">			(&quot;[类型很关键](https://zh.javascript.info/switch#lei-xing-hen-guan-jian)&quot;)</span><br><span class="line">		(&quot;函数&quot;)</span><br><span class="line">			(&quot;函数声明&quot;)</span><br><span class="line">			(&quot;局部变量&quot;)</span><br><span class="line">			(&quot;外部变量&quot;)</span><br><span class="line">			(&quot;全局变量&quot;)</span><br><span class="line">			(&quot;参数&quot;)</span><br><span class="line">			(&quot;默认值&quot;)</span><br><span class="line">			(&quot;默认参数的计算&quot;)</span><br><span class="line">			(&quot;返回值&quot;)</span><br><span class="line">			(&quot;函数命名&quot;)</span><br><span class="line">			(&quot;函数 == 注释&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br><span class="line">		(&quot;函数表达式&quot;)</span><br><span class="line">			(&quot;回调函数&quot;)</span><br><span class="line">			(&quot;函数表达式 vs 函数声明&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br><span class="line">		(&quot;箭头函数，基础知识&quot;)</span><br><span class="line">			(&quot;多行的箭头函数&quot;)</span><br><span class="line">			(&quot;更多内容&quot;)</span><br><span class="line">			(&quot;总结&quot;)</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript学习笔记（2）对象object</title>
    <url>//blog/note/code/JavaScript2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p><code>JavaScript</code> 中有八种数据类型。有七种原始类型，因为它们的值只包含一种东西（字符串，数字或者其他）。</p>
<p><code>对象</code>则用来存储键值对和更复杂的实体。在 <code>JavaScript</code> 中，对象几乎渗透到了这门编程语言的方方面面。所以，在我们深入理解这门语言之前，必须先理解<code>对象</code>。</p>
<p>我们可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对<code>（“key: value”）</code>，其中键（<code>key</code>）是一个字符串（也叫做<span style="color:#CC0000;">属性名</span>），值（<code>value</code>）可以是任何值。</p>
<p>我们可以把<code>对象</code>想象成一个带有<code>抽屉</code>的<code>文件柜</code>。<br>每一条数据都基于键（<code>key</code>）存储在<code>抽屉</code>中。<br>这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加&#x2F;删除文件了。</p>
<p>我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  		<span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure>

<p>通常，我们用花括号，即常用第二种方法。这种方式我们叫做 <strong>字面量</strong>。</p>
<h2 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a>文本和属性</h2><p>我们可以在创建对象的时候，立即将一些属性以<code>键值对</code>的形式放到 <code>&#123;...&#125;</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;     <span class="comment">// 一个对象</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,  <span class="comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>        <span class="comment">// 键 &quot;age&quot;，值 30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p>
<p>在 <code>user</code> 对象中，有两个属性：</p>
<ol>
<li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li>
<li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li>
</ol>
<p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 “name” 和 “age” 的<code>抽屉</code>的柜子。</p>
<p>我们可以随时添加、删除和读取文件。</p>
<p>可以使用<code>点符号</code>访问属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件的属性：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">age</span> ); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>属性的值可以是任意类型，让我们加个布尔类型：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">user.<span class="property">isAdmin</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以用 <code>delete</code> 操作符移除属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> user.<span class="property">age</span>;</span><br></pre></td></tr></table></figure>

<p>我们也可以用<code>多字词语</code>来作为属性名，但必须给它们加上引号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">&quot;likes birds&quot;</span>: <span class="literal">true</span>  <span class="comment">// 多词属性名必须加引号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>列表中的最后一个属性应以逗号结尾：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p>
<h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>对于多词属性，点操作就不能用了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这将提示有语法错误</span></span><br><span class="line">user.<span class="property">likes</span> birds = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 理解不了。它认为我们在处理 <code>user.likes</code>，然后在遇到意外的 <code>birds</code> 时给出了语法错误。</p>
<p>点符号要求 <code>key</code> 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 <code>$</code> 和 <code>_</code>）。</p>
<p>有另一种方法，就是使用方括号，可用于<strong>任何字符串</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">user[<span class="string">&quot;likes birds&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[<span class="string">&quot;likes birds&quot;</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> user[<span class="string">&quot;likes birds&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。</p>
<p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式 —— 与文本字符串不同 —— 例如下面的变量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;likes birds&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span></span><br><span class="line">user[key] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key =  <span class="string">&quot;name&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user[key] ); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>点符号不能以类似的方式使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">key</span> ) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&quot;你想买什么水果?&quot;</span>, <span class="string">&quot;苹果&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的，默认输入的是苹果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bag.<span class="property">apple</span> ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>

<p>计算属性的含义很简单：<code>[fruit]</code> 含义是属性名应该从 <code>fruit</code> 变量中获取。</p>
<p>所以，如果一个用户输入 <code>&quot;apple&quot;</code>，<code>bag</code> 将变为 <code>&#123;apple: 5&#125;</code>。</p>
<p>本质上，这跟下面的语法效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> bag = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 fruit 变量中获取值</span></span><br><span class="line">bag[fruit] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


<p>我们可以在方括号中使用更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit + <span class="string">&#x27;Computers&#x27;</span>]: <span class="number">5</span> <span class="comment">// bag.appleComputers = 5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方括号比点符号更强大</strong>。它允许任何属性名和变量，但写起来也更加麻烦。</p>
<p>所以，大部分时间里，</p>
<ul>
<li>当属性名是已知且简单的时候，就使用点符号。</li>
<li>如果我们需要一些更复杂的内容，那么就用方括号。</li>
</ul>
<h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>在实际开发中，我们通常用已存在的变量当做属性名。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="comment">// ……其他的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="title function_">makeUser</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p>
<p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">    age,  <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把属性名简写方式和正常方式混用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name,  <span class="comment">// 与 name:name 相同</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a>属性名称限制</h2><p>我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……</p>
<p>但对象的属性名并不受此限制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些属性都没问题</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">for</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">let</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">return</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">for</span> + obj.<span class="property">let</span> + obj.<span class="property">return</span> );  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>简而言之，属性命名没有限制。属性名可以是任何字符串或者 <code>symbol</code>（一种特殊的标志符类型，将在后面介绍）。</p>
<p>其他类型会被自动地转换为字符串。</p>
<p>例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;test&quot;</span> <span class="comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj[<span class="string">&quot;0&quot;</span>] ); <span class="comment">// test</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj[<span class="number">0</span>] ); <span class="comment">// test (相同的属性)</span></span><br></pre></td></tr></table></figure>

<p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="number">5</span>; <span class="comment">// 分配一个数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// [object Object] —— 值为对象，与预期结果不同</span></span><br></pre></td></tr></table></figure>

<p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p>
<p>我们将在 <a href="https://zh.javascript.info/prototype-inheritance">后续章节</a> 中学习 <code>__proto__</code> 的特殊性质，并给出了 <a href="https://zh.javascript.info/prototype-methods">解决此问题的方法</a>。</p>
<h2 id="属性存在性测试，“in”-操作符"><a href="#属性存在性测试，“in”-操作符" class="headerlink" title="属性存在性测试，“in” 操作符"></a>属性存在性测试，“in” 操作符</h2><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p>
<p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">noSuchProperty</span> === <span class="literal">undefined</span> ); <span class="comment">// true 意思是没有这个属性</span></span><br></pre></td></tr></table></figure>

<p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;key&quot;</span> <span class="keyword">in</span> object</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true，user.age 存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false，user.blabla 不存在。</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p>
<p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( key <span class="keyword">in</span> user ); <span class="comment">// true，属性 &quot;age&quot; 存在</span></span><br></pre></td></tr></table></figure>

<p>为何会有 <code>in</code> 运算符呢？与 <code>undefined</code> 进行比较来判断还不够吗？</p>
<p>确实，大部分情况下与 <code>undefined</code> 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 <code>in</code> 运算符的判断结果仍是对的。</p>
<p>那就是属性存在，但存储的值是 <code>undefined</code> 的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">test</span> ); <span class="comment">// 显示 undefined，所以属性不存在？</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;test&quot;</span> <span class="keyword">in</span> obj ); <span class="comment">// true，属性存在！</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，属性 <code>obj.test</code> 事实上是存在的，所以 <code>in</code> 操作符检查通过。</p>
<p>这种情况很少发生，因为通常情况下不应该给对象赋值 <code>undefined</code>。我们通常会用 <code>null</code> 来表示未知的或者空的值。因此，<code>in</code> 运算符是代码中的特殊来宾。</p>
<h2 id="“for-in”-循环"><a href="#“for-in”-循环" class="headerlink" title="“for..in” 循环"></a>“for..in” 循环</h2><p>为了遍历一个对象的所有键<code>（key）</code>，可以使用一个特殊形式的循环：<code>for..in</code>。这跟我们在前面学到的 <code>for(;;)</code> 循环是完全不一样的东西。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// 对此对象属性中的每个键执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，让我们列出 <code>user</code> 所有的属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( key );  <span class="comment">// 会依次输出 name, age, isAdmin</span></span><br><span class="line">  <span class="comment">// 属性键的值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( user[key] ); <span class="comment">// 会依次输出 John, 30, true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，所有的 <code>“for” </code>结构体都允许我们在循环中定义变量，像这里的 <code>let key</code>。</p>
<p>同样，我们可以用其他属性名来替代 <code>key</code>。例如 <code>&quot;for(let prop in obj)&quot;</code> 也很常用。</p>
<h3 id="像对象一样排序"><a href="#像对象一样排序" class="headerlink" title="像对象一样排序"></a>像对象一样排序</h3><p>对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？</p>
<p>简短的回答是：“有特别的顺序”：<strong>整数属性会被进行排序，其他属性则按照创建的顺序显示</strong>。详情如下：</p>
<p>例如，让我们考虑一个带有电话号码的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;德国&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;新西兰&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;大不列颠&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;美国&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(code); <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象可用于面向用户的建议选项列表。如果我们的网站主要面向德国观众，那么我们可能希望 <code>49</code> 排在第一。</p>
<p>但如果我们执行代码，会看到完全不同的现象：</p>
<ul>
<li>美国 (1) 排在了最前面</li>
<li>然后是 新西兰 (41) 及其它。</li>
</ul>
<p>因为这些电话号码是整数，所以它们以升序排列。所以我们看到的是 <code>1, 41, 44, 49</code>。</p>
<p><strong>整数属性？那是什么？</strong></p>
<p>这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。</p>
<p>所以，<code>&quot;49&quot;</code> 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 “+49” 和 “1.2” 就不行了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Number(...) 显式转换为数字</span></span><br><span class="line"><span class="comment">// Math.trunc 是内建的去除小数部分的方法。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;49&quot;</span>))) ); <span class="comment">// &quot;49&quot;，相同，整数属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;+49&quot;</span>))) ); <span class="comment">// &quot;49&quot;，不同于 &quot;+49&quot; ⇒ 不是整数属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;1.2&quot;</span>))) ); <span class="comment">// &quot;1&quot;，不同于 &quot;1.2&quot; ⇒ 不是整数属性</span></span><br></pre></td></tr></table></figure>

<p>……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 增加一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非整数属性是按照创建的顺序来排列的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( prop ); <span class="comment">// name, surname, age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，为了解决电话号码的问题，我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p>
<p>像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;德国&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;新西兰&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;大不列颠&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;美国&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( +code ); <span class="comment">// 49, 41, 44, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在跟预想的一样了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象是具有一些特殊特性的关联数组。</p>
<p>它们存储<code>属性名</code>与<code>属性值</code>（键值对），其中：</p>
<ul>
<li>属性的键必须是字符串或者 symbol（通常是字符串）。</li>
<li>值可以是任何类型。</li>
</ul>
<p>我们可以用下面的方法访问属性：</p>
<ul>
<li>点符号: <code>obj.property</code>。</li>
<li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li>
</ul>
<p>其他操作：</p>
<ul>
<li>删除属性：<code>delete obj.prop</code>。</li>
<li>检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>。</li>
<li>遍历对象：<code>for(let key in obj)</code> 循环。</li>
</ul>
<blockquote>
<p>遍历的对象除了整数型的属性名是按照数值大小来排序；其余的对象都是按照编写顺序进行依次输出。</p>
</blockquote>
<p>我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。</p>
<p>JavaScript 中还有很多其他类型的对象：</p>
<ul>
<li><code>Array</code> 用于存储有序数据集合，</li>
<li><code>Date</code> 用于存储时间日期，</li>
<li><code>Error</code> 用于存储错误信息。</li>
<li>……等等。</li>
</ul>
<p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。</p>
<p>JavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。</p>
<hr>
<h1 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h1><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制。</p>
<p>如果我们深入了解复制值时会发生什么，就很容易理解了。</p>
<p>让我们从原始类型开始，例如一个字符串。</p>
<p>这里我们将 <code>message</code> 复制到 <code>phrase</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = message;</span><br></pre></td></tr></table></figure>

<p>结果我们就有了两个独立的变量，每个都存储着字符串 <code>&quot;Hello!&quot;</code>。</p>
<p>显而易见的结果，对吧？</p>
<p>但是，对象不是这样的。</p>
<p><strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong></p>
<p>让我们看一个这样的变量的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>我们可以将一个对象变量（例如 <code>user</code>）想象成一个有对象的地址的快捷方式。</p>
<p>当我们对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p>
<p>现在，这就是为什么它很重要。</p>
<p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user; <span class="comment">// 复制引用</span></span><br></pre></td></tr></table></figure>

<p>现在我们有了两个变量，它们保存的都是对同一个对象的引用：</p>
<p>正如你所看到的，这里仍然只有一个对象，但现在有两个引用它的变量。</p>
<p>我们可以通过其中任意一个变量来访问该对象并修改它的内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line"></span><br><span class="line">admin.<span class="property">name</span> = <span class="string">&#x27;Pete&#x27;</span>; <span class="comment">// 通过 &quot;admin&quot; 引用来修改</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span></span><br></pre></td></tr></table></figure>

<p>这就像我们为一个A文件创立了两个快捷方式，使用其中一个快捷方式（<code>admin</code>）打开文件并更改了里面的东西。那么，如果我们稍后用另一个快捷方式（<code>user</code>），我们仍然可以打开同一个文件并且可以访问更改的内容。</p>
<h2 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a>通过引用来比较</h2><p>仅当两个对象为同一对象时，两者才相等。</p>
<p>例如，这里 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以它们相等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 复制引用</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a == b ); <span class="comment">// true，都引用同一对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a === b ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;; <span class="comment">// 两个独立的对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a == b ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>对于类似 <code>obj1 &gt; obj2</code> 的比较，或者跟一个原始类型值的比较 <code>obj == 5</code>，对象都会被转换为原始值。我们很快就会学到对象是如何转换的，但是说实话，很少需要进行这样的比较 —— 通常是在编程错误的时候才会出现这种情况。</p>
<h2 id="克隆与合并，Object-assign"><a href="#克隆与合并，Object-assign" class="headerlink" title="克隆与合并，Object.assign"></a>克隆与合并，Object.assign</h2><p>那么，拷贝一个对象变量会又创建一个对相同对象的引用。</p>
<p>但是，如果我们想要复制一个对象，那该怎么做呢？</p>
<p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = &#123;&#125;; <span class="comment">// 新的空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 user 中所有的属性拷贝到其中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  clone[key] = user[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 clone 是带有相同内容的完全独立的对象</span></span><br><span class="line">clone.<span class="property">name</span> = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// 改变了其中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// 原来的对象中的 name 属性依然是 John</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法来达成同样的效果。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, [src1, src2, src3...])</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 <code>dest</code> 是指目标对象。</li>
<li>更后面的参数 <code>src1, ..., srcN</code>（可按需传递多个参数）是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的对象的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 <code>dest</code>。</li>
</ul>
<p>例如，我们可以用它来合并多个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br></pre></td></tr></table></figure>

<p>它将 <code>user</code> 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</p>
<p>还有其他克隆对象的方法，例如使用 <a href="https://zh.javascript.info/rest-parameters-spread">spread 语法</a> <code>clone = &#123;...user&#125;</code>，在后面的章节中我们会讲到。</p>
<h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h2><p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">sizes</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">182</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">sizes</span>.<span class="property">height</span> ); <span class="comment">// 182</span></span><br></pre></td></tr></table></figure>

<p>现在这样拷贝 <code>clone.sizes = user.sizes</code> 已经不足够了，因为 <code>user.sizes</code> 是个对象，它会以引用形式被拷贝。因此 <code>clone</code> 和 <code>user</code> 会共用一个 sizes：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">sizes</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">182</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">sizes</span> === clone.<span class="property">sizes</span> ); <span class="comment">// true，同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 和 clone 分享同一个 sizes</span></span><br><span class="line">user.<span class="property">sizes</span>.<span class="property">width</span>++;       <span class="comment">// 通过其中一个改变属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone.<span class="property">sizes</span>.<span class="property">width</span>); <span class="comment">// 51，能从另外一个获取到变更后的结果</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</p>
<p>我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 <a href="https://lodash.com/">lodash</a> 库的 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<p><strong>使用 const 声明的对象也是可以被修改的</strong></p>
<p>通过引用对对象进行存储的一个重要的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// Pete</span></span><br></pre></td></tr></table></figure>

<p>看起来 <code>(*)</code> 行的代码会触发一个错误，但实际并没有。<code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p>
<p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p>
<p>也就是说，如果我们真的需要创建常量对象属性，也是可以的，但使用的是完全不同的方法。我们将在 <a href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章中学习它。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
<p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p>
<p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<hr>
<h1 id="对象方法，”this”"><a href="#对象方法，”this”" class="headerlink" title="对象方法，”this”"></a>对象方法，”this”</h1><p>作为对象属性的函数被称为 <strong>方法</strong>。</p>
<p>通常创建对象来表示真实世界中的实体，如用户和订单等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并且，在现实世界中，用户可以进行 <strong>操作</strong>：从购物车中挑选某物、登录和注销等。</p>
<p>在 JavaScript 中，行为<code>（action）</code>由属性中的函数来表示。</p>
<h2 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h2><p>刚开始，我们来教 <code>user</code> 说 hello：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用函数表达式创建了一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p>
<p>随后我们像这样 <code>user.sayHi()</code> 调用它。用户现在可以说话了！</p>
<p>作为对象属性的函数被称为 <strong>方法</strong>。</p>
<p>所以，在这我们得到了 <code>user</code> 对象的 <code>sayHi</code> 方法。</p>
<p>当然，我们也可以使用预先声明的函数作为方法，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，声明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其作为一个方法添加</span></span><br><span class="line">user.<span class="property">sayHi</span> = sayHi;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p><strong>面向对象编程</strong> OOP</p>
<p>当我们在代码中用对象表示实体时，就是所谓的 <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，简称为 “OOP”。</p>
<p>OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。</p>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>在对象字面量中，有一种更短的（声明）方法的语法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line">user = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们可以省略 <code>&quot;function&quot;</code>，只写 <code>sayHi()</code>。</p>
<p>说实话，这种表示法还是有些不同。在对象继承方面有一些细微的差别（稍后将会介绍），但目前它们并不重要。在几乎所有的情况下，更短的语法是首选的。</p>
<h2 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a>方法中的 “this”</h2><p>通常，对象方法需要访问对象中存储的信息才能完成其工作。</p>
<p>例如，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p>
<p><strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong></p>
<p><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// &quot;this&quot; 指的是“当前的对象”</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p>
<p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// &quot;user&quot; 替代 &quot;this&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>……但这样的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p>
<p>下面这个示例证实了这一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// 导致错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line">user = <span class="literal">null</span>; <span class="comment">// 重写让其更明显</span></span><br><span class="line"></span><br><span class="line">admin.<span class="title function_">sayHi</span>(); <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br></pre></td></tr></table></figure>

<p>如果我们在 <code>console.log</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p>
<h2 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a>“this” 不受限制</h2><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</p>
<p>下面这样的代码没有语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
<p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.<span class="property">f</span> = sayHi;</span><br><span class="line">admin.<span class="property">f</span> = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.<span class="title function_">f</span>(); <span class="comment">// John（this == user）</span></span><br><span class="line">admin.<span class="title function_">f</span>(); <span class="comment">// Admin（this == admin）</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>

<p>这个规则很简单：如果 <code>obj.f()</code> 被调用了，则 <code>this</code> 在 <code>f</code> 函数调用期间是 <code>obj</code>。所以在上面的例子中 this 先是 <code>user</code>，之后是 <code>admin</code>。</p>
<p><strong>在没有对象的情况下调用：<code>this == undefined</code></strong></p>
<p>我们甚至可以在没有对象的情况下调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p>
<p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会在 <a href="https://zh.javascript.info/global-object">全局对象</a> 一章中学习它）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p>
<p>通常这种调用是程序出错了。如果在一个函数内部有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的。</p>
<p><strong>解除 <code>this</code> 绑定的后果</strong></p>
<p>如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是有指向该对象的 <code>this</code>。</p>
<p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p>
<p>在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。</p>
<p>这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p>
<h2 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a>箭头函数没有自己的 “this”</h2><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p>
<p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Ilya&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">firstName</span>);</span><br><span class="line">    <span class="title function_">arrow</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure>

<p>这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。在后面的 <a href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a> 一章中，我们将深入介绍箭头函数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>存储在对象属性中的函数被称为“方法”。</li>
<li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”。</li>
<li>方法可以将对象引用为 <code>this</code>。</li>
</ul>
<p><code>this</code> 的值是在程序运行时得到的。</p>
<ul>
<li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li>
<li>可以方便在对象之间复制函数。</li>
<li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li>
</ul>
<p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p>
<hr>
<h1 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h1><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。</p>
<p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数在技术上是常规函数。不过有两个约定：</p>
<ol>
<li>它们的命名以大写字母开头。</li>
<li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">isAdmin</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值。</li>
</ol>
<p>换句话说，<code>new User(...)</code> 做的就是类似的事情：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p>
<p>这是<strong>构造器的主要目的 —— 实现可重用的对象创建代码</strong>。</p>
<p>让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
<p><strong>new function() { … }</strong></p>
<p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句</span></span><br><span class="line">  <span class="comment">// 局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p>
<h2 id="构造器模式测试：new-target-（选学）"><a href="#构造器模式测试：new-target-（选学）" class="headerlink" title="构造器模式测试：new.target （选学）"></a>构造器模式测试：new.target （选学）</h2><p><strong>进阶内容</strong></p>
<p><strong>本节涉及的语法内容很少使用</strong>，除非你想了解所有内容，否则你可以直接跳过该语法。</p>
<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了。</p>
<p>对于常规调用，它为 undefined，对于使用 <code>new</code> 的调用，则等于该函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带 &quot;new&quot;：</span></span><br><span class="line"><span class="title class_">User</span>(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 &quot;new&quot;：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// function User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<p>它可以被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p>
<p>我们也可以让 <code>new</code> 调用和常规调用做相同的工作，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果你没有通过 new 运行我</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name); <span class="comment">// ……我会给你添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向到新用户</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 <code>new</code>，程序都能工作。</p>
<p>不过，到处都使用它并不是一件好事，因为省略了 <code>new</code> 使得很难观察到代码中正在发生什么。而通过 <code>new</code> 我们都可以知道这创建了一个新对象。</p>
<h2 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a>构造器的 return</h2><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p>
<p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BigUser</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;Godzilla&quot;</span> &#125;;  <span class="comment">// &lt;-- 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">new</span> <span class="title class_">BigUser</span>().<span class="property">name</span> );  <span class="comment">// Godzilla，得到了那个对象</span></span><br></pre></td></tr></table></figure>

<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SmallUser</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// &lt;-- 返回 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">new</span> <span class="title class_">SmallUser</span>().<span class="property">name</span> );  <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p>
<p><strong>省略括号</strong></p>
<p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>; <span class="comment">// &lt;-- 没有参数</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p>
<h2 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a>构造器中的方法</h2><p>使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。</p>
<p>当然，我们不仅可以将属性添加到 <code>this</code> 中，还可以添加方法。</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;My name is: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">john.<span class="title function_">sayHi</span>(); <span class="comment">// My name is: John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">john = &#123;</span></span><br><span class="line"><span class="comment">   name: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">   sayHi: function() &#123; ... &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zh.javascript.info/classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li>
<li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li>
</ul>
<p>我们可以使用构造函数来创建多个类似的对象。</p>
<p>JavaScript 为许多内建的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p>
<p><strong>对象，我们还会回来哒！</strong></p>
<p>在本章中，我们只介绍了关于对象和构造器的基础知识。它们对于我们在下一章中，学习更多关于数据类型和函数的相关知识非常重要。</p>
<p>在我们学习了那些之后，我们将回到对象，在 <a href="https://zh.javascript.info/prototypes">原型，继承</a> 和 <a href="https://zh.javascript.info/classes">类</a> 章节中深入介绍它们。</p>
<hr>
<h1 id="可选链-“-”"><a href="#可选链-“-”" class="headerlink" title="可选链 “?.”"></a>可选链 “?.”</h1><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.<br>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p>
<h2 id="“不存在的属性”的问题"><a href="#“不存在的属性”的问题" class="headerlink" title="“不存在的属性”的问题"></a>“不存在的属性”的问题</h2><p>如果你才刚开始读此教程并学习 JavaScript，那可能还没接触到这个问题，但它却相当常见。</p>
<p>举个例子，假设我们有很多个 <code>user</code> 对象，其中存储了我们的用户数据。</p>
<p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p>
<p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span>.<span class="property">street</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 <code>user.address</code> 为 <code>undefined</code>，尝试读取 <code>user.address.street</code> 会失败，并收到一个错误。</p>
<p>但是在很多实际场景中，我们更希望得到的是 <code>undefined</code>（表示没有 <code>street</code> 属性）而不是一个错误。</p>
<p>……还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)）</code>以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span></span><br><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>).<span class="property">innerHTML</span>; </span><br><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure>
<p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p>
<p>我们如何实现这一点呢？</p>
<p>可能最先想到的方案是在访问该值的属性之前，使用 <code>if</code> 或条件运算符 <code>?</code> 对该值进行检查，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> : <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，<code>&quot;user.address&quot;</code> 在代码中出现了两次。</p>
<p>我们看一个以相同方式获取 <code>document.querySelector</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>) ? <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>).<span class="property">innerHTML</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看到用于进行元素搜索的 <code>document.querySelector(&#39;.elem&#39;)</code> 在这里实际上被调用了两次。这样不优雅。</p>
<p>对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。</p>
<p>例如，让我们以相同的方式尝试获取 <code>user.address.street.name</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> ? user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span> : <span class="literal">null</span> : <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。</p>
<p>这里有一种更好的实现方式，就是使用 <code>&amp;&amp;</code> 运算符：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">address</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span> ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。</p>
<p>就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，<code>user.address</code> 被重复写了三遍。</p>
<p>这就是为什么可选链 <code>?.</code> 被加入到了 <code>JavaScript</code> 这门编程语言中。那就是彻底地解决以上所有问题！</p>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</p>
<p>换句话说，例如 <code>value?.prop：</code></p>
<p>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，<br>否则（当 <code>value</code> 为 <code>undefined</code> 或 <code>null</code> 时）则返回结果 <code>undefined</code>。<br>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span>?.<span class="property">street</span> ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<p>代码简洁明了，也不用重复写好几遍属性名。</p>
<p>这里是一个结合 <code>document.querySelector</code> 使用的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>)?.<span class="property">innerHTML</span>; </span><br><span class="line"><span class="comment">// 如果没有符合的元素，则为 undefined</span></span><br></pre></td></tr></table></figure>
<p>即使 对象 <code>user</code> 不存在，使用 <code>user?.address</code> 来读取地址也没问题：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span> ); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span>.<span class="property">street</span> ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>请注意：?. 语法使其前面的值成为可选值，但不会对其后面的起作用。</p>
<p>例如，在 <code>user?.address.street.name</code> 中，<code>?.</code> 允许 <code>user</code> 为 <code>null/undefined</code>（在这种情况下会返回 <code>undefined</code>）也不会报错，但这仅对于 <code>user</code>。更深层次的属性是通过常规方式访问的。如果我们希望它们中的一些也是可选的，那么我们需要使用更多的 <code>?.</code> 来替换 .。</p>
<h2 id="不要过度使用可选链"><a href="#不要过度使用可选链" class="headerlink" title="不要过度使用可选链"></a>不要过度使用可选链</h2><p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p>
<p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p>
<p>那么，如果 <code>user</code> 恰巧为 <code>undefined</code>，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p>
<p><strong>?. 前的变量必须已声明</strong><br>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReferenceError: user is not defined</span></span><br><span class="line">user?.<span class="property">address</span>;</span><br></pre></td></tr></table></figure>
<p><code>?.</code> 前的变量必须已声明（例如 <code>let/const/var user</code> 或作为一个函数参数）。可选链仅适用于已声明的变量。</p>
<h2 id="短路效应"><a href="#短路效应" class="headerlink" title="短路效应"></a>短路效应</h2><p>正如前面所说的，如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</p>
<p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">user?.<span class="title function_">sayHi</span>(x++); <span class="comment">// 没有 &quot;user&quot;，因此代码执行没有到达 sayHi 调用和 x++</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0，值没有增加</span></span><br></pre></td></tr></table></figure>
<p>其它变体：<code>?.()</code>，<code>?.[]</code><br>可选链 <code>?.</code> 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。</p>
<p>例如，将 <code>?.()</code> 用于调用一个可能不存在的函数。</p>
<p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> userAdmin = &#123;</span><br><span class="line">  <span class="title function_">admin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am admin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userGuest = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">userAdmin.<span class="property">admin</span>?.(); <span class="comment">// I am admin</span></span><br><span class="line"></span><br><span class="line">userGuest.<span class="property">admin</span>?.(); <span class="comment">// 啥都没发生（没有这样的方法）</span></span><br></pre></td></tr></table></figure>
<p>在这两行代码中，我们首先使用点符号<code>（userAdmin.admin）</code>来获取 <code>admin</code> 属性，因为我们假定对象 <code>userAdmin</code> 存在，因此可以安全地读取它。</p>
<p>然后 <code>?.()</code> 会检查它左边的部分：如果 <code>admin</code> 函数存在，那么就调用运行它（对于 <code>userAdmin）</code>。否则（对于 <code>userGuest）</code> 运算停止，没有报错。</p>
<p>如果我们想使用方括号 <code>[]</code> 而不是点符号 <code>.</code> 来访问属性，语法 <code>?.[]</code> 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;firstName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user1?.[key] ); <span class="comment">// John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user2?.[key] ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以将 <code>?.</code> 跟 <code>delete</code> 一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> user?.<span class="property">name</span>; <span class="comment">// 如果 user 存在，则删除 user.name</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>?.</code> 来安全地读取或删除，但不能写入<br>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">user?.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>; <span class="comment">// Error，不起作用</span></span><br><span class="line"><span class="comment">// 因为它在计算的是：undefined = &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>可选链 <code>?.</code> 语法有三种形式：</p>
<p><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。<br><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.[prop]</code>，否则返回 <code>undefined</code>。<br><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。<br>正如我们所看到的，这些语法形式用起来都很简单直接。<code>?.</code> 检查左边部分是否为 <code>null/undefined</code>，如果不是则继续运算。</p>
<p><code>?.</code> 链使我们能够安全地访问嵌套属性。</p>
<p>但是，我们应该谨慎地使用 <code>?.</code>，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。</p>
<hr>
<h1 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h1><p>【不常用】可以等基础知识学完再来学习。</p>
<p>根据规范，只有两种原始类型可以用作对象属性键：</p>
<ul>
<li>字符串类型</li>
<li>symbol 类型</li>
</ul>
<p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串， <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p>
<p>到目前为止，我们一直只使用字符串。</p>
<p>现在我们来看看 <code>symbol</code> 能给我们带来什么。</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>“symbol”</code> 值表示唯一的标识符。</p>
<p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>
<p>创建时，我们可以给 <code>symbol</code> 一个描述（也称为 symbol 名），这在代码调试时非常有用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 symbol</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>symbol</code> 保证是唯一的。即使我们创建了许多具有相同描述的 <code>symbol</code>，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<p>例如，这里有两个描述相同的 <code>symbol</code> —— 它们不相等：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果你熟悉 <code>Ruby</code> 或者其他有 <code>“symbol”</code> 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。</p>
<p>所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。</p>
<p><strong>symbol 不会被自动转换为字符串</strong><br>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 console.log 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。</p>
<p>例如，这个 console.log 将会提示出错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id); <span class="comment">// 类型错误：无法将 symbol 值转换为字符串。</span></span><br></pre></td></tr></table></figure>
<p>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p>
<p>如果我们真的想显示一个 <code>symbol</code>，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toString</span>()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br></pre></td></tr></table></figure>
<p>或者获取 <code>symbol.description</code> 属性，只显示描述<code>（description）</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="property">description</span>); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<h2 id="“隐藏”属性"><a href="#“隐藏”属性" class="headerlink" title="“隐藏”属性"></a>“隐藏”属性</h2><p><code>symbol</code> 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p>
<p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p>
<p>我们可以给它们使用 <code>symbol</code> 键：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user[id] ); <span class="comment">// 我们可以使用 symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p>
<p>由于 <code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 <code>symbol</code> 属性不会被意外访问到。第三方代码不会知道新定义的 <code>symbol</code>，因此将 <code>symbol</code> 添加到 <code>user</code> 对象是安全的。</p>
<p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。</p>
<p>那么，该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="string">&quot;Their id value&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们的标识符和它们的标识符之间不会有冲突，因为 <code>symbol</code> 总是不同的，即使它们有相同的名字。</p>
<p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 <code>symbol</code>，那么 就会 出现冲突：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span></span><br><span class="line">user.<span class="property">id</span> = <span class="string">&quot;Our id value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">id</span> = <span class="string">&quot;Their id value&quot;</span></span><br><span class="line"><span class="comment">// 砰！无意中被另一个脚本重写了 id！</span></span><br></pre></td></tr></table></figure>
<p>对象字面量中的 <code>symbol</code><br>如果我们要在对象字面量 {…} 中使用 <code>symbol</code>，则需要使用方括号把它括起来。</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  [id]: <span class="number">123</span> <span class="comment">// 而不是 &quot;id&quot;：123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 <code>“id”</code>。</p>
<p><code>symbol</code> 在 <code>for…in</code> 中会被跳过<br><code>symbol</code> 属性不参与 <code>for..in</code> 循环。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">[id]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name, age（没有 symbol）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 symbol 任务直接访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Direct: &quot;</span> + user[id]); <span class="comment">// Direct: 123</span></span><br></pre></td></tr></table></figure>
<p><code>Object.keys(user)</code> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>相反，<code>Object.assign</code> 会同时复制字符串和 <code>symbol</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">[id]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( clone[id] ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 <code>object</code> 时，通常希望 所有 属性被复制（包括像 <code>id</code> 这样的 <code>symbol</code>）。</p>
<h2 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a>全局 symbol</h2><p>正如我们所看到的，通常所有的 <code>symbol</code> 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 <code>symbol</code> 具有相同的实体。例如，应用程序的不同部分想要访问的 <code>symbol &quot;id&quot;</code> 指的是完全相同的属性。</p>
<p>为了实现这一点，这里有一个 全局 <code>symbol</code> 注册表。我们可以在其中创建 <code>symbol</code> 并在稍后访问它们，它可以确保每次访问相同名字的 <code>symbol</code> 时，返回的都是相同的 <code>symbol</code>。</p>
<p>要从注册表中读取（不存在则创建）<code>symbol</code>，请使用 <code>Symbol.for(key)</code>。</p>
<p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 <code>symbol</code>，则返回该 <code>symbol</code>，否则将创建一个新 <code>symbol（Symbol(key)）</code>，并通过给定的 <code>key</code> 将其存储在注册表中。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( id === idAgain ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注册表内的 <code>symbol</code> 被称为 <code>全局 symbol</code>。如果我们想要一个应用程序范围内的 <code>symbol</code>，可以在代码中随处访问 —— 这就是它们的用途。</p>
<p>这听起来像 Ruby<br>在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。</p>
<p>正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。</p>
<p><strong>Symbol.keyFor</strong><br>我们已经看到，对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。<br>相反，通过全局 symbol 返回一个名字，我们可以使用 Symbol.keyFor(sym)：</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 name 获取 symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 symbol 获取 name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym) ); <span class="comment">// name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym2) ); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined。</p>
<p>但是，所有 symbol 都具有 description 属性。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(globalSymbol) ); <span class="comment">// name，全局 symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(localSymbol) ); <span class="comment">// undefined，非全局</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( localSymbol.<span class="property">description</span> ); <span class="comment">// name</span></span><br></pre></td></tr></table></figure>

<h2 id="系统-symbol"><a href="#系统-symbol" class="headerlink" title="系统 symbol"></a>系统 symbol</h2><p>JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。</p>
<p>它们都被列在了 众所周知的 symbol 表的规范中：</p>
<ul>
<li>Symbol.hasInstance</li>
<li>Symbol.isConcatSpreadable</li>
<li>Symbol.iterator</li>
<li>Symbol.toPrimitive<br>……等等。<br>例如，Symbol.toPrimitive 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</li>
</ul>
<p>当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>symbol 是唯一标识符的基本类型</p>
<p>symbol 是使用带有可选描述（name）的 Symbol() 调用创建的。</p>
<p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：Symbol.for(key) 返回（如果需要的话则创建）一个以 key 作为名字的全局 symbol。使用 Symbol.for 多次调用 key 相同的 symbol 时，返回的就是同一个 symbol。</p>
<p>symbol 有两个主要的使用场景：</p>
<p> “隐藏” 对象属性。</p>
<p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
<p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 Symbol.iterator 来进行 迭代 操作，使用 Symbol.toPrimitive 来设置 对象原始值的转换 等等。</p>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的 所有 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<hr>
<h1 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h1><p>当对象相加 obj1 + obj2，相减 obj1 - obj2，或者使用 alert(obj) 打印时会发生什么？</p>
<p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同，我们无法实现特殊的对象处理方法来处理加法（或其他运算）。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。</p>
<p>这是一个重要的限制：因为 obj1 + obj2（或者其他数学运算）的结果不能是另一个对象！</p>
<p>例如，我们无法使用对象来表示向量或矩阵，把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。</p>
<p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p>
<p>本文将介绍对象是如何转换为原始值的，以及如何对其进行自定义。</p>
<p>我们有两个目的：</p>
<p>让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。<br>也有例外，这些操作也可以是可行的。例如日期相减或比较（Date 对象）。我们稍后会遇到它们。</p>
<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><p>在 类型转换 一章中，我们已经看到了数字、字符串和布尔转换的规则。但是我们没有讲对象的转换规则。现在我们已经掌握了方法（method）和 symbol 的相关知识，可以开始学习对象原始值转换了。</p>
<p>没有转换为布尔值。所有的对象在布尔上下文（context）中均为 true，就这么简单。只有字符串和数字转换。<br>数字转换发生在对象相减或应用数学函数时。例如，Date 对象（将在 日期和时间 一章中介绍）可以相减，date1 - date2 的结果是两个日期之间的差值。<br>至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。<br>我们可以使用特殊的对象方法，自己实现字符串和数字的转换。</p>
<p>现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。</p>
<h2 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h2><p>JavaScript 是如何决定应用哪种转换的？</p>
<p>类型转换在各种情况下有三种变体。它们被称为 “hint”，在 规范 所述：</p>
<p>“string”<br>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”：</p>
<p>&#x2F;&#x2F; 输出<br>alert(obj);</p>
<p>&#x2F;&#x2F; 将对象作为属性键<br>anotherObj[obj] &#x3D; 123;<br>“number”<br>对象到数字的转换，例如当我们进行数学运算时：</p>
<p>&#x2F;&#x2F; 显式转换<br>let num &#x3D; Number(obj);</p>
<p>&#x2F;&#x2F; 数学运算（除了二元加法）<br>let n &#x3D; +obj; &#x2F;&#x2F; 一元加法<br>let delta &#x3D; date1 - date2;</p>
<p>&#x2F;&#x2F; 小于&#x2F;大于的比较<br>let greater &#x3D; user1 &gt; user2;<br>大多数内建的数学函数也包括这种转换。</p>
<p>“default”<br>在少数情况下发生，当运算符“不确定”期望值的类型时。</p>
<p>例如，二元加法 + 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 “default” hint 来对其进行转换。</p>
<p>此外，如果对象被用于与字符串、数字或 symbol 进行 &#x3D;&#x3D; 比较，这时到底应该进行哪种转换也不是很明确，因此使用 “default” hint。</p>
<p>&#x2F;&#x2F; 二元加法使用默认 hint<br>let total &#x3D; obj1 + obj2;</p>
<p>&#x2F;&#x2F; obj &#x3D;&#x3D; number 使用默认 hint<br>if (user &#x3D;&#x3D; 1) { … };<br>像 &lt; 和 &gt; 这样的小于&#x2F;大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint，而不是 “default”。这是历史原因。</p>
<p>上面这些规则看起来比较复杂，但在实践中其实挺简单的。</p>
<p>除了一种情况（Date 对象，我们稍后会讲到）之外，所有内建对象都以和 “number” 相同的方式实现 “default” 转换。我们也可以这样做。</p>
<p>尽管如此，了解上述的 3 个 hint 还是很重要的，很快你就会明白为什么这样说。</p>
<p>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</p>
<p>调用 obj<a href="hint">Symbol.toPrimitive</a> —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话，<br>否则，如果 hint 是 “string” —— 尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。<br>否则，如果 hint 是 “number” 或 “default” —— 尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。</p>
<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p>我们从第一个方法开始。有一个名为 Symbol.toPrimitive 的内建 symbol，它被用来给转换方法命名，像这样：</p>
<p>obj[Symbol.toPrimitive] &#x3D; function(hint) {<br>  &#x2F;&#x2F; 这里是将此对象转换为原始值的代码<br>  &#x2F;&#x2F; 它必须返回一个原始值<br>  &#x2F;&#x2F; hint &#x3D; “string”、”number” 或 “default” 中的一个<br>}<br>如果 Symbol.toPrimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。</p>
<p>例如，这里 user 对象实现了它：</p>
<p>let user &#x3D; {<br>  name: “John”,<br>  money: 1000,</p>
<p>  <a href="hint">Symbol.toPrimitive</a> {<br>    alert(<code>hint: $&#123;hint&#125;</code>);<br>    return hint &#x3D;&#x3D; “string” ? <code>&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;</code> : this.money;<br>  }<br>};</p>
<p>&#x2F;&#x2F; 转换演示：<br>alert(user); &#x2F;&#x2F; hint: string -&gt; {name: “John”}<br>alert(+user); &#x2F;&#x2F; hint: number -&gt; 1000<br>alert(user + 500); &#x2F;&#x2F; hint: default -&gt; 1500<br>从代码中我们可以看到，根据转换的不同，user 变成一个自描述字符串或者一个金额。user[Symbol.toPrimitive] 方法处理了所有的转换情况。</p>
<h2 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString&#x2F;valueOf"></a>toString&#x2F;valueOf</h2><p>如果没有 Symbol.toPrimitive，那么 JavaScript 将尝试寻找 toString 和 valueOf 方法：</p>
<p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。<br>toString 和 valueOf 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p>
<p>这些方法必须返回一个原始值。如果 toString 或 valueOf 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 toString 和 valueOf 方法：</p>
<p>toString 方法返回一个字符串 “[object Object]”。<br>valueOf 方法返回对象自身。<br>下面是一个示例：</p>
<p>let user &#x3D; {name: “John”};</p>
<p>alert(user); &#x2F;&#x2F; [object Object]<br>alert(user.valueOf() &#x3D;&#x3D;&#x3D; user); &#x2F;&#x2F; true<br>所以，如果我们尝试将一个对象当做字符串来使用，例如在 alert 中，那么在默认情况下我们会看到 [object Object]。</p>
<p>这里提到的默认的 valueOf 只是为了完整起见，以避免混淆。正如你看到的，它返回对象本身，因此被忽略。别问我为什么，这是历史原因。所以我们可以假设它根本就不存在。</p>
<p>让我们实现一下这些方法来自定义转换。</p>
<p>例如，这里的 user 执行和前面提到的那个 user 一样的操作，使用 toString 和 valueOf 的组合（而不是 Symbol.toPrimitive）：</p>
<p>let user &#x3D; {<br>  name: “John”,<br>  money: 1000,</p>
<p>  &#x2F;&#x2F; 对于 hint&#x3D;”string”<br>  toString() {<br>    return <code>&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;</code>;<br>  },</p>
<p>  &#x2F;&#x2F; 对于 hint&#x3D;”number” 或 “default”<br>  valueOf() {<br>    return this.money;<br>  }</p>
<p>};</p>
<p>alert(user); &#x2F;&#x2F; toString -&gt; {name: “John”}<br>alert(+user); &#x2F;&#x2F; valueOf -&gt; 1000<br>alert(user + 500); &#x2F;&#x2F; valueOf -&gt; 1500<br>我们可以看到，执行的动作和前面使用 Symbol.toPrimitive 的那个例子相同。</p>
<p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 toString，就像这样：</p>
<p>let user &#x3D; {<br>  name: “John”,</p>
<p>  toString() {<br>    return this.name;<br>  }<br>};</p>
<p>alert(user); &#x2F;&#x2F; toString -&gt; John<br>alert(user + 500); &#x2F;&#x2F; toString -&gt; John500<br>如果没有 Symbol.toPrimitive 和 valueOf，toString 将处理所有原始转换。</p>
<p>转换可以返回任何原始类型<br>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>
<p>没有限制 toString() 是否返回字符串，或 Symbol.toPrimitive 方法是否为 “number” hint 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<p>历史原因<br>由于历史原因，如果 toString 或 valueOf 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>
<p>相反，Symbol.toPrimitive 更严格，它 必须 返回一个原始值，否则就会出现 error。</p>
<h2 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h2><p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 * 将操作数转换为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p>
<p>对象被转换为原始值（通过前面我们描述的规则）。<br>如果还需要进一步计算，则生成的原始值会被进一步转换。<br>例如：</p>
<p>let obj &#x3D; {<br>  &#x2F;&#x2F; toString 在没有其他方法的情况下处理所有转换<br>  toString() {<br>    return “2”;<br>  }<br>};</p>
<p>alert(obj * 2); &#x2F;&#x2F; 4，对象被转换为原始值字符串 “2”，之后它被乘法转换为数字 2。<br>乘法 obj * 2 首先将对象转换为原始值（字符串 “2”）。<br>之后 “2” * 2 变为 2 * 2（字符串被转换为数字）。<br>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p>
<p>let obj &#x3D; {<br>  toString() {<br>    return “2”;<br>  }<br>};</p>
<p>alert(obj + 2); &#x2F;&#x2F; 22（”2” + 2）被转换为原始值字符串 &#x3D;&gt; 级联</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型（hint）：</p>
<p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）<br>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<p>调用 obj<a href="hint">Symbol.toPrimitive</a> 如果这个方法存在，<br>否则，如果 hint 是 “string”<br>尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。<br>否则，如果 hint 是 “number” 或者 “default”<br>尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。<br>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p>
<p>在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>
<hr>
]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>//blog/note/markdown/yufa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>在需要目录出现的地方（一般在文章一开始）放置一个标记<code>[toc]</code>，这样会自动生成一个嵌套的包含所有标题的列表。</p>
<p>[toc]</p>
<hr>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>Typora快捷键整合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+1  一阶标题    Ctrl+B  字体加粗</span><br><span class="line">Ctrl+2  二阶标题    Ctrl+I  字体倾斜</span><br><span class="line">Ctrl+3  三阶标题    Ctrl+U  下划线</span><br><span class="line">Ctrl+4  四阶标题    Ctrl+Home   返回Typora顶部</span><br><span class="line">Ctrl+5  五阶标题    Ctrl+End    返回Typora底部</span><br><span class="line">Ctrl+6  六阶标题    Ctrl+T  创建表格</span><br><span class="line">Ctrl+L  选中某句话   Ctrl+K  创建超链接</span><br><span class="line">Ctrl+D  选中某个单词  Ctrl+F  搜索</span><br><span class="line">Ctrl+E  选中相同格式的文字   Ctrl+H  搜索并替换</span><br><span class="line"></span><br><span class="line">Alt+Shift+5 	删除线 </span><br><span class="line">Ctrl+Shift+I    插入图片</span><br><span class="line">Ctrl+Shift+M    公式块 </span><br><span class="line">Ctrl+Shift+Q    引用</span><br><span class="line"></span><br><span class="line">插入代码： Ctrl/Cmd + Shift + C</span><br><span class="line">行内代码： Ctrl/Cmd + Shift + K</span><br><span class="line">插入图片： Ctrl/Cmd + Shift + I</span><br><span class="line">无序列表： Ctrl/Cmd + Shift + L</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="一、标题语法"><a href="#一、标题语法" class="headerlink" title="一、标题语法"></a>一、标题语法</h1><p>请在单词或短语前面添加井号 (<code>#</code>) 。<code>#</code> 的数量代表了标题的级别。</p>
<p>（注意，#号与文字中间需要输入一个空格）  </p>
<p>不同的 Markdown 应用程序处理 <code>#</code> 和标题之间的空格方式并不一致。为了兼容考虑，请用一个空格在 <code>#</code> 和标题之间进行分隔。</p>
<p>快捷键 <code>Ctrl + 数字键</code> 可以设置标题级别</p>
<hr>
<h1 id="二、段-行语法"><a href="#二、段-行语法" class="headerlink" title="二、段&#x2F;行语法"></a>二、段&#x2F;行语法</h1><h2 id="1-换行"><a href="#1-换行" class="headerlink" title="1.换行"></a>1.换行</h2><p>Typora 直接换行回车，实现换行；</p>
<p>但是在有的地方，想要换行必须得在一行字后面输入两个空格才行。</p>
<p>在编辑的时候有多少个空行(只有回车或者空格就算空行)，在渲染之后，只隔着一行。</p>
<h2 id="2-分割线"><a href="#2-分割线" class="headerlink" title="2.分割线"></a>2.分割线</h2><p>请在单独一行上使用三个或多个星号 (<code>***</code>)、破折号 (<code>---</code>) 或下划线 (<code>___</code>) </p>
<p>为了显示最好的效果，在分割线前后各空一行</p>
<h2 id="3-对齐方式"><a href="#3-对齐方式" class="headerlink" title="3.对齐方式"></a>3.对齐方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;center&gt;行中心对齐&lt;/center&gt;</span><br><span class="line">&lt;p align=&quot;left&quot;&gt;行左对齐&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;行右对齐&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">显示效果如下</span><br></pre></td></tr></table></figure>

<center>行中心对齐</center>
<p align="left">行左对齐</p>
<p align="right">行右对齐</p>



<h2 id="4-脚注"><a href="#4-脚注" class="headerlink" title="4.脚注"></a>4.脚注</h2><p>在需要插入脚注的地方，加上<code>[^1]</code>即可</p>
<p>你可以创建一个脚注，像这样[^1].		<code>按住Crtrl + 鼠标左键点击即可实现跳转</code></p>
<p>注意：该例子脚注标识是1，脚注标识可以为字母数字下划线，但是暂不支持中文。脚注内容可为任意字符，包括中文。</p>
<hr>
<h1 id="三、字体语法"><a href="#三、字体语法" class="headerlink" title="三、字体语法"></a>三、字体语法</h1><h2 id="1-粗体"><a href="#1-粗体" class="headerlink" title="1.粗体"></a>1.粗体</h2><p>请在单词或短语的前后各添加两个星号或下划线。</p>
<p>如需加粗一个单词或短语的中间部分用以表示强调的话，请在要加粗部分的两侧各添加两个星号</p>
<p>例如</p>
<p>1.使用<code>**</code>号加粗			    	<strong>我是前后两个星号加粗的</strong></p>
<p>2.使用两个<code>__</code>加粗				<strong>我是前后两个下划线加粗的</strong></p>
<h2 id="2-斜体"><a href="#2-斜体" class="headerlink" title="2.斜体"></a>2.斜体</h2><p>在单词或短语 <strong>前后</strong> 添加 <em><strong>1</strong></em> 个星号或下划线。(推荐使用*号)</p>
<p>单词的中间部分，请在字母前后各添加一个星号，中间不要带空格。</p>
<p>*号适用于文字与字母的斜体</p>
<p>下划线_不能用于英文字母的中间显示,会失效的</p>
<p>例如</p>
<p>1.使用<code>*</code>号斜体		<em>这是用星号进行斜体显示dasdasasdaasdsa</em></p>
<p>2.下划线<code>_</code>				<em>这是使用下划线斜体显示asdasdasdasdad</em></p>
<p>3.英文字母串中间部分只能用*号进行斜体显示，下划线会失败</p>
<p>aasd<em>asdasda</em></p>
<p>aasd_asdasda_</p>
<h2 id="3-粗体-斜体"><a href="#3-粗体-斜体" class="headerlink" title="3.粗体+斜体"></a>3.粗体+斜体</h2><p>请在要突出显示的部分前后各添加三个星号，中间不要带空格。</p>
<p>例如</p>
<p>使用<code>**</code>对字体加粗     <strong>粗体</strong></p>
<p><em>斜体</em></p>
<p><em><strong>这是粗体与斜体</strong></em></p>
<h2 id="4-删除线"><a href="#4-删除线" class="headerlink" title="4.删除线"></a>4.删除线</h2><p>在你需要操作的字符先后各加两个<code>~~</code></p>
<p><del>例如我在这串文字前后各加两个小弯弯</del></p>
<h2 id="5-下划线"><a href="#5-下划线" class="headerlink" title="5.下划线"></a>5.下划线</h2><p><em><strong>在你需要操作的字符串前后加标签 	<code>&lt;u&gt; &lt;/u&gt;</code></strong></em></p>
<p><u> 例如我在前后加<code>&lt;u&gt; &lt;/u&gt;</code>两可以添加下划线</u></p>
<p><code>&lt;!--通过Latex公式实现下划线--&gt;</code><br>$\underline{\text{下划线}}$       $\overline{上划线}$ </p>
<p>$\widehat{顶上的宽帽子}$    $\hat{顶上的小帽子}$ 	$\widetilde{顶上显示波浪线}$ 		 $\dot{顶上加点}$<br>$\ddot{顶上显示加两点} $</p>
<h2 id="6-背景高亮"><a href="#6-背景高亮" class="headerlink" title="6.背景高亮"></a>6.背景高亮</h2><p>使用<code>==</code>再文本前后，即可实现高亮</p>
<p>&#x3D;&#x3D;我是高亮文本&#x3D;&#x3D;</p>
<h2 id="7-上标与下标"><a href="#7-上标与下标" class="headerlink" title="7.上标与下标"></a>7.上标与下标</h2><p>(1)下标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br></pre></td></tr></table></figure>

<p>H<sub>2</sub>O</p>
<p>(2)上标</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X&lt;sup&gt;2&lt;/sup&gt;</span><br></pre></td></tr></table></figure>

<p>X<sup>2</sup></p>
<h2 id="8-字体大小"><a href="#8-字体大小" class="headerlink" title="8.字体大小"></a>8.字体大小</h2><p>size：规定文本的尺寸大小，取值范围为1~7 ，默认值是 3。</p>
<p>最大为7号，超过7与7是一样的效果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font size=1&gt;字体大小size=1&lt;/font&gt;</span><br><span class="line">&lt;font size=2&gt;字体大小size=2&lt;/font&gt;</span><br><span class="line">&lt;font size=3&gt;字体大小size=3&lt;/font&gt;</span><br><span class="line">&lt;font size=4&gt;字体大小size=4&lt;/font&gt;</span><br><span class="line">&lt;font size=5&gt;字体大小size=5&lt;/font&gt;</span><br><span class="line">&lt;font size=6&gt;字体大小size=6&lt;/font&gt;</span><br><span class="line">&lt;font size=7&gt;字体大小size=7&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<p><font size=1>字体大小size&#x3D;1</font><br><font size=2>字体大小size&#x3D;2</font><br><font size=3>字体大小size&#x3D;3</font><br><font size=4>字体大小size&#x3D;4</font><br><font size=5>字体大小size&#x3D;5</font><br><font size=6>字体大小size&#x3D;6</font><br><font size=7>字体大小size&#x3D;7</font></p>
<h2 id="9-改变字体颜色"><a href="#9-改变字体颜色" class="headerlink" title="9.改变字体颜色"></a>9.改变字体颜色</h2><p>1、英文字母</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=red&gt;红色&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;blue&quot;&gt;蓝色&lt;/font&gt;</span><br><span class="line">&lt;font color=Yellow&gt;黄色&lt;/font&gt;</span><br><span class="line">&lt;font color=YellowGreen&gt;黄绿色&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<p><font color=red>红色</font><br><font color="blue">蓝色</font><br><font color=Yellow>黄色</font><br><font color=YellowGreen>黄绿色</font></p>
<p>2、十六进制颜色值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;font color=#ff0000&gt;红色&lt;/font&gt;</span><br><span class="line">&lt;font color=#00ff00&gt;绿色&lt;/font&gt;</span><br><span class="line">&lt;font color=#0000ff&gt;蓝色&lt;/font&gt;</span><br></pre></td></tr></table></figure>

<p><font color=#ff0000>红色</font><br><font color=#00ff00>绿色</font><br><font color=#0000ff>蓝色</font></p>
<hr>
<h1 id="四、列表语法"><a href="#四、列表语法" class="headerlink" title="四、列表语法"></a>四、列表语法</h1><h2 id="1-有序列表"><a href="#1-有序列表" class="headerlink" title="1.有序列表"></a>1.有序列表</h2><p>使用  <strong>数字</strong> 紧接 <strong>英文小数点</strong> 再加 <strong>空格</strong></p>
<p>快捷键：<code>Ctrl + Shift + [</code></p>
<p>例如	 </p>
<ol>
<li>第一项<ol>
<li>按下Tab键可以实现列表嵌套</li>
<li>子列表的第二项</li>
</ol>
</li>
<li>第二项</li>
</ol>
<h2 id="2-无序列表"><a href="#2-无序列表" class="headerlink" title="2.无序列表"></a>2.无序列表</h2><p>列表内容前可使用 <code>*</code> 或 <code>-</code> 或 <code>+</code> + <code>空格</code>来表示无序列表</p>
<p>快捷键：<code>Ctrl + Shift + ]</code></p>
<ul>
<li>这是用<code>*</code>显示的无序列表</li>
</ul>
<h2 id="3-任务列表"><a href="#3-任务列表" class="headerlink" title="3.任务列表"></a>3.任务列表</h2><p><code> - [ ] 不勾选     - [x] 勾选</code></p>
<p>一个减号，空格，方括号(括号中间需要输入空格或x)，空格，任务文字</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 任务文字		代码<code>- [ ] 任务文字</code></li>
<li><input disabled="" type="checkbox"> 任务一 未做任务 </li>
<li><input checked="" disabled="" type="checkbox"> 任务二 已做任务</li>
</ul>
<hr>
<h1 id="五、数学表达式"><a href="#五、数学表达式" class="headerlink" title="五、数学表达式"></a>五、数学表达式</h1><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。根据需要加载 Mathjax 对数学公式进行渲染。</p>
<p>LaTeX公式语法<a href="LaTex%E8%AF%AD%E6%B3%95">^2</a></p>
<p>按下 <code>$$</code>，然后按下回车键，即可进行数学公式的编辑。<br>$$<br>\mathbf{V}_1\times\mathbf{V}_2 &#x3D; \mathbf{X}_3<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;_1\times\mathbf&#123;V&#125;_2 = \mathbf&#123;X&#125;_3</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="六、块语法"><a href="#六、块语法" class="headerlink" title="六、块语法"></a>六、块语法</h1><h2 id="1-区块引用"><a href="#1-区块引用" class="headerlink" title="1.区块引用"></a>1.区块引用</h2><p>使用 <code>&gt;</code> + <code>空格</code> 来表示区块引用</p>
<p><em>当需要换行时，可以在前方不加 <code>&gt;</code></em>		<em>需要新板块可以空出一行</em></p>
<p>例如</p>
<blockquote>
<ol>
<li>第一项 这是我的引用文本</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>第二项 xxxxx</li>
</ol>
<blockquote>
<ol>
<li>嵌入列表 我在引用中再输入<code>&gt; + 空格</code>可以实现多层引用</li>
</ol>
</blockquote>
</blockquote>
<blockquote>
<p>[!Warning]</p>
<p>Test</p>
</blockquote>
<blockquote>
<p>[Warning]</p>
<p>这里也是警告，但是没有用感叹号。</p>
</blockquote>
<h2 id="彩色提示块"><a href="#彩色提示块" class="headerlink" title="彩色提示块"></a>彩色提示块</h2><blockquote>
<p>[!NOTE]<br>这是注意区块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [!NOTE]</span><br><span class="line">&gt; 这是注意区块</span><br></pre></td></tr></table></figure>



<blockquote>
<p>[!TIP]<br>这是提示区块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [!TIP]</span><br><span class="line">&gt;这是提示区块</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>[!IMPORTANT]<br>这是强调区块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [!IMPORTANT]</span><br><span class="line">&gt; 这是强调区块</span><br></pre></td></tr></table></figure>



<blockquote>
<p>[!WARNING]<br>这是警告区块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [!WARNING]</span><br><span class="line">&gt; 这是警告区块</span><br></pre></td></tr></table></figure>



<blockquote>
<p>[!CAUTION]<br>这是小心区块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; [!CAUTION]</span><br><span class="line">&gt; 这是小心区块</span><br></pre></td></tr></table></figure>





<h2 id="2-表格插入"><a href="#2-表格插入" class="headerlink" title="2.表格插入"></a>2.表格插入</h2><p>快捷键<code>Ctrl + T</code>即可弹出创建表格的对话框</p>
<p>使用下面的代码也可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| 表头1 | 表头2 | 表头3|</span><br><span class="line">|  |  |</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center"><div style="display:inline-block;width: 80px"> 快捷键 </div></th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Enter</td>
<td>换到下一行</td>
<td></td>
</tr>
<tr>
<td align="center">Shift + Enter</td>
<td>表格内换行</td>
<td></td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Backspace</td>
<td>删除改行</td>
<td></td>
</tr>
<tr>
<td align="center">Alt + 方向键</td>
<td>向上&#x2F;下移动该行</td>
<td></td>
</tr>
<tr>
<td align="center">Ctrl + Enter</td>
<td>添加一行</td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="2-1-如何自定义修改Typora表格宽度"><a href="#2-1-如何自定义修改Typora表格宽度" class="headerlink" title="2.1 如何自定义修改Typora表格宽度"></a>2.1 如何自定义修改Typora表格宽度</h3><ul>
<li>预留宽度，用于打印后填写</li>
</ul>
<p>一个比较简单粗暴的方法自然是加一段空格符</p>
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>一个更加优雅的方法则是使用空的 <img> 标签。例如<code>&lt;img width=200/&gt;</code></p>
<table>
<thead>
<tr>
<th><img width=200/></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>长文本需要指定列宽，控制换行</li>
</ul>
<p>可以使用 <code>&lt;div style=&quot;width:长度&quot;&gt;</code>单元格文本<code>&lt;/div&gt; </code>的形式，</p>
<p>长度单位可以是 pt , px, cm等。</p>
<table>
<thead>
<tr>
<th>表头1</th>
<th>表头2</th>
</tr>
</thead>
<tbody><tr>
<td><div style="width:300pt">&#96;&#96;我使用了300pt的长度</div> &#96;</td>
<td></td>
</tr>
</tbody></table>
<h2 id="3-图片引用"><a href="#3-图片引用" class="headerlink" title="3.图片引用"></a>3.图片引用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片说明](图片地址 <span class="string">&#x27;&#x27;</span>图片title<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">图片说明 ：就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title ：是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line">&lt;img src=<span class="string">&quot;https://im.gurl.eu.org/file/1fa8315a5ce9bc78fac63.png&quot;</span>  style=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>例如</p>
<img src="https://im.gurl.eu.org/file/1fa8315a5ce9bc78fac63.png"  style="zoom:50%;" />

<p><img src="https://im.gurl.eu.org/file/1fa8315a5ce9bc78fac63.png" alt="图片说明"></p>
<h2 id="4-代码块"><a href="#4-代码块" class="headerlink" title="4.代码块"></a>4.代码块</h2><h3 id="1-单行代码"><a href="#1-单行代码" class="headerlink" title="(1).单行代码"></a>(1).单行代码</h3><p>使用 <code>反引号</code> 再文本前后各加一个即可	例如：</p>
<p><code>我的前后各有一个反引号（键盘上左上角 ~ 键，需在英文状态输入）    </code></p>
<h3 id="2-多行代码段"><a href="#2-多行代码段" class="headerlink" title="(2).多行代码段"></a>(2).多行代码段</h3><p>使用 &#96;&#96;&#96;&#96; <code>三个</code> 反引号&#96; 按下回车即可激活代码块</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我按下三个反引号后，按下回车即可激活</span><br><span class="line">非常人性</span><br></pre></td></tr></table></figure>





<h2 id="5-流程图"><a href="#5-流程图" class="headerlink" title="5.流程图"></a>5.流程图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">st=&gt;start: 闹钟响起</span><br><span class="line">op=&gt;operation: 与床板分离</span><br><span class="line">cond=&gt;condition: 分离成功?</span><br><span class="line">e=&gt;end: 快乐的一天</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure>







<h2 id="6-链接引用-超链接"><a href="#6-链接引用-超链接" class="headerlink" title="6.链接引用  超链接"></a>6.链接引用  超链接</h2><p>语法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 <span class="string">&quot;超链接title&quot;</span>)</span><br><span class="line">title可加可不加（title是鼠标移到该链接文本时显示的名称）</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p>超链接名：百度搜索，地址  <a href="http://www.baidu.com/">www.baidu.com</a>	,鼠标移到<code>百度搜索</code>这个文本上时，显示<code>百度搜索的官网</code></p>
<p><a href="https://www.baidu.com/" title="百度搜索的官网">百度搜索</a></p>
<p><a href="https://www.baidu.com/">我是无title的超链接</a></p>
<h2 id="7-视频引用"><a href="#7-视频引用" class="headerlink" title="7.视频引用"></a>7.视频引用</h2><p>这里有两种方法，第一种是使用video标签，第二种是使用iframe标签。</p>
<p>video标签语法如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;video src=&quot;xxxxxx.mp4&quot;  width=&quot;100%&quot; height=&quot;100%&quot;  poster=&quot;xxxxxx.jpg&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;</span><br></pre></td></tr></table></figure>

<p>src是视频的地址；poster是可以设置视频的封面（可选）</p>
<p><video src="https://cesium.com/public/SandcastleSampleData/big-buck-bunny_trailer.mp4"  width="100%" height="100%" poster="https://youimg1.c-ctrip.com/target/010341200061sysx2A203_D_10000_1200.jpg" controls="controls"></video></p>
<hr>
<p>下面是使用iframe标签，这里一般是各大视频网站直接提供的，自己去他们的网站找到复制粘贴即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">引用Bilibili的视频代码如下</span><br><span class="line"></span><br><span class="line">官方给的嵌入代码（只需要在网页版的分享按钮里有嵌入代码）</span><br><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=754099091&amp;bvid=BV1mk4y1m7nr&amp;cid=220770745&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">修改后的代码</span><br><span class="line">&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=754099091&amp;bvid=BV1mk4y1m7nr&amp;cid=220770745&amp;page=1&amp;high_quality=1&amp;danmaku=0&quot; allowfullscreen=&quot;allowfullscreen&quot; width=&quot;100%&quot; height=&quot;500&quot; scrolling=&quot;no&quot; frameborder=&quot;0&quot; sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>



<p>如下是一个实例：</p>
<hr>
<iframe src="//player.bilibili.com/player.html?aid=754099091&bvid=BV1mk4y1m7nr&cid=220770745&page=1&autoplay=0&high_quality=1&danmaku=0" allowfullscreen="allowfullscreen" width="100%" height="500" scrolling="no" frameborder="0" sandbox="allow-top-navigation allow-same-origin allow-forms allow-scripts"></iframe>

 

<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">BILIBILI 地址PC端参数</span><br><span class="line">    &amp;high_quality=1   (1=最高画质 0=最低画质)</span><br><span class="line">    &amp;danmaku=0   (1=打开弹幕 0=关闭弹幕)</span><br><span class="line">iframe 参数</span><br><span class="line">    allowfullscreen=&quot;allowfullscreen&quot; #移动端全屏</span><br><span class="line">    sandbox=&quot;allow-top-navigation allow-same-origin allow-forms allow-scripts&quot; #禁止弹出网页</span><br><span class="line">     autoplay=0     取消自动播放</span><br><span class="line">frameborder 规定是否显示框架周围的边框。好像修改了没啥用？</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">值</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">align</td>
<td align="center">left right top middle bottom</td>
<td align="center">不赞成使用。请使用样式代替。规定如何根据周围的元素来对齐此框架。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">frameborder</td>
<td align="center">10</td>
<td align="center">规定是否显示框架周围的边框。</td>
</tr>
<tr>
<td align="center">height</td>
<td align="center">pixels%</td>
<td align="center">规定 iframe 的高度。</td>
</tr>
<tr>
<td align="center">longdesc</td>
<td align="center">URL</td>
<td align="center">规定一个页面，该页面包含了有关iframe 的较长描述。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">marginheight</td>
<td align="center">pixels</td>
<td align="center">定义 iframe的顶部和底部的边距。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">marginwidth</td>
<td align="center">pixels</td>
<td align="center">定义 iframe的左侧和右侧的边距。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">name</td>
<td align="center">frame_name</td>
<td align="center">规定 iframe 的名称。</td>
</tr>
<tr>
<td align="center">sandbox</td>
<td align="center">“”allow-formsallow-same-originallow-scriptsallow-top-navigation</td>
<td align="center">启用一系列对 &lt;_iframe&gt; 中内容的额外限制。</td>
</tr>
<tr>
<td align="center">scrolling</td>
<td align="center">yesnoauto</td>
<td align="center">规定是否在 iframe中显示滚动条。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">seamless</td>
<td align="center">seamless</td>
<td align="center">规定 &lt;_iframe&gt; 看上去像是包含文档的一部分。</td>
</tr>
<tr>
<td align="center">src</td>
<td align="center">URL</td>
<td align="center">规定在 iframe中显示的文档的 URL。</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">srcdoc</td>
<td align="center">HTML_code</td>
<td align="center">规定在 &lt;_iframe&gt; 中显示的页面的 HTML 内容。</td>
</tr>
<tr>
<td align="center">width</td>
<td align="center">pixels%</td>
<td align="center">定义 iframe 的宽度。</td>
</tr>
</tbody></table>
<h2 id="8-折叠语法"><a href="#8-折叠语法" class="headerlink" title="8.折叠语法"></a>8.折叠语法</h2><details>
  <summary>折叠文本</summary>
  此处可书写文本
  嗯，是可以书写文本的
</details>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;折叠文本&lt;/summary&gt;</span><br><span class="line">  此处可书写文本</span><br><span class="line">  嗯，是可以书写文本的</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure>

<details>
  <summary>折叠代码块</summary>
  <pre><code> 
     console.log("虽然可以折叠代码块");
     console.log("但是代码无法高亮");
     let n = 1;
     function add(a,b)
      &#123;
         return a+b ;
      &#125;
  </code></pre>
</details>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>折叠代码块<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span> </span><br><span class="line">     console.log(&quot;虽然可以折叠代码块&quot;);</span><br><span class="line">     console.log(&quot;但是代码无法高亮&quot;);</span><br><span class="line">     let n = 1;</span><br><span class="line">     function add(a,b)</span><br><span class="line">      &#123;</span><br><span class="line">         return a+b ;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>


<details>
  <summary>折叠代码块</summary>
  <pre><blockcode> 
     console.log("虽然可以折叠代码块");
     console.log("但是代码无法高亮");
     let n = 1;
     function add(a,b)
      {
         return a+b ;
      }
  </blockcode></pre>
</details>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span>折叠代码块<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">blockcode</span>&gt;</span> </span><br><span class="line">     console.log(&quot;虽然可以折叠代码块&quot;);</span><br><span class="line">     console.log(&quot;但是代码无法高亮&quot;);</span><br><span class="line">      let n = 1;</span><br><span class="line">     function add(a,b)</span><br><span class="line">      &#123;</span><br><span class="line">         return a+b ;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">blockcode</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用 <code> 标签更符合语义，因为它明确表示这段文本是代码。<br><blockcode> 没有语义上的意义，因为它不是一个有效的 HTML 标签。</p>
<hr>
<h1 id="七、不常用的语法"><a href="#七、不常用的语法" class="headerlink" title="七、不常用的语法"></a>七、不常用的语法</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释，不会显示--&gt;</span></span><br><span class="line">[comment]: <span class="tag">&lt;&gt;</span> (注释，不会显示)</span><br><span class="line">[//]: <span class="tag">&lt;&gt;</span> (注释，不会显示)</span><br><span class="line">[//]: # (注释，不会显示)</span><br><span class="line">*[^_^]:注释，不会显示</span><br><span class="line">*[@_@]:注释，不会显示</span><br></pre></td></tr></table></figure>





<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;kbd&gt;tab&lt;/kbd&gt;键</span><br><span class="line">&lt;b&gt;粗体&lt;/b&gt;</span><br><span class="line">&lt;i&gt;斜体&lt;/i&gt;</span><br><span class="line">&lt;em&gt;也是斜体&lt;/em&gt;</span><br><span class="line">文本&lt;sup&gt;上标&lt;/sup&gt;</span><br><span class="line">文本&lt;sub&gt;下标&lt;/sub&gt;</span><br><span class="line">换行&lt;br&gt;下一行</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="尾注"><a href="#尾注" class="headerlink" title="尾注"></a>尾注</h1><p>[^1]: 这是上面的注释内容。				<code>用鼠标点一下（非这行）其他的地方，这里就会出现跳转按钮</code></p>
<p>1.行内公式</p>
<p>只需在两个 <code>$$</code>之间输入需要显示的公式即可</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$ f(x) = a+b $</span><br></pre></td></tr></table></figure>

<p>显示的效果：$f(x)=a+b$</p>
<p>2.单独一行的公式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$$ f(x) = a+b $$</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>编程语言入门到精通</title>
    <url>//note/mind/biancheng0-1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>入门了，，，，，</p>
<p>算不上精通。。。。。。</p>
<p>等将来再说吧。。。。</p>
]]></content>
      <categories>
        <category>笔记</category>
        <category>思维</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML学习笔记</title>
    <url>//blog/note/code/html.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="HTML-5-学习笔记"><a href="#HTML-5-学习笔记" class="headerlink" title="HTML 5 学习笔记"></a>HTML 5 学习笔记</h1><h1 id="HTML-入门"><a href="#HTML-入门" class="headerlink" title="HTML 入门"></a>HTML 入门</h1><h2 id="HTML-是什么？"><a href="#HTML-是什么？" class="headerlink" title="HTML 是什么？"></a>HTML 是什么？</h2><p>HTML的全称是<code>Hyper Text Mark Language</code>，译为 “超文本标记语言”。</p>
<p>与普通文本相比，HTML除了有文字，还可以拥有图片、音乐、视频、表格等各种内容。</p>
<p>在HTML中插入内容都需要使用 “标记” 来插入，因此针对文字、图片、视频等等不同的内容拥有不同的 “标记”，专业用语称为 “标签”，也可以称为 “元素”。</p>
<h2 id="初识HTML-标签"><a href="#初识HTML-标签" class="headerlink" title="初识HTML 标签"></a>初识HTML 标签</h2><p>标签又称为“元素”，是HTML组成的基本单位。</p>
<p>例如，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span>&gt;</span> 认真学习，能够忘我 <span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这就是一句html代码，其中使用了<code>marquee</code>的标签，使得其包含的文字有一定的特性。</p>
<ul>
<li><code>&lt;marquee&gt;</code>称为这个元素的起始标签，<code>&lt;/marquee&gt;</code>称为这个元素的结束标签。</li>
<li>标签有单标签、双标签之分，像上面那种标签就属于双标签；单标签，例如<code>&lt;input&gt;</code>。</li>
<li>标签的字母不区分大小写，但推荐使用<strong>小写</strong>。</li>
</ul>
<p><strong>标签的属性</strong></p>
<p>例如，给上述示例中的标签增加一些属性，为标签提供一些附加信息</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">loop</span>=<span class="string">&quot;3&quot;</span> <span class="attr">bgcolor</span>=<span class="string">&quot;green&quot;</span>  &gt;</span> 认真学习，能够忘我 <span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上述代码中，可以看出如何给标签增加属性了，</p>
<p>其中<code>bgcolor</code>为属性名称，<code>green</code>为属性值，意为 背景颜色 &#x3D; 绿色 。</p>
<p>标签的属性写在标签的起始标签中，或者是单标签。</p>
<p><strong>至于有多少标签，每种标签有哪些属性可以使用HTML5 标准手册进行查询。</strong></p>
<blockquote>
<p>这里分享常用的在线权威——参考手册</p>
<p>[1]   [MDN在线手册]（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/HTML%EF%BC%89">https://developer.mozilla.org/zh-CN/docs/Learn/HTML）</a></p>
</blockquote>
<p><strong>注意</strong></p>
<blockquote>
<ol>
<li>不同的标签，有不同的属性；也有一些通用属性（在任何标签内都能写，后面会详细</li>
</ol>
<p>总结）。</p>
<ol start="2">
<li>属性名、属性值不能乱写，都是W3C规定好的。</li>
<li>属性名、属性值，都不区分大小写，但推荐小写。</li>
<li>双引号，也可以写成单引号，甚至不写都行，但还是推荐写双引号。</li>
<li>标签中不要出现同名属性，否则后写的会失效，例如：</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="HTML的基本组成结构"><a href="#HTML的基本组成结构" class="headerlink" title="HTML的基本组成结构"></a>HTML的基本组成结构</h2><p>下面是一串标准的HTML代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span> 网站名称 <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">            锄禾日当午</span><br><span class="line">            汗滴禾下土</span><br><span class="line">            谁知盘中餐</span><br><span class="line">            粒粒皆辛苦</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<ol>
<li>想要呈现在网页中的内容写在 body 标签中。</li>
<li>head 标签中的内容不会出现在网页中。</li>
<li>head 标签中的 title 标签可以指定网页的标题。</li>
<li><code>&lt;!DOCTYPE html&gt;</code>是HTML5的文档声明，意在告诉浏览器，我是使用HTML5的语法。文档声明必须要在文档的第一行，且在<code>&lt;html&gt;</code>标签的外面。</li>
</ol>
</blockquote>
<h2 id="网页开发的基本工具——VScode"><a href="#网页开发的基本工具——VScode" class="headerlink" title="网页开发的基本工具——VScode"></a>网页开发的基本工具——VScode</h2><p>1、安装好VScode</p>
<p>2、安装插件</p>
<ul>
<li>中文插件——让软件界面语言设置成中文。搜索“简体中文”即可安装。</li>
<li>图标插件——让VScode打开的文件夹内文件图标更优美。vscode-icons</li>
<li>html及时预览插件——LivePreview</li>
</ul>
<p><strong>LivePreview的使用与设置</strong></p>
<p>安装后，在vscode编辑html文件的窗口中，右键，会看到<code>显示预览</code>，点击即可及时看见渲染后的网页。</p>
<p>进入插件的设置页面，将LivePreview的刷新频率设置成<code>on changes to save files</code>。</p>
<p>因为插件默认的设置是：只要文件一修改，立马刷新页面显示刚刚的修改效果，这种有点耗费资源。</p>
<p>当修改成<code>on changes to save files</code>后，只有修改文件并保存之后，插件才会开始刷新页面。有利于节约电脑的性能资源。</p>
<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><ul>
<li><p><code>ctrl + Enter</code>   直接增加下一空行。（即使鼠标光标在上一行的文字中间也没事）</p>
</li>
<li><p><code>ctrl + shift + k</code>  删除鼠标光标所在的一行（即使鼠标没有选中这一行的任何内容）</p>
</li>
<li><p><code>shift + Alt + ↓  </code>向下复制光标所在行的内容。</p>
</li>
<li><p><code>tab</code>键可用于鼠标选中内容后，按下<code>tab</code>向右缩进；<code>shift + tab </code>键可以向左缩进。</p>
</li>
</ul>
<p>在html文件中，输入英文感叹号<code>!</code>，再按下回车键，即可快速在vscode中生成HTML的标准结构。</p>
<p>当然也可以输入<code>html:5</code>再按下回车，也能生成HTML标准结构。</p>
<h2 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h2><ol>
<li>特点</li>
</ol>
<p>注释的内容会被浏览器自动忽略，但源代码中依然可见。</p>
<ol start="2">
<li>作用</li>
</ol>
<p>给代码进行必要的解释说明，防止时间久了，自己忘了。下次再看代码的时候能快速掌握整个逻辑思路。</p>
<ol start="3">
<li><p>代码格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 下面的文字只能滚动3次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">loop</span>=<span class="string">&quot;3&quot;</span>&gt;</span>认真学习，可以忘我<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 注释里面的文字是可以换行的，</span></span><br><span class="line"><span class="comment">本段文字就是全部被注释了 --&gt;</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>注意——注释是不能嵌套的，下面是<strong>错误</strong>的例子。</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">我是一段注释</span></span><br><span class="line"><span class="comment">&lt;!-- 我是一段注释 --&gt;</span></span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>



<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ol>
<li>计算机操作数据<ul>
<li>存储数据的时候，要对数据进行“<strong>编码</strong>”</li>
<li>读取数据的时候，要对数据进行“<strong>解码</strong>”</li>
</ul>
</li>
<li>在进行编码、解码时要使用同一套规则，称之为<strong>字符集</strong>。</li>
<li>常见的字符集有</li>
</ol>
<blockquote>
<ol>
<li>ASCII：大小写字母、数字、一些符号，共计128个。</li>
<li>ISO 8859-1 ：在ASCII基础上，扩充了一些希腊字符，共计256个。</li>
<li>GB2312：在上述基础上继续扩充，收录了6763个常用汉字、682个字符。</li>
<li>GBK：收录了汉字和符号达到2000+，支持繁体中文。</li>
<li>UTF-8：万国码，包含世界上所有语言的文字与符号。<strong>常用！</strong></li>
</ol>
</blockquote>
<ol start="4">
<li>使用的规则</li>
</ol>
<blockquote>
<p><strong>存储</strong></p>
<p>你在保存数据的时候，你选择的字符集一定要包含支持你这些数据的文字和符号。</p>
<p>否则：<strong>无法储存，数据丢失！</strong></p>
</blockquote>
<blockquote>
<p><strong>读取</strong></p>
<p>你保存数据用什么方式，读取的时候就用什么方式。</p>
<p>否则：<strong>数据错乱，俗称“乱码”</strong>。</p>
<p>此时，你只需要重新修改对应的解码方式，仍然能看到正确的内容。</p>
</blockquote>
<ol start="5">
<li>总结<blockquote>
<ul>
<li>为保证所有的输入，都能正常存储和读取，现在几乎全都采用： UFT-8 编码。</li>
<li>为了让浏览器能渲染html文件时，能正确显示字符，可以使用<code>meta</code>标签的<code>charset</code>属性，指定浏览器使用特定的字符集。</li>
</ul>
</blockquote>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>meta</code>属于一种标签，他有两种写法</p>
<ul>
<li>自闭和写法，即在一个标签内完成起始与结束。<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></li>
<li>单标签写法。<code>&lt;meta charset=&quot;UTF-8&quot; &gt;</code></li>
</ul>
<p>在HTML5中，自闭合的使用是推荐的做法，因为它有助于保持代码的一致性和简洁性、有助于避免某些历史浏览器的解析错误。</p>
<p>虽然加不加斜杠在现代浏览器中通常不会有太大区别，但为了遵循HTML5标准和最佳实践，建议使用 <code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code></p>
<h2 id="HTML设置网站的语言"><a href="#HTML设置网站的语言" class="headerlink" title="HTML设置网站的语言"></a>HTML设置网站的语言</h2><ol>
<li>主要作用</li>
</ol>
<ul>
<li>让浏览器能显示对应的翻译提示。</li>
<li>有利于搜索引擎优化。</li>
</ul>
<ol start="2">
<li><p>代码写法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

</li>
<li><p>lang属性的编写规则<br><code>语言—国家/地区</code></p>
</li>
</ol>
<ul>
<li>zh-CN  中文-中国大陆（简体中文）</li>
<li>zh-TW 中文-台湾（繁体中文）</li>
<li>zh       中文</li>
<li>en-US  英语-美国</li>
<li>en-GB  英语-英国</li>
</ul>
<p>其他国家的语言简写，可以网络搜索&#x2F;询问AI。</p>
<hr>
<h1 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h1><h2 id="排版标签"><a href="#排版标签" class="headerlink" title="排版标签"></a>排版标签</h2><table>
<thead>
<tr>
<th align="center">标签名</th>
<th align="center">标签含义</th>
<th align="center">单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td align="center">h1~h6</td>
<td align="center">标题、大纲文本</td>
<td align="center">双</td>
</tr>
<tr>
<td align="center">p</td>
<td align="center">段落</td>
<td align="center">双</td>
</tr>
<tr>
<td align="center">div</td>
<td align="center">无含义，可以包含一系列标签，可以认为div用于标签的分组，将来可用于批量修改样式以及布局。</td>
<td align="center">双</td>
</tr>
</tbody></table>
<ol>
<li>h1最好只写一个，h2~h6可以正常使用。</li>
<li>h1~h6不能嵌套使用。例如h1中不能嵌套h2。</li>
<li>p标签里面不能嵌套h标签、p标签、div标签。</li>
</ol>
<h2 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h2><ul>
<li><p>定义：用特定的标签表示特定的含义。</p>
</li>
<li><p>原则：标签的默认效果不重要（后期可以使用CSS随意修改效果），<strong>语义最重要</strong>。</p>
</li>
</ul>
<p>举例，h1表示文章的标题，是本片网页的重点。而其带来的效果（字体变大、粗并不重要，因为后期可以使用CSS自定义修改）。</p>
<ul>
<li>为什么要强调标签的语义化<ul>
<li>代码结构清晰，可读性强</li>
<li>有利于SEO优化（有利于搜索引擎爬虫，别人很容易搜索到你的网站）</li>
<li>方便设备解析（例如屏幕阅读器、盲人阅读器）。</li>
</ul>
</li>
</ul>
<h2 id="块级元素与行内元素"><a href="#块级元素与行内元素" class="headerlink" title="块级元素与行内元素"></a>块级元素与行内元素</h2><ol>
<li>块级元素：独占一行（排版标签都是块级元素）。</li>
<li>行内元素：不独占一行（例如<code>input</code>，后期还会学习更多）。</li>
<li>使用规则</li>
</ol>
<blockquote>
<p>[1] 块级元素什么都能写。</p>
<p>[2] 行内元素可以写行内元素，但不能写块级元素。</p>
<p>[3]一些特殊规则</p>
<ul>
<li>h1~h6不能相互嵌套。</li>
<li>p中不要写块级元素。</li>
</ul>
</blockquote>
<h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ol>
<li>用于包裹：词汇、短语等。</li>
<li>通常写在排版标签内。</li>
<li>文本标签都是行内元素。</li>
<li>排版标签更宏观（常用于大段的文字），文本标签更微观（词汇、短语）。</li>
</ol>
<table>
<thead>
<tr>
<th>标签名</th>
<th>标签语义</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td>em</td>
<td>着重阅读的内容</td>
<td>双</td>
</tr>
<tr>
<td>strong</td>
<td>十分重要的内容</td>
<td>双</td>
</tr>
<tr>
<td>span</td>
<td>没有语义，用于包裹短语的通用容器。</td>
<td>双</td>
</tr>
</tbody></table>
<blockquote>
<p>div与span的区别：</p>
<p>div常用于大段文字包裹；span用于行内词语包括。</p>
</blockquote>
<hr>
<h3 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h3><blockquote>
<ol>
<li>这些不常用的文本标签，编码时不用过于纠结（酌情而定，不用也没毛病）。</li>
<li><code>blockquote</code> 与 <code>address</code> 是块级元素，其他的文本标签，都是行内元素。</li>
<li>有些语义感不强的标签，我们很少使用，例如：<br><code>small</code> 、<code> b</code> 、 <code>u</code> 、 <code>q</code> 、 <code>blockquote</code></li>
<li>HTML标签太多了！记住那些：重要的、语义感强的标签即可；截止目前，有这些：<br><code>h1~h6</code> 、<code> p</code> 、 <code>div</code> 、<code> em</code> 、 <code>strong</code> 、 <code>span</code></li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>标签名</th>
<th>标签语义</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td><code>cite</code></td>
<td>作品标题（书籍、电影、歌曲等）</td>
<td>双</td>
</tr>
<tr>
<td><code>dfn</code></td>
<td>特殊术语、专属词汇</td>
<td>双</td>
</tr>
<tr>
<td><code>del</code>与<code>ins</code></td>
<td>分别表示：删除的文本、插入的文本</td>
<td>双</td>
</tr>
<tr>
<td><code>sub</code>与<code>sup</code></td>
<td>下标文字、上标文字</td>
<td>双</td>
</tr>
<tr>
<td><code>code</code></td>
<td>一段代码</td>
<td>双</td>
</tr>
<tr>
<td><code>samp</code></td>
<td>从正常的上下文中，将某些内容提取出来，例如：标识设备输出</td>
<td>双</td>
</tr>
<tr>
<td><code>kbd</code></td>
<td>键盘文本，表示文本是通过键盘输入的，经常用在与计算机相关的手册中</td>
<td>双</td>
</tr>
<tr>
<td><code>abbr</code></td>
<td>缩写，最好配合上 title 属性</td>
<td>双</td>
</tr>
<tr>
<td><code>bdo</code></td>
<td>更改文本方向，要配合 <code>dir</code> 属性，可选值: <code>ltr</code> （默认值）、<code>rtl</code></td>
<td>双</td>
</tr>
<tr>
<td><code>var</code></td>
<td>标记变量，可以与 <code>code</code> 标签一起使用</td>
<td>双</td>
</tr>
<tr>
<td><code>small</code></td>
<td>附属细则，例如：包括版权、法律文本。—— 很少使用</td>
<td>双</td>
</tr>
<tr>
<td><code>b</code></td>
<td>摘要中的关键字、评论中的产品名称。—— 很少使用</td>
<td>双</td>
</tr>
<tr>
<td><code>i</code></td>
<td>本意是：人物的思想活动、所说的话等等。现在多用于：呈现字体图标（后面要讲的内容）。</td>
<td>双</td>
</tr>
<tr>
<td><code>u</code></td>
<td>与正常内容有反差文本，例如：错的单词、不合适的描述等。——很少使用</td>
<td>双</td>
</tr>
<tr>
<td><code>q</code></td>
<td>短引用 —— 很少使用</td>
<td>双</td>
</tr>
<tr>
<td><code>blockquote</code></td>
<td>长引用 —— 很少使用</td>
<td>双</td>
</tr>
<tr>
<td><code>address</code></td>
<td>地址信息</td>
<td>双</td>
</tr>
</tbody></table>
<hr>
<h2 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1. 基本使用"></a>1. 基本使用</h3><p>代码格式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">src</span>=<span class="string">&quot;xxx.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;这里是描述图片内容&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p><code>width</code>：图片的宽度，单位是像素<code>px</code>，例如：<code>200px</code>或<code>200</code></p>
<p><code>heght</code>：图片高度。</p>
<p><code>src</code>：图片路径（也称：图片的地址）</p>
<p><code>alt</code>：图片描述</p>
<p><strong>注意事项</strong></p>
<blockquote>
<p>1、<code>width</code>和<code>height</code>是可选属性，如果不添加该属性，则默认显示图片的原始大小。</p>
<p>如果只修改图片的宽或者是只修改高，则默认是按比例放大或缩小。</p>
<p>尽量不同时修改图片的宽和高，可能会造成比例失调。</p>
<p>2、<code>img</code>是行内元素。</p>
<p>3、<code>alt</code>属性的作用</p>
<ul>
<li>搜索引擎通过<code>alt</code>属性的值，可以知道图片的内容。——最主要的作用</li>
<li>当图片无法展示的时候，浏览器就会展示<code>alt</code>的值。</li>
<li>盲人阅读器会朗读<code>alt</code>属性的值。</li>
</ul>
</blockquote>
<h3 id="2-路径的分类"><a href="#2-路径的分类" class="headerlink" title="2. 路径的分类"></a>2. 路径的分类</h3><ul>
<li>相对路径</li>
</ul>
<p><code>以当前路径为参考点，去建立图片的路径</code></p>
<p>①引用与<code>html文件</code>在同一文件夹下的<code>图片</code>：怪兽.jpg</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;怪兽.jpg&quot;</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上述代码还可以写成下面这样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./怪兽.jpg&quot;</span> &gt;</span></span><br></pre></td></tr></table></figure>

<p>②引用<code>html文件</code>所在文件夹的子文件夹<code>picture</code>中的<code>图片</code>：怪兽.jpg</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./picture/怪兽.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>③引用<code>html文件</code>所在文件夹的上一个文件夹中的子文件夹<code>picture</code>里面的<code>图片</code>：怪兽.jpg</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../picture/怪兽.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p><strong>总结</strong></p>
<p><code>./</code>  同一个文件夹。（这个也可以不写，例如第一个例子。）</p>
<p><code>/</code>下一个文件夹</p>
<p><code>../</code> 上一个文件夹，可以使用多次表示连续返回上一层级。</p>
<ul>
<li><p>绝对路径</p>
<ul>
<li><p>本地绝对路径（很少使用）</p>
<p><code> E:/a/b/c/奥特曼.jpg</code></p>
</li>
<li><p>网络绝对路径</p>
</li>
</ul>
</li>
</ul>
<p><code>http://www.atguigu.com/images/index_new/logo.png</code></p>
<h3 id="3-常见图片的格式"><a href="#3-常见图片的格式" class="headerlink" title="3. 常见图片的格式"></a>3. 常见图片的格式</h3><table>
<thead>
<tr>
<th>图片格式</th>
<th>扩展名</th>
<th>概述</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>jpg</td>
<td>扩展名为 <code>.jpg</code> 或 <code>.jpeg</code></td>
<td>是一种有损的压缩格式（把肉眼不容易观察出来的细节丢弃了）</td>
<td><strong>支持的颜色丰富、占用空间较小</strong></td>
<td>不支持透明背景、不支持动态图</td>
<td>对图片细节<strong>没有极高要求</strong>的场景，例如：网站的产品宣传图等 。—— 该格式网页中很常见。</td>
</tr>
<tr>
<td>png</td>
<td><code> .png</code></td>
<td>无损的压缩格式，能够更高质量的保存图片</td>
<td><strong>支持的颜色丰富</strong>、<strong>支持透明背景</strong></td>
<td>占用空间略大、不支持动态图</td>
<td>①想让图片有透明背景；②想更高质量的呈现图片；例如 ：公司logo图、重要配图等。</td>
</tr>
<tr>
<td>bmp</td>
<td><code>.bmp</code></td>
<td>不进行压缩的一种格式，在最大程度上保留图片更多的细节</td>
<td><strong>支持的颜色丰富、保留的细节更多</strong></td>
<td>占用空间极大、不支持透明背景、不支持动态图</td>
<td>对图片细节<strong>要求极高</strong>的场景，例如：一些大型游戏中的图片 。（网页中很少使用）</td>
</tr>
<tr>
<td>gif</td>
<td><code>.gif</code></td>
<td>仅支持256种颜色，色彩呈现不是很完整</td>
<td><strong>支持<strong><strong>简单</strong></strong>透明背景、支持动态图</strong></td>
<td>支持的颜色较少</td>
<td>网页中的动态图片</td>
</tr>
<tr>
<td>webp</td>
<td><code>.webp </code></td>
<td>谷歌推出的一种格式，专门用来在网页中呈现图片.</td>
<td>具备上述几种格式的优点</td>
<td>但兼容性不太好，一旦使用务必要解决兼容性问题。</td>
<td>网页中的各种图片。<code>【未来网页中图片的主流趋势】</code></td>
</tr>
<tr>
<td>base64</td>
<td>一串特殊的文本</td>
<td>使用一些工具或者在线网站，把图片进行 <code>base64</code> 编码，形成一串文本。</td>
<td>把base64直接作为 img 标签的 src 属性的值即可。</td>
<td>不受文件位置的影响，可以与网站同时显示，没有请求与接受的延迟。</td>
<td>一些较小的图片，或者需要和网页一起加载的图片。</td>
</tr>
</tbody></table>
<p><strong>图片的格式非常多，上面这些，只是一些常见的、我们前端人员常接触到的。</strong></p>
<hr>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p>主要作用：从当前页面进行跳转，可以实现：</p>
<ul>
<li>跳转到指定页面</li>
<li>跳转到指定文件（也可以触发下载）</li>
<li>跳转到页面锚点位置</li>
<li>唤起指定应用</li>
</ul>
<table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
<th>常用属性</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>超链接</td>
<td><code>href</code>：要跳转的目标<br /><code>target</code>：控制跳转时如何打开页面，常用值如下：<br />        _self ：本窗口打开<br />       _blank：新窗口打开<br /><code>id</code>：元素的唯一标识，可用于设置锚点。<br /></td>
<td>双</td>
</tr>
</tbody></table>
<h3 id="1、跳转到指定页面"><a href="#1、跳转到指定页面" class="headerlink" title="1、跳转到指定页面"></a>1、跳转到指定页面</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转到其他网页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.baidu.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> &gt;</span>百度官网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳转到本地网页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./测试.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> &gt;</span>去看测试网页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>1、代码中的<strong>多个空格、多个回车</strong>，都会被浏览器解析成一个空格。</p>
<p>2、虽然<code>a</code>是行内元素，但是<code>a</code>元素可以包含除它自身外的任何元素！</p>
</blockquote>
<h3 id="2、跳转到文件"><a href="#2、跳转到文件" class="headerlink" title="2、跳转到文件"></a>2、跳转到文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 浏览器能直接打开的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/自拍.jpg&quot;</span>&gt;</span>看自拍<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/小电影.mp4&quot;</span>&gt;</span>看小电影<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/小姐姐.gif&quot;</span>&gt;</span>看小姐姐<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/如何一夜暴富.pdf&quot;</span>&gt;</span>点我一夜暴富<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 浏览器不能打开的文件，会自动触发下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/内部资源.zip&quot;</span>&gt;</span>内部资源<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 强制触发下载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;./resource/小电影.mp4&quot;</span> <span class="attr">download</span>=<span class="string">&quot;电影片段.mp4&quot;</span>&gt;</span>下载电影<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意1：若浏览器无法打开文件，则会引导用户下载。</p>
<p>注意2：若想强制触发下载，请使用 download 属性，属性值即为下载文件的名称。</p>
</blockquote>
<h3 id="3、跳转到页面的锚定位置"><a href="#3、跳转到页面的锚定位置" class="headerlink" title="3、跳转到页面的锚定位置"></a>3、跳转到页面的锚定位置</h3><p>什么是锚点？—— 网页中的一个标记点。</p>
<p>具体的使用方式</p>
<ul>
<li>第一步：设置锚点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种方式：a标签配合name属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;test1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二种方式：其他标签配合id属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">&quot;test2&quot;</span>&gt;</span>我是一个位置<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>具有 href 属性的 a 标签是<strong>超链接</strong>，具有 name 属性的 a 标签是<strong>锚点</strong>。</li>
<li>name 和 id 都是区分大小写的，且 id 最好别是数字开头。</li>
</ol>
<p>推荐使用<code>id</code>进行锚定。</p>
</blockquote>
<ul>
<li>第二步：跳转锚点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转到test1锚点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#test1&quot;</span>&gt;</span>去test1锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳到本页面顶部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 跳转到其他页面锚点 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;demo.html#test1&quot;</span>&gt;</span>去demo.html页面的test1锚点<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 刷新本页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>刷新本页面<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 执行一段js,如果还不知道执行什么，可以留空，javascript:; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1);&quot;</span>&gt;</span>点我弹窗<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="4、打开指定应用"><a href="#4、打开指定应用" class="headerlink" title="4、打开指定应用"></a>4、打开指定应用</h3><p>通过<code>a</code>标签可以唤起设备上的应用程序。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 唤起设备拨号 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;tel:10010&quot;</span>&gt;</span>电话联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 唤起设备发送邮件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:10010@qq.com&quot;</span>&gt;</span>邮件联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 唤起设备发送短信 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;sms:10086&quot;</span>&gt;</span>短信联系<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表-ol"><a href="#有序列表-ol" class="headerlink" title="有序列表 ol"></a>有序列表 <code>ol</code></h3><p>有序列表 “ordered list” ，因此在html中使用<code>ol</code>来定义有序列表。</p>
<p>有序列表：有顺序或者侧重顺序的列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>要把大象放冰箱总共分几步<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>把冰箱门打开<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>把大象放进去<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>把冰箱门关上<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="无序列表-ul"><a href="#无序列表-ul" class="headerlink" title="无序列表 ul"></a>无序列表 <code>ul</code></h3><p>无序列表 “unordered list”，因此在html中使用<code>ul</code>来定义无序列表。</p>
<p>无序列表：无顺序或者不侧重顺序的列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我想去的几个城市<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>成都<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>上海<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>西安<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>武汉<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>注意</p>
<p>无论是有序列表还是无序列表，每一个项目都要使用<code>li</code>标签来进行标记。</p>
<p><code>li</code>标签最好是写在<code>ol</code>、<code>ul</code>中，不要单独使用。</p>
</blockquote>
<h3 id="自定义列表-dl"><a href="#自定义列表-dl" class="headerlink" title="自定义列表 dl"></a>自定义列表 <code>dl</code></h3><p>所谓自定义列表，就是一个包含<strong>术语名称</strong>以及<strong>术语描述</strong>的列表。</p>
<p>一个<code> dl</code> 就是一个自定义列表，一个 <code>dt</code> 就是一个术语名称，一个 <code>dd</code> 就是术语描述（可以有多个）。</p>
<p>自定义列表 “denifition list”    <code>dl</code></p>
<p>术语名称    “denifition title”   <code>dt</code></p>
<p>属于描述    “denifition description”    <code>dd</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;h2&gt;如何高效的学习？&lt;/h2&gt;</span><br><span class="line">&lt;dl&gt;</span><br><span class="line">&lt;dt&gt;做好笔记&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;笔记是我们以后复习的一个抓手&lt;/dd&gt;</span><br><span class="line">&lt;dd&gt;笔记可以是电子版，也可以是纸质版&lt;/dd&gt;</span><br><span class="line">&lt;dt&gt;多加练习&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;只有敲出来的代码，才是自己的&lt;/dd&gt;</span><br><span class="line">&lt;dt&gt;别怕出错&lt;/dt&gt;</span><br><span class="line">&lt;dd&gt;错很正常，改正后并记住，就是经验&lt;/dd&gt;</span><br><span class="line">&lt;/dl&gt;</span><br></pre></td></tr></table></figure>



<h3 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h3><p>列表中的某一项内容，又包含了一个列表。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我喜欢吃的食物<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>粉条<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>水果<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>菠萝<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>芒果<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>汤类<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>西红柿蛋汤<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>紫菜蛋花汤<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶树菇排骨汤<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>炒菜<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>







<hr>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol>
<li>基本结构</li>
</ol>
<p>一个完整的表格由：<strong>表格标题</strong>、<strong>表格头部</strong>、<strong>表格主体</strong>、<strong>表格脚注</strong>，四部分组成。</p>
<img src=" https://imgsrc.baidu.com/forum/pic/item/8cb1cb1349540923be77ae5cd458d109b3de49f2.jpg "  style="zoom:50%;" />



<ol start="2">
<li>表格涉及到的标签</li>
</ol>
<p><code>table</code>：表格</p>
<p><code>caption</code>：表格标题</p>
<p><code>thead</code>：表格头部</p>
<p><code>tbody</code>：表格主体</p>
<p><code>tfoot</code>：表格脚注</p>
<p><code>tr</code>：每一行。     t代表table，r代表row（行）。</p>
<p><code>th</code>：表格头部中的每一个单元格。 t代表table，h代表head。</p>
<p><code>td</code>：表格主体、脚注中的单元格。t代表table，d代表data。</p>
<ol start="3">
<li>示例代码</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里是一个表格 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 表格头部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span>  <span class="comment">&lt;!-- tr表示每一行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- th表示表格头部的每一个单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>民族<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>政治面貌<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 表格主体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span>  <span class="comment">&lt;!-- td代表表格主体和脚注的每一个单元格 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>18<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>汉族<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>团员<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>满族<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>群众<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>19<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>回族<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>党员<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>赵六<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>女<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>21<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>壮族<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>团员<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 表格脚注 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>共计：4人<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h2 id="表格常用属性"><a href="#表格常用属性" class="headerlink" title="表格常用属性"></a>表格常用属性</h2><p>后期主要使用<code>CSS</code>调节表格的属性，这里只是了解即可，不强制要求记忆，反正后期也能查笔记，不用记没事。</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
<th>常用属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>table</code></td>
<td>表格</td>
<td><code>width</code>：设置表格宽度。<br /><code>height</code>：设置表格的最小高度，表格最终高度可能会更大。<br /><code>border</code>：设置表格外边框的宽度。<br /><code>cellspacing</code>：设置单元格之间的距离。<br /></td>
</tr>
<tr>
<td><code>thead</code></td>
<td>表格头部</td>
<td><code>height</code><br /><code>align</code>：设置单元格的水平对齐方式，可选值：<code>left</code>、<code>center</code>、<code>right</code><br /><code>valign</code>：设置单元格的垂直对齐方式，可选值：<code>top</code>、<code>middle</code>、<code>bottom</code><br /></td>
</tr>
<tr>
<td><code>tbody</code></td>
<td>表格主体</td>
<td>常用属性与<code>thead</code>相同</td>
</tr>
<tr>
<td><code>tr</code></td>
<td>行</td>
<td>常用属性与<code>thead</code>相同</td>
</tr>
<tr>
<td><code>tfoot</code></td>
<td>表格脚注</td>
<td>常用属性与<code>thead</code>相同</td>
</tr>
<tr>
<td><code>td</code></td>
<td>普通单元格</td>
<td><code>width</code>：设置单元格的宽度，同列所有单元格都受其影响。<br /><code>height</code>：设置单元格的高度，同行所有单元格全都受到影响。<br /><code>align</code>：设置单元格水平对齐方式。<br /><code>valign</code>：设置单元格垂直对齐方式。<br /><code>rowspan</code>：指定要跨的行数。<br /><code>colspan</code>：指定要跨的列数。<br /></td>
</tr>
<tr>
<td><code>th</code></td>
<td>表格头部的单元格</td>
<td>常用属性与<code>td</code>相同。</td>
</tr>
</tbody></table>
<p><strong>注意</strong></p>
<blockquote>
<p>1、<code>&lt;table&gt;</code>元素的<code>border</code>属性可以控制表格的最外侧边框，但<code>border</code>不能修改单元格的边框宽度。后期靠<code>CSS</code>可以修改每一个单元格的宽度。</p>
<p>2、默认情况下，每列的宽度，得看这一列单元格最长的那个文字。</p>
<p>3、给某个<code>th</code>或者<code>td</code>设置了宽度之后，他们所在的那一列宽度就确定了。</p>
<p>4、给出某个<code>th</code>或者<code>td</code>设置了高度之后，他们所在的那一行的高度就确定了。</p>
</blockquote>
<hr>
<h2 id="表格的跨行与跨列"><a href="#表格的跨行与跨列" class="headerlink" title="表格的跨行与跨列"></a>表格的跨行与跨列</h2><p>跨行与跨列针对的是表格中<strong>单元格</strong>的属性。</p>
<p>让我们再一起复习一遍表格的组成：</p>
<p>表格<code>table</code>由四大部分组成：标题<code>caption</code>、表格头部<code>thead</code>、表格主体<code>tbody</code>、表格脚注<code>tfoot</code>。</p>
<p>表格中的每一行<code>tr</code></p>
<p>表格中的单元格有两类：标题中的格子<code>th</code>、主体和脚注中的格子<code>td</code>。</p>
<p>表格的列数就是由这一行<code>tr</code>中存在多少个单元格（<code>th</code>或<code>td</code>）决定的。</p>
<p>因此<strong>表格的跨行与跨列</strong>操作的就是<code>th</code>或<code>td</code>的属性。</p>
<p><code>rowspan</code>：指定要跨的行数。			row意为“行”，span有跨度的含义。</p>
<p><code>colspan</code>：指定要跨的列数。			column意为”列”，这里取“col”做前缀，span意思同上。</p>
<img src=" https://dlink.host/wx3.sinaimg.cn/large/007ERWx2ly8htxqdc2rzgj30m40dpjsx.jpg "  style="zoom:50%;" />

<p>编写一个如图所示的课程表，代码如下</p>
<p>代码示例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>表格的跨行与跨列<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>课程表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;5&quot;</span>&gt;</span>上课<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>活动与休息<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期一<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期二<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期五<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期六<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>星期日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>上午<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>3-7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;4&quot;</span>&gt;</span>休息<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>4-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>5-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>6-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;8&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>午 休<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>下午<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>7-7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">&quot;2&quot;</span>&gt;</span>休息<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-3<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-4<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">td</span>&gt;</span>8-6<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="常用标签补充"><a href="#常用标签补充" class="headerlink" title="常用标签补充"></a>常用标签补充</h2><table>
<thead>
<tr>
<th>标签名</th>
<th>含义</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td><code>br</code></td>
<td>换行</td>
<td>单</td>
</tr>
<tr>
<td><code>hr</code></td>
<td>分割线</td>
<td>单</td>
</tr>
<tr>
<td><code>per</code></td>
<td>按原文输出（在源码中所见即所得，不会自动修改文字间的缩进）</td>
<td>双</td>
</tr>
</tbody></table>
<blockquote>
<p>注意</p>
<p>1、不要使用<code>br</code>标签来增大段落之间的空行，应当使用<code>p</code>标签，或者使用<code>CSS</code>来修改段间距<code>margin</code>。</p>
<p>2、<code>&lt;hr&gt;</code>的属性是分割文本，如果只是想画一条水平线，可以使用<code>CSS</code>完成。</p>
</blockquote>
<hr>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
<th>常用属性</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td><code>form</code></td>
<td>表单</td>
<td><code>action</code>：用于指定表单的提交地址。<br /><code>target</code>：用于控制表单提交后，如何打开页面。<code>_self</code>：本窗口打开。<code>_blank</code>：新窗口打开。<br /><code>method</code>：用于控制表单的提交方式，常用的方式有两种，<code>post</code>或<code>get</code>。<br /></td>
<td>双</td>
</tr>
<tr>
<td><code>input</code></td>
<td>输入框</td>
<td><code>type</code>：设置输入框的类型，常用的值是<code>text</code>，表示普通文本。<br /><code>name</code>：用于指定提交数据的名字。<br /></td>
<td>单</td>
</tr>
<tr>
<td><code>botton</code></td>
<td>按钮</td>
<td>表单中的按钮，<code>type</code>的默认值是提交表单<code>submit</code>。当然也有其他的属性，后面会学。</td>
<td>双</td>
</tr>
</tbody></table>
<p>例子如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;https://www.baidu.com/s&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;wd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>去百度搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，跳转的网址是百度规定的，method也是百度规定的，name的值还是百度规定的，因为咱们用的是它的服务器，向它发送请求，想得到他的数据，只能按照他规定来。</p>
<h3 id="常用的表单控件"><a href="#常用的表单控件" class="headerlink" title="常用的表单控件"></a>常用的表单控件</h3><h4 id="①文本输入框"><a href="#①文本输入框" class="headerlink" title="①文本输入框"></a>①文本输入框</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性如下：</p>
<p><code>name</code>属性：用于提交表单时，表示数据的名称。</p>
<p><code>value</code>属性：输入框的默认显示值。</p>
<p><code>maxlength</code>属性：用于规定输入框最大可输入长度。</p>
</blockquote>
<h4 id="②密码输入框"><a href="#②密码输入框" class="headerlink" title="②密码输入框"></a>②密码输入框</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>与本文输入框在外观上最明显的区别是用户输入的值不是明文显示，而是用一个小黑点代替。</p>
<p>常用属性如下：</p>
<p><code>name</code>属性：数据的名称。</p>
<p><code>maxlength</code>属性：输入框的最大可输入长度。</p>
</blockquote>
<h4 id="③单选框"><a href="#③单选框" class="headerlink" title="③单选框"></a><strong>③单选框</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性如下：</p>
<p><code>name</code>属性：数据的名称，如果想做到单选的效果，必须把一组选项（多个<code>radio</code>）的<code>name</code>属性值保持一致，这样子浏览器才能之别他们是同一组单选框。</p>
<p><code>value</code>属性：提交的数据值。</p>
<p><code>checked</code>属性：让该单选按钮默认被选中。</p>
</blockquote>
<h4 id="④复选框"><a href="#④复选框" class="headerlink" title="④复选框"></a><strong>④复选框</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;math&quot;</span>&gt;</span>数学</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chemistry&quot;</span>&gt;</span>化学</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;biology&quot;</span>&gt;</span>生物</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;physics&quot;</span>&gt;</span>物理</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性如下：</p>
<p><code>name</code>属性：数据的名称。</p>
<p><code>value</code>属性：提交的数据值。</p>
<p><code>checked</code>属性：让该复选框默认被选中。</p>
</blockquote>
<h4 id="⑤隐藏域"><a href="#⑤隐藏域" class="headerlink" title="⑤隐藏域**"></a><strong>⑤隐藏域</strong>**</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;tag&quot;</span> <span class="attr">value</span>=<span class="string">&quot;666&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>用户不可见的一个输入区域，作用是： 提交表单的时候，携带一些固定的数据。</p>
<p><code>name </code>属性：指定数据的名称。</p>
<p><code>value</code> 属性：指定的是真正提交的数据。</p>
</blockquote>
<h4 id="⑥提交按钮"><a href="#⑥提交按钮" class="headerlink" title="⑥提交按钮**"></a><strong>⑥提交按钮</strong>**</h4><p>这里有两种写法：一种是<code>input1</code>标签， 另一种是使用<code>button</code>标签。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二种写法与下面这种写法是一样的，因为在表单<code>form</code>中，<code>button</code>默认属性就是提交<code>submit</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">botton</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">botton</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br><code>button</code>标签在表单中，其<code>type</code>属性默认就是<code>submit</code>。<br><code>button</code>不要指定<code>name</code>属性。<br><code>input</code>标签编写的按钮，使用<code>value</code>属性指定按钮文字。</p>
</blockquote>
<h4 id="⑦重置按钮"><a href="#⑦重置按钮" class="headerlink" title="⑦重置按钮"></a><strong>⑦重置按钮</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我重置&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面给出另一种写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span>点我重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<br><code>button</code>不要指定<code>name</code>属性。<br><code>input</code>标签编写的按钮，使用<code>value</code>属性指定按钮文字。</p>
</blockquote>
<h4 id="⑧普通按钮"><a href="#⑧普通按钮" class="headerlink" title="⑧普通按钮"></a><strong>⑧普通按钮</strong></h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;botton&quot;</span> <span class="attr">value</span>=<span class="string">&quot;普通按钮&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;botton&quot;</span>&gt;</span>普通按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>想在表单中插入普通按钮，其<code>type</code>属性值必须为<code>button</code>，若不写<code>type</code>属性，其默认值就是<code>submit</code>，那么这个按钮就会成为提交按钮，而不是普通按钮了。</p>
</blockquote>
<h4 id="⑨文本域"><a href="#⑨文本域" class="headerlink" title="⑨文本域"></a>⑨文本域</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;22&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;3&quot;</span>&gt;</span>我是文本域<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性如下：</p>
<p>1、<code>rows</code>属性：指定文本域默认显示的行数，会影响文本域的高度。</p>
<p>2、<code>cols</code>属性：指定默认显示的列数，会影响文本域的宽度。</p>
<p>3、不能编写<code>type</code>属性，其他的属性与普通文本输入框一致。</p>
</blockquote>
<h4 id="⑩下拉框"><a href="#⑩下拉框" class="headerlink" title="⑩下拉框"></a>⑩下拉框</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;homeland&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;黑&quot;</span>&gt;</span>黑龙江<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;赣&quot;</span> <span class="attr">selected</span>&gt;</span>江西<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;粤&quot;</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;皖&quot;</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用属性及注意事项：</p>
<p>1、<code>name</code>属性：指定数据的名称。</p>
<p>2、<code>option</code>标签如果设置了<code>value</code>属性，则提交表单时上传的就是<code>value</code>的值；如果没有<code>value</code>属性，则提交时默认上传的就是<code>option</code>中间的文字。</p>
<p>（建议设置<code>value</code>属性，因为<code>option</code>中间的文字是展示给用户看的，有时候会比较长，我们手动设置<code>value</code>属性，这样子最后提交时可以只提交简短的自定义<code>value</code>值，有利于传输速度。）</p>
<p>3、<code>option</code>标签中设置了<code>selected</code>属性，则表示默认选中该选项。</p>
</blockquote>
<h4 id="禁用表单控件"><a href="#禁用表单控件" class="headerlink" title="禁用表单控件"></a>禁用表单控件</h4><p>给表单的标签设置<code>disable</code>，即可禁用改表单控件。在用户视角，此控件呈灰色不可操作状态。</p>
<blockquote>
<p><code>input</code>、<code>textarea</code>、<code>button</code>、<code>selcet</code>、<code>option</code>都可以设置<code>disable</code>属性。</p>
</blockquote>
<h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p><code>label</code>标签可以使 “文本” 与另一个控件关联起来，例如使 “文字”与一个输入框关联起来，点击该文字后，激活关联控件的输入框（激活也称为获取焦点）。</p>
<p>两种与<code>label</code>关联的方式：</p>
<ul>
<li>近距离</li>
</ul>
<p>把需要被关联的表单控件嵌套在<code>label</code>标签的里面。</p>
<ul>
<li>远距离</li>
</ul>
<p>让<code>label</code>标签的<code>for</code>属性的值等于与之关联的表单控件的<code>id</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 分组框线标签-fieldset与legend（了解）</span><br><span class="line"></span><br><span class="line">`fieldset`标签为表单控件分组。</span><br><span class="line"></span><br><span class="line">`legend`标签在`fieldset`标签内部，是分组的标题。</span><br><span class="line"></span><br><span class="line">```html</span><br><span class="line">        <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legend</span>&gt;</span>账户登录<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 下面是第一种文字与控件关联的方法 嵌套 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>账户：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span> &gt;</span> <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--  下面是第二种文字与控件关联的方法 id  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;mima&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;mima&quot;</span> <span class="attr">name</span>=<span class="string">&quot;psw&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">legend</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">legend</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 单选框，使用radio；用同一个name保证只能选一个 --&gt;</span></span><br><span class="line">            性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男 </span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女</span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 复选框/多选框 --&gt;</span></span><br><span class="line">            任科：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;math&quot;</span>&gt;</span>数学</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;chemistry&quot;</span>&gt;</span>化学</span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;subject&quot;</span> <span class="attr">value</span>=<span class="string">&quot;biology&quot;</span>&gt;</span>生物</span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            爱好：<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;22&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            籍贯：</span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;homeland&quot;</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;粤&quot;</span>&gt;</span>广东<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;赣&quot;</span>&gt;</span>江西<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;皖&quot;</span>&gt;</span>安徽<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;辽&quot;</span>&gt;</span>辽宁<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>



<hr>
<h3 id="表单总结"><a href="#表单总结" class="headerlink" title="表单总结"></a>表单总结</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
<th>常用属性</th>
</tr>
</thead>
<tbody><tr>
<td><code>form</code></td>
<td>表单</td>
<td><code>action</code>属性：表单数据要提交的目标地址。<br /><code>target</code>属性：跳转到新地址时，打开窗口的方式，值：<code>_self</code>、<code>_blank</code><br /><code>method</code>属性：请求的方式，值：<code>get</code>、<code>post</code><br /></td>
</tr>
<tr>
<td><code>input</code></td>
<td>多种形式的表单控件</td>
<td><code>type</code>属性：指定表单控件的类型。<br />值：<code>text</code>、<code>password</code>、<code>radio</code>、<code>checkbox</code>、<code>hidden</code>、<code>submit</code>、<code>reset</code>、<code>button</code>等。<br /><code>name</code>属性：为这个数据起一个名称。<br /><code>value</code>属性：<br />对于输入框：可以指定输入框默认存在的值。<br />对于单选框和复选框：是对应选项实际提交的值。<br />对于按钮：是按钮上显示的文字。<br /><code>disable</code>属性：设置表单控件不可用。<br /><code>maxlength</code>属性：用于输入框，设置最大可输入长度。<br /><code>checked</code>属性：用于单选框和复选框，在哪个选项中加入checked的属性，表示默认选中。<br /></td>
</tr>
<tr>
<td><code>textarea</code></td>
<td>文本域</td>
<td><code>name</code>属性：指定数据的名称。<br /><code>rows</code>属性：设置默认显示的行数，影响文本域的高度。<br /><code>cols</code>属性：设置默认显示的列数，影响文本域的宽度。<br /><code>disable</code>属性：设置表单属性不可用。<br /></td>
</tr>
<tr>
<td><code>select</code></td>
<td>下拉框</td>
<td><code>name</code>属性：指定数据的名称。<br /><code>disable</code>属性：设置整个下拉框不可用。<br /></td>
</tr>
<tr>
<td><code>option</code></td>
<td>下拉框的选项</td>
<td><code>disable</code>属性：设置该下拉选项不可用。<br /><code>value</code>属性：该选项对应的实际提交的数据（若不设置value，则默认提交选项中的内容）<br /><code>selected</code>属性：默认选中。<br /></td>
</tr>
<tr>
<td><code>button</code></td>
<td>按钮</td>
<td><code>disable</code>属性：设置按钮不可用。<br /><code>type</code>属性：设置按钮的类型，值：submit（默认）、reset、button<br /></td>
</tr>
<tr>
<td><code>label</code></td>
<td>控件关联</td>
<td><code>for</code>属性：值&#x3D;与要关联的表单控件的id值相同。</td>
</tr>
<tr>
<td><code>fieldset</code></td>
<td>控件分组</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="HTML实体"><a href="#HTML实体" class="headerlink" title="HTML实体"></a>HTML实体</h2><p>在<code>HTML</code> 中我们可以用一种<strong>特殊的形式</strong>的内容，来表示某个<strong>符号</strong>，这种特殊形式的内容，就是<code> HTML 实体</code>。比如小于号<code> &lt;</code> 用于定义 HTML 标签的开始。如果我们希望浏览器正确地显示这些字符，我们必须在 HTML 源码中插入字符实体。</p>
<blockquote>
<p>字符实体语法有两种：</p>
<ul>
<li>由连字号（<code>&amp;</code>）与<code>实体名称</code>构成，最后再加上分号（<code>;</code>）结尾。      </li>
<li>由井号（<code>#</code>）与<code>实体编号</code>构成，最后加上分号（<code>;</code>）结尾。</li>
</ul>
<p>推荐第一种写法。</p>
</blockquote>
<p><strong><code>实体</code>的常见用途</strong></p>
<p>1、用于显示保留字符（这些字符会被解析为 HTML 代码）和不可见的字符（如“不换行空格”）。</p>
<p>2、用 HTML 字符实体来代替其他难以用标准键盘键入的字符。</p>
<p><a href="https://html.spec.whatwg.org/multipage/named-characters.html#named-character-references">所有的字符实体在线参考</a></p>
<p>常见实体</p>
<table>
<thead>
<tr>
<th></th>
<th>描述</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td>空格</td>
<td><code>&amp;bnsp;</code></td>
<td><code>&amp;#160;</code></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td><code>&amp;lt;</code></td>
<td><code>&amp;#60;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td><code>&amp;gt;</code></td>
<td><code>&amp;#62;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td>连接符</td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
</tr>
<tr>
<td>“</td>
<td>引号</td>
<td><code>&amp;quot;</code></td>
<td><code>&amp;#34;</code></td>
</tr>
<tr>
<td>&#96;</td>
<td>反引号</td>
<td><code>&amp;acute;</code></td>
<td><code>&amp;#180;</code></td>
</tr>
<tr>
<td>￠</td>
<td>分（cent）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>£</td>
<td>镑（pound）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>¥</strong></td>
<td>元（yen）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>€</td>
<td>欧元（euro）</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>©</strong></td>
<td>版权（copyright）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td></td>
<td></td>
</tr>
<tr>
<td>™</td>
<td>商标</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>×</strong></td>
<td>乘号</td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>÷</strong></td>
<td>除号</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="HTML全局属性"><a href="#HTML全局属性" class="headerlink" title="HTML全局属性"></a>HTML全局属性</h2><p><strong>全局属性</strong>是所有 HTML 元素共有的属性，它们可以用于所有元素。</p>
<p>下面列举一些常见的全局属性</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>给标签指定唯一标识，注意： <code>id</code> 是不能重复的。   作用：可以让&#96;&#96; label<code> 标签与表单控件相关联；也可以与</code> CSS<code> 、</code> JavaScript &#96;配合使用。</td>
</tr>
<tr>
<td><code>class</code></td>
<td>给标签指定类名，随后就可以通过<code>CSS</code>可以给同一类的标签批量修改样式。</td>
</tr>
<tr>
<td><code>style</code></td>
<td>给标签设置<code>CSS</code>样式。</td>
</tr>
<tr>
<td><code>dir</code></td>
<td>内容在网页上输出的方向。值：<code>ltr</code>、<code>rtl</code></td>
</tr>
<tr>
<td><code>title</code></td>
<td>给标签设置一个文字提示，鼠标移动到该文字上，就会自动展现小字提示。一般超链接和图片用的比较多。</td>
</tr>
<tr>
<td><code>lang</code></td>
<td>给标签指定语言。（用的较少）</td>
</tr>
</tbody></table>
<hr>
<h2 id="meta信息"><a href="#meta信息" class="headerlink" title="meta信息"></a>meta信息</h2><ol>
<li>配制字符编码</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="2">
<li>针对<code>IE</code>浏览器的兼容性配置。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li>针对移动端的配置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=divice-width&quot;</span>, <span class="attr">initial-scale</span>=<span class="string">1.0</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>配置网页关键字</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网络购物,商城,电商&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>关键字一般设置8~12个，用英文逗号<code>，</code>隔开。</p>
<ol start="5">
<li>配置网页描述性息</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;80字以内的一段话，与网站内容有关&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="6">
<li>针对搜索引擎爬虫配置</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;robots&quot;</span> <span class="attr">content</span>=<span class="string">&quot;此处可选值见下表&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>index</code></td>
<td>允许搜索引擎爬虫索引此页面。</td>
</tr>
<tr>
<td><code>noindex</code></td>
<td>不允许搜索引擎爬虫索引此页面。</td>
</tr>
<tr>
<td><code>follow</code></td>
<td>允许搜索爬虫跟随此页面上的链接。</td>
</tr>
<tr>
<td><code>nofllow</code></td>
<td>要求搜索爬虫不跟随此页面上的链接。</td>
</tr>
<tr>
<td><code>all</code></td>
<td>等于同时允许<code>fllow</code>+<code>index</code></td>
</tr>
<tr>
<td><code>none</code></td>
<td>等于同时拒绝<code>fllow</code>+<code>index</code></td>
</tr>
<tr>
<td><code>noarchive</code></td>
<td>要求搜索引擎不缓存页面内容。</td>
</tr>
<tr>
<td><code>nocache</code></td>
<td>&#x3D;<code>noarchive</code>，即要求搜索引擎不缓存页面内容。</td>
</tr>
</tbody></table>
<ol start="7">
<li>配置网页作者</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;ZhongYuan&quot;</span> <span class="attr">content</span>=<span class="string">&quot;tony&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="8">
<li>配置网页生成工具</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;genrator&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Visual Studio Code&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>配置网页版权信息</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;copyright&quot;</span> <span class="attr">content</span>=<span class="string">&quot;2022-22029©版权所有&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>配置网页自动刷新</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;10;url=http://www.baidu.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>完整网页元信息，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta">元信息|MDN</a></p>
<hr>
<h1 id="HTML5新特性"><a href="#HTML5新特性" class="headerlink" title="HTML5新特性"></a>HTML5新特性</h1><h2 id="什么是HTML5"><a href="#什么是HTML5" class="headerlink" title="什么是HTML5"></a>什么是HTML5</h2><ul>
<li><code>HTML5</code>是新一代<code>HTML</code>标准，2014年10月由万维网联盟（<code>W3C</code>）完成标准制定。</li>
<li><code>HTML5</code>狭义上指的是最新标准，广义上是指：整个前端。</li>
</ul>
<h2 id="HTML5的优势"><a href="#HTML5的优势" class="headerlink" title="HTML5的优势"></a>HTML5的优势</h2><ol>
<li>针对<code>JavaScript</code>，新增了很多可操作的接口。</li>
<li>新增了一些语义化标签，全局属性。</li>
<li>新增了多媒体标签，可以很好的取缔<code>flash</code>。</li>
<li>更加侧重语义化，对<code>SEO</code>更加友好。</li>
<li>可以移植性好，可以大量应用在移动设备上。</li>
</ol>
<h2 id="HTML5的兼容性"><a href="#HTML5的兼容性" class="headerlink" title="HTML5的兼容性"></a>HTML5的兼容性</h2><ul>
<li>支持主流浏览器：<code>Chrome</code>、<code>Sfari</code>、<code>Opera</code>、<code>Firefox</code>等。</li>
</ul>
<blockquote>
<p>IE 浏览器必须是 9 及以上版本才支持 HTML5 ，且 IE9 仅支持部分 HTML5 新特性。</p>
</blockquote>
<h2 id="新增语义化标签"><a href="#新增语义化标签" class="headerlink" title="新增语义化标签"></a>新增语义化标签</h2><h3 id="新增布局标签"><a href="#新增布局标签" class="headerlink" title="新增布局标签"></a>新增布局标签</h3><table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
<th>单&#x2F;双标签</th>
</tr>
</thead>
<tbody><tr>
<td><code>header</code></td>
<td>整个页面或部分区域的头部。</td>
<td>双</td>
</tr>
<tr>
<td><code>footer</code></td>
<td>整个页面或部分区域的底部。</td>
<td>双</td>
</tr>
<tr>
<td><code>nav</code></td>
<td>导航</td>
<td>双</td>
</tr>
<tr>
<td><code>article</code></td>
<td>文章、帖子、杂志、新闻、博客、评论等。</td>
<td>双</td>
</tr>
<tr>
<td><code>section</code></td>
<td>页面中的某段文字或文章中的某段文字。</td>
<td>双</td>
</tr>
<tr>
<td><code>aside</code></td>
<td>侧边栏</td>
<td>双</td>
</tr>
<tr>
<td><code>main</code></td>
<td>文档的主要内容，这标签基本不用。</td>
<td>双</td>
</tr>
</tbody></table>
<p>关于<code>article</code>和<code>section</code>：</p>
<blockquote>
<ol>
<li><code>article</code>里面可以有多个<code>section</code>。</li>
<li><code>section</code>强调的是分段或分块，如果你想把一段内容分成几段的时候，可以使用<code>section</code>元素。</li>
<li><code>article</code>比<code>section</code>更强调独立性，一块内容如果比较独立、完整，应该使用<code>article</code>元素。</li>
</ol>
</blockquote>
<h3 id="新增状态标签"><a href="#新增状态标签" class="headerlink" title="新增状态标签"></a>新增状态标签</h3><h3 id="新增列表标签"><a href="#新增列表标签" class="headerlink" title="新增列表标签"></a>新增列表标签</h3><h3 id="新增文本标签"><a href="#新增文本标签" class="headerlink" title="新增文本标签"></a>新增文本标签</h3><h2 id="新增表单功能"><a href="#新增表单功能" class="headerlink" title="新增表单功能"></a>新增表单功能</h2><h3 id="表单控件新增属性"><a href="#表单控件新增属性" class="headerlink" title="表单控件新增属性"></a>表单控件新增属性</h3><h3 id="input新增属性值"><a href="#input新增属性值" class="headerlink" title="input新增属性值"></a>input新增属性值</h3><h3 id="form新增属性"><a href="#form新增属性" class="headerlink" title="form新增属性"></a>form新增属性</h3><h2 id="新增多媒体标签"><a href="#新增多媒体标签" class="headerlink" title="新增多媒体标签"></a>新增多媒体标签</h2><h3 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h3><h3 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h3>]]></content>
      <categories>
        <category>笔记</category>
        <category>编程</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>综合素质-材料分析题——刷题笔记</title>
    <url>//note/teacher/zhuguanti.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、职业理念"><a href="#一、职业理念" class="headerlink" title="一、职业理念"></a>一、职业理念</h1><h2 id="教育观"><a href="#教育观" class="headerlink" title="教育观"></a>教育观</h2><h3 id="素质教育的内涵"><a href="#素质教育的内涵" class="headerlink" title="素质教育的内涵"></a>素质教育的内涵</h3><div class="note info flat"><p>提示： “提素，个性，创，两全”</p>
</div>

<details class="toggle" ><summary class="toggle-button" style="">可以尝试回忆背诵一下，点我展开答案</summary><div class="toggle-content"><ul>
<li><p>1、素质教育以提高国民素质为根本宗旨<br>国民：所有人；素质：思想道德、文化素养、健康等；包括基础、高等、社会教育</p>
</li>
<li><p>2、素质教育是面向全体学生的教育<br>不歧视学生，全班每一个人一视同仁</p>
</li>
<li><p>3、素质教育是促进学生全面发展的教育——成绩+其他<br>除了成绩还关心其他：品德、心理、实践等；不占用音体美课堂补习语数英；全面发展不等于平均发展</p>
</li>
<li><p>4、素质教育是促进学生个性发展的教育——特长+特点<br>关注到学生的特点，因材施教</p>
</li>
<li><p>5、素质教育是以培养学生的创新精神和实践能力为重点的教育</p>
<p>尊重学生的新想法；鼓励学生创造和动手操作；带学生走出课堂</p>
<p>创新精神：素质教育的核心、现代教育与传统教育的根本区别</p>
</li>
</ul>
</div></details>

<h3 id="新课程改革的教学观"><a href="#新课程改革的教学观" class="headerlink" title="新课程改革的教学观"></a>新课程改革的教学观</h3><div class="note info flat"><p>提示：“学，习，过，人”</p>
</div>

<details class="toggle" ><summary class="toggle-button" style="">可以尝试回忆背诵一下，点我展开答案</summary><div class="toggle-content"><ul>
<li><p>1教学从“教育者为中心”转向“学习者为中心”——互动、游戏<br>调动学生积极性；鼓励学生参与；考虑学生意见</p>
</li>
<li><p>2教学从“教会学生知识”转向“教会学生学习”——方法<br>教给学生学习的方法</p>
</li>
<li><p>3教学从“重结论轻过程”转向“重结论的同时更重过程”——参与<br>鼓励学生自己分析问题和解决问题、鼓励自主探索</p>
</li>
<li><p>4教学从“关注学科”转向“关注人”——人格、情感<br>关注学生的情绪、情感、道德、人格、</p>
</li>
</ul>
</div></details>

<h3 id="材料分析题"><a href="#材料分析题" class="headerlink" title="材料分析题"></a>材料分析题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>崔老师刚工作就担任了副班主任。<br>崔老师对学生很“宽容”。有的学生偏科，他说：“没有关系，很多天才都偏科。”有的学生不喜欢体育锻炼，他也表示理解：“人有自己喜欢的事情，也一定有自己不喜欢的事情，不可能什么都喜欢。”</p>
<p>崔老师很喜欢学习成绩好的学生，经常召集这些学生谈话，告诉他们要有远大理想，并引导他们树立正确的人生目标。对于成绩不太好的学生，他也不加干预，还说：“学习上的差异古今中外都存在，十个手指头还不一样长呢。”</p>
<p>班主任与崔老师商量，打算分头联系家长，了解学生的基本情况，敦促家长为学校工作提供支持。他觉得没有必要，理由是：“家长平时都很忙，我们应该理解家长。教育孩子是我们老师的责任，不能给家长增加负担。”<br>很多老师对崔老师的做法不理解。</p>
<hr>
<details class="toggle" ><summary class="toggle-button" style="">点我查看参考答案</summary><div class="toggle-content"><p>材料中崔老师的行为是<strong>错误</strong>的，违背了素质教育的要求。<br>首先，素质教育是面向全体学生的教育。素质教育强调在教育中使每一个人都得到发展，而不是只注重一部分人。材料中，崔老师很喜欢成绩好的学生，并引导、促进他们的发展；对于成绩不好的学生不管不顾，没有做到面向全体学生。<br>其次，素质教育是促进学生全面发展的教育。实施素质教育就要通过德育、智育、体育等的有机融合，来实现学生德、智、体、美等方面的全面发展。材料中，崔老师认可学生偏科、不喜欢体育锻炼等情况，忽视了学生的全面发展。<br>最后，素质教育是促进学生个性发展的教育。老师要尊重学生的个性并做到因材施教。材料中，崔老师只看到学生之间有差异，但是并没有针对学生的特点进行有针对性的教育。<br>总之，崔老师的行为严重违背素质教育的要求，不利于学生的健康成长，我们要引以为戒。</p>
</div></details>



<hr>
<hr>
<h2 id="教师观"><a href="#教师观" class="headerlink" title="教师观"></a>教师观</h2><h3 id="教师角色的改变"><a href="#教师角色的改变" class="headerlink" title="教师角色的改变"></a>教师角色的改变</h3><div class="note info flat"><p>提示：“ 建、研、放、促 ”</p>
</div>

<details class="toggle" ><summary class="toggle-button" style="">点我展开答案</summary><div class="toggle-content"><p>1、从教师与学生的关系看，新课程要求教师应该是学生学习和发展的促进者。</p>
<p>2、从教师与课程的关系看，新课程要求教师应该是课程的建设者和开发者。</p>
<p>3、从教师与研究的关系看，新课程要求教师应该是教育教学的研究者。</p>
<p>4、从学校与社区的关系看，新课程要求教师应该是社区型的开放教师。</p>
</div></details>





<h3 id="教师行为转变"><a href="#教师行为转变" class="headerlink" title="教师行为转变"></a>教师行为转变</h3><div class="note info flat"><p>提示：“ 建、研、放、促 ”</p>
</div>

<details class="toggle" ><summary class="toggle-button" style="">点我展开答案</summary><div class="toggle-content"><p>1、在对待师生关系上，新课程强调尊重与赞赏</p>
<p>2、在对待教学上，新课程强调帮助与引导</p>
<p>3、在对待自我上，新课程强调反思</p>
<p>4、在对待与其他教育者的关系上，新课程强调合作</p>
</div></details>



<hr>
<hr>
<h2 id="学生观"><a href="#学生观" class="headerlink" title="学生观"></a>学生观</h2><p>下面是md语法支持的彩色语法块和折叠文字</p>
<blockquote>
<p>[!注意]<br>这是注意区块</p>
</blockquote>
<details>
<summary>点击查看详细内容</summary>
展开的内容
</details>
]]></content>
      <categories>
        <category>笔记</category>
        <category>教资考试</category>
      </categories>
      <tags>
        <tag>综合素质</tag>
        <tag>教资</tag>
      </tags>
  </entry>
</search>
