<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript学习笔记（2）对象object | 源的自留地</title><meta name="author" content="Yuan"><meta name="copyright" content="Yuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="正在学习JavaScript的对象，加油！！！">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript学习笔记（2）对象object">
<meta property="og:url" content="https://github.com/aboucide/aboucide.github.io.git/blog/note/code/JavaScript2.html">
<meta property="og:site_name" content="源的自留地">
<meta property="og:description" content="正在学习JavaScript的对象，加油！！！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://emaillistvalidation.com/blog/content/images/2023/09/JavaScript-Symbol.png">
<meta property="article:published_time" content="2024-10-08T17:58:39.000Z">
<meta property="article:modified_time" content="2024-11-08T09:59:31.769Z">
<meta property="article:author" content="Yuan">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://emaillistvalidation.com/blog/content/images/2023/09/JavaScript-Symbol.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://github.com/aboucide/aboucide.github.io.git/blog/note/code/JavaScript2.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.clarity.ms"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>(function(c,l,a,r,i,t,y){
    c[a]=c[a]||function(){(c[a].q=c[a].q||[]).push(arguments)};
    t=l.createElement(r);t.async=1;t.src="https://www.clarity.ms/tag/"+i;
    y=l.getElementsByTagName(r)[0];y.parentNode.insertBefore(t,y);
})(window, document, "clarity", "script", "nr4zxz4vpa");</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":180,"position":"top","messagePrev":"这篇文章已经发布","messageNext":"天了，请注意考虑本文内容是否失效，仅作参考使用."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript学习笔记（2）对象object',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-08 09:59:31'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="referrer" content="no-referrer-when-downgrade" /><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://puui.qpic.cn/vpic_cover/l3165317c7s/l3165317c7s_hz.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-navicon"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/note/"><i class="fa-fw fas fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-screwdriver-wrench"></i><span> OL tool</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/OLtool/m3u8-downloader/index-m3u8.html"><span> m3u8视频下载</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-code"></i><span> HTML学习记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Demo/"><i class="fa-fw far fa-file-code"></i><span> all html demo</span></a></li><li><a class="site-page child" href="/html/html-learn-paiban.html"><i class="fa-fw fas fa-code"></i><span> 1、排版标签</span></a></li><li><a class="site-page child" href="/html/html-learn-table.html"><i class="fa-fw fas fa-code"></i><span> 2、表格的使用</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="源的自留地"><span class="site-name">源的自留地</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-navicon"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/note/"><i class="fa-fw fas fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-screwdriver-wrench"></i><span> OL tool</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/OLtool/m3u8-downloader/index-m3u8.html"><span> m3u8视频下载</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-file-code"></i><span> HTML学习记录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Demo/"><i class="fa-fw far fa-file-code"></i><span> all html demo</span></a></li><li><a class="site-page child" href="/html/html-learn-paiban.html"><i class="fa-fw fas fa-code"></i><span> 1、排版标签</span></a></li><li><a class="site-page child" href="/html/html-learn-table.html"><i class="fa-fw fas fa-code"></i><span> 2、表格的使用</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript学习笔记（2）对象object<a class="post-edit-link" href="https://github.com/aboucide/hexo-blog-source/tree/main/source/_posts/blog/笔记note/JavaScript学习笔记（2）对象object.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表日期</span><time class="post-meta-date-created" datetime="2024-10-08T17:58:39.000Z" title="发表日期 2024-10-08 17:58:39">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">最近更新日期</span><time class="post-meta-date-updated" datetime="2024-11-08T09:59:31.769Z" title="最近更新日期 2024-11-08 09:59:31">2024-11-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/note/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/note/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript学习笔记（2）对象object"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">本文总阅读次数:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p><code>JavaScript</code> 中有八种数据类型。有七种原始类型，因为它们的值只包含一种东西（字符串，数字或者其他）。</p>
<p><code>对象</code>则用来存储键值对和更复杂的实体。在 <code>JavaScript</code> 中，对象几乎渗透到了这门编程语言的方方面面。所以，在我们深入理解这门语言之前，必须先理解<code>对象</code>。</p>
<p>我们可以通过使用带有可选 <strong>属性列表</strong> 的花括号 <code>&#123;…&#125;</code> 来创建对象。一个属性就是一个键值对<code>（“key: value”）</code>，其中键（<code>key</code>）是一个字符串（也叫做<span style="color:#CC0000;">属性名</span>），值（<code>value</code>）可以是任何值。</p>
<p>我们可以把<code>对象</code>想象成一个带有<code>抽屉</code>的<code>文件柜</code>。<br>每一条数据都基于键（<code>key</code>）存储在<code>抽屉</code>中。<br>这样我们就可以很容易根据文件名（也就是“键”）查找文件或添加&#x2F;删除文件了。</p>
<p>我们可以用下面两种语法中的任一种来创建一个空的对象（“空柜子”）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// “构造函数” 的语法</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;&#125;;  		<span class="comment">// “字面量” 的语法</span></span><br></pre></td></tr></table></figure>

<p>通常，我们用花括号，即常用第二种方法。这种方式我们叫做 <strong>字面量</strong>。</p>
<h2 id="文本和属性"><a href="#文本和属性" class="headerlink" title="文本和属性"></a>文本和属性</h2><p>我们可以在创建对象的时候，立即将一些属性以<code>键值对</code>的形式放到 <code>&#123;...&#125;</code> 中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;     <span class="comment">// 一个对象</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,  <span class="comment">// 键 &quot;name&quot;，值 &quot;John&quot;</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>        <span class="comment">// 键 &quot;age&quot;，值 30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性有键（或者也可以叫做“名字”或“标识符”），位于冒号 <code>&quot;:&quot;</code> 的前面，值在冒号的右边。</p>
<p>在 <code>user</code> 对象中，有两个属性：</p>
<ol>
<li>第一个的键是 <code>&quot;name&quot;</code>，值是 <code>&quot;John&quot;</code>。</li>
<li>第二个的键是 <code>&quot;age&quot;</code>，值是 <code>30</code>。</li>
</ol>
<p>生成的 <code>user</code> 对象可以被想象为一个放置着两个标记有 “name” 和 “age” 的<code>抽屉</code>的柜子。</p>
<p>我们可以随时添加、删除和读取文件。</p>
<p>可以使用<code>点符号</code>访问属性值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件的属性：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">age</span> ); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>

<p>属性的值可以是任意类型，让我们加个布尔类型：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.<span class="property">isAdmin</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>我们可以用 <code>delete</code> 操作符移除属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> user.<span class="property">age</span>;</span><br></pre></td></tr></table></figure>

<p>我们也可以用<code>多字词语</code>来作为属性名，但必须给它们加上引号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="string">&quot;likes birds&quot;</span>: <span class="literal">true</span>  <span class="comment">// 多词属性名必须加引号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>列表中的最后一个属性应以逗号结尾：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这叫做尾随（trailing）或悬挂（hanging）逗号。这样便于我们添加、删除和移动属性，因为所有的行都是相似的。</p>
<h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>对于多词属性，点操作就不能用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这将提示有语法错误</span></span><br><span class="line">user.<span class="property">likes</span> birds = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>JavaScript 理解不了。它认为我们在处理 <code>user.likes</code>，然后在遇到意外的 <code>birds</code> 时给出了语法错误。</p>
<p>点符号要求 <code>key</code> 是有效的变量标识符。这意味着：不包含空格，不以数字开头，也不包含特殊字符（允许使用 <code>$</code> 和 <code>_</code>）。</p>
<p>有另一种方法，就是使用方括号，可用于<strong>任何字符串</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">user[<span class="string">&quot;likes birds&quot;</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user[<span class="string">&quot;likes birds&quot;</span>]); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="keyword">delete</span> user[<span class="string">&quot;likes birds&quot;</span>];</span><br></pre></td></tr></table></figure>

<p>现在一切都可行了。请注意方括号中的字符串要放在引号中，单引号或双引号都可以。</p>
<p>方括号同样提供了一种可以通过任意表达式来获取属性名的方式 —— 与文本字符串不同 —— 例如下面的变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;likes birds&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟 user[&quot;likes birds&quot;] = true; 一样</span></span><br><span class="line">user[key] = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，变量 <code>key</code> 可以是程序运行时计算得到的，也可以是根据用户的输入得到的。然后我们可以用它来访问属性。这给了我们很大的灵活性。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key =  <span class="string">&quot;name&quot;</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问变量</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user[key] ); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>点符号不能以类似的方式使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">key</span> ) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>当创建一个对象时，我们可以在对象字面量中使用方括号。这叫做 <strong>计算属性</strong>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&quot;你想买什么水果?&quot;</span>, <span class="string">&quot;苹果&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit]: <span class="number">5</span>, <span class="comment">// 属性名是从 fruit 变量中得到的，默认输入的是苹果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( bag.<span class="property">apple</span> ); <span class="comment">// 5 如果 fruit=&quot;apple&quot;</span></span><br></pre></td></tr></table></figure>

<p>计算属性的含义很简单：<code>[fruit]</code> 含义是属性名应该从 <code>fruit</code> 变量中获取。</p>
<p>所以，如果一个用户输入 <code>&quot;apple&quot;</code>，<code>bag</code> 将变为 <code>&#123;apple: 5&#125;</code>。</p>
<p>本质上，这跟下面的语法效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="title function_">prompt</span>(<span class="string">&quot;Which fruit to buy?&quot;</span>, <span class="string">&quot;apple&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> bag = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 fruit 变量中获取值</span></span><br><span class="line">bag[fruit] = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>


<p>我们可以在方括号中使用更复杂的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fruit = <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> bag = &#123;</span><br><span class="line">  [fruit + <span class="string">&#x27;Computers&#x27;</span>]: <span class="number">5</span> <span class="comment">// bag.appleComputers = 5</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>方括号比点符号更强大</strong>。它允许任何属性名和变量，但写起来也更加麻烦。</p>
<p>所以，大部分时间里，</p>
<ul>
<li>当属性名是已知且简单的时候，就使用点符号。</li>
<li>如果我们需要一些更复杂的内容，那么就用方括号。</li>
</ul>
<h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>在实际开发中，我们通常用已存在的变量当做属性名。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name,</span><br><span class="line">    <span class="attr">age</span>: age,</span><br><span class="line">    <span class="comment">// ……其他的属性</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="title function_">makeUser</span>(<span class="string">&quot;John&quot;</span>, <span class="number">30</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，属性名跟变量名一样。这种通过变量生成属性的应用场景很常见，在这有一种特殊的 <strong>属性值缩写</strong> 方法，使属性名变得更短。</p>
<p>可以用 <code>name</code> 来代替 <code>name:name</code> 像下面那样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeUser</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name, <span class="comment">// 与 name: name 相同</span></span><br><span class="line">    age,  <span class="comment">// 与 age: age 相同</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以把属性名简写方式和正常方式混用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  name,  <span class="comment">// 与 name:name 相同</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="属性名称限制"><a href="#属性名称限制" class="headerlink" title="属性名称限制"></a>属性名称限制</h2><p>我们已经知道，变量名不能是编程语言的某个保留字，如 “for”、“let”、“return” 等……</p>
<p>但对象的属性名并不受此限制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些属性都没问题</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">for</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">let</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">return</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">for</span> + obj.<span class="property">let</span> + obj.<span class="property">return</span> );  <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>简而言之，属性命名没有限制。属性名可以是任何字符串或者 <code>symbol</code>（一种特殊的标志符类型，将在后面介绍）。</p>
<p>其他类型会被自动地转换为字符串。</p>
<p>例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&quot;test&quot;</span> <span class="comment">// 等同于 &quot;0&quot;: &quot;test&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 都会输出相同的属性（数字 0 被转为字符串 &quot;0&quot;）</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj[<span class="string">&quot;0&quot;</span>] ); <span class="comment">// test</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj[<span class="number">0</span>] ); <span class="comment">// test (相同的属性)</span></span><br></pre></td></tr></table></figure>

<p>这里有个小陷阱：一个名为 <code>__proto__</code> 的属性。我们不能将它设置为一个非对象的值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="number">5</span>; <span class="comment">// 分配一个数字</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// [object Object] —— 值为对象，与预期结果不同</span></span><br></pre></td></tr></table></figure>

<p>我们从代码中可以看出来，把它赋值为 <code>5</code> 的操作被忽略了。</p>
<p>我们将在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/prototype-inheritance">后续章节</a> 中学习 <code>__proto__</code> 的特殊性质，并给出了 <a target="_blank" rel="noopener" href="https://zh.javascript.info/prototype-methods">解决此问题的方法</a>。</p>
<h2 id="属性存在性测试，“in”-操作符"><a href="#属性存在性测试，“in”-操作符" class="headerlink" title="属性存在性测试，“in” 操作符"></a>属性存在性测试，“in” 操作符</h2><p>相比于其他语言，JavaScript 的对象有一个需要注意的特性：能够被访问任何属性。即使属性不存在也不会报错！</p>
<p>读取不存在的属性只会得到 <code>undefined</code>。所以我们可以很容易地判断一个属性是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">noSuchProperty</span> === <span class="literal">undefined</span> ); <span class="comment">// true 意思是没有这个属性</span></span><br></pre></td></tr></table></figure>

<p>这里还有一个特别的，检查属性是否存在的操作符 <code>&quot;in&quot;</code>。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;key&quot;</span> <span class="keyword">in</span> object</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;age&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// true，user.age 存在</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;blabla&quot;</span> <span class="keyword">in</span> user ); <span class="comment">// false，user.blabla 不存在。</span></span><br></pre></td></tr></table></figure>

<p>请注意，<code>in</code> 的左边必须是 <strong>属性名</strong>。通常是一个带引号的字符串。</p>
<p>如果我们省略引号，就意味着左边是一个变量，它应该包含要判断的实际属性名。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">age</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;age&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( key <span class="keyword">in</span> user ); <span class="comment">// true，属性 &quot;age&quot; 存在</span></span><br></pre></td></tr></table></figure>

<p>为何会有 <code>in</code> 运算符呢？与 <code>undefined</code> 进行比较来判断还不够吗？</p>
<p>确实，大部分情况下与 <code>undefined</code> 进行比较来判断就可以了。但有一个例外情况，这种比对方式会有问题，但 <code>in</code> 运算符的判断结果仍是对的。</p>
<p>那就是属性存在，但存储的值是 <code>undefined</code> 的时候：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">test</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="property">test</span> ); <span class="comment">// 显示 undefined，所以属性不存在？</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;test&quot;</span> <span class="keyword">in</span> obj ); <span class="comment">// true，属性存在！</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，属性 <code>obj.test</code> 事实上是存在的，所以 <code>in</code> 操作符检查通过。</p>
<p>这种情况很少发生，因为通常情况下不应该给对象赋值 <code>undefined</code>。我们通常会用 <code>null</code> 来表示未知的或者空的值。因此，<code>in</code> 运算符是代码中的特殊来宾。</p>
<h2 id="“for-in”-循环"><a href="#“for-in”-循环" class="headerlink" title="“for..in” 循环"></a>“for..in” 循环</h2><p>为了遍历一个对象的所有键<code>（key）</code>，可以使用一个特殊形式的循环：<code>for..in</code>。这跟我们在前面学到的 <code>for(;;)</code> 循环是完全不一样的东西。</p>
<p>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  <span class="comment">// 对此对象属性中的每个键执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，让我们列出 <code>user</code> 所有的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( key );  <span class="comment">// 会依次输出 name, age, isAdmin</span></span><br><span class="line">  <span class="comment">// 属性键的值</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( user[key] ); <span class="comment">// 会依次输出 John, 30, true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，所有的 <code>“for” </code>结构体都允许我们在循环中定义变量，像这里的 <code>let key</code>。</p>
<p>同样，我们可以用其他属性名来替代 <code>key</code>。例如 <code>&quot;for(let prop in obj)&quot;</code> 也很常用。</p>
<h3 id="像对象一样排序"><a href="#像对象一样排序" class="headerlink" title="像对象一样排序"></a>像对象一样排序</h3><p>对象有顺序吗？换句话说，如果我们遍历一个对象，我们获取属性的顺序是和属性添加时的顺序相同吗？这靠谱吗？</p>
<p>简短的回答是：“有特别的顺序”：<strong>整数属性会被进行排序，其他属性则按照创建的顺序显示</strong>。详情如下：</p>
<p>例如，让我们考虑一个带有电话号码的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;德国&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;新西兰&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;大不列颠&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;美国&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(code); <span class="comment">// 1, 41, 44, 49</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象可用于面向用户的建议选项列表。如果我们的网站主要面向德国观众，那么我们可能希望 <code>49</code> 排在第一。</p>
<p>但如果我们执行代码，会看到完全不同的现象：</p>
<ul>
<li>美国 (1) 排在了最前面</li>
<li>然后是 新西兰 (41) 及其它。</li>
</ul>
<p>因为这些电话号码是整数，所以它们以升序排列。所以我们看到的是 <code>1, 41, 44, 49</code>。</p>
<p><strong>整数属性？那是什么？</strong></p>
<p>这里的“整数属性”指的是一个可以在不做任何更改的情况下与一个整数进行相互转换的字符串。</p>
<p>所以，<code>&quot;49&quot;</code> 是一个整数属性名，因为我们把它转换成整数，再转换回来，它还是一样的。但是 “+49” 和 “1.2” 就不行了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Number(...) 显式转换为数字</span></span><br><span class="line"><span class="comment">// Math.trunc 是内建的去除小数部分的方法。</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;49&quot;</span>))) ); <span class="comment">// &quot;49&quot;，相同，整数属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;+49&quot;</span>))) ); <span class="comment">// &quot;49&quot;，不同于 &quot;+49&quot; ⇒ 不是整数属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">String</span>(<span class="title class_">Math</span>.<span class="title function_">trunc</span>(<span class="title class_">Number</span>(<span class="string">&quot;1.2&quot;</span>))) ); <span class="comment">// &quot;1&quot;，不同于 &quot;1.2&quot; ⇒ 不是整数属性</span></span><br></pre></td></tr></table></figure>

<p>……此外，如果属性名不是整数，那它们就按照创建时的顺序来排序，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">surname</span>: <span class="string">&quot;Smith&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">user.<span class="property">age</span> = <span class="number">25</span>; <span class="comment">// 增加一个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非整数属性是按照创建的顺序来排列的</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> user) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( prop ); <span class="comment">// name, surname, age</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以，为了解决电话号码的问题，我们可以使用非整数属性名来 <strong>欺骗</strong> 程序。只需要给每个键名加一个加号 <code>&quot;+&quot;</code> 前缀就行了。</p>
<p>像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> codes = &#123;</span><br><span class="line">  <span class="string">&quot;+49&quot;</span>: <span class="string">&quot;德国&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+41&quot;</span>: <span class="string">&quot;新西兰&quot;</span>,</span><br><span class="line">  <span class="string">&quot;+44&quot;</span>: <span class="string">&quot;大不列颠&quot;</span>,</span><br><span class="line">  <span class="comment">// ..,</span></span><br><span class="line">  <span class="string">&quot;+1&quot;</span>: <span class="string">&quot;美国&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> code <span class="keyword">in</span> codes) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( +code ); <span class="comment">// 49, 41, 44, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在跟预想的一样了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对象是具有一些特殊特性的关联数组。</p>
<p>它们存储<code>属性名</code>与<code>属性值</code>（键值对），其中：</p>
<ul>
<li>属性的键必须是字符串或者 symbol（通常是字符串）。</li>
<li>值可以是任何类型。</li>
</ul>
<p>我们可以用下面的方法访问属性：</p>
<ul>
<li>点符号: <code>obj.property</code>。</li>
<li>方括号 <code>obj[&quot;property&quot;]</code>，方括号允许从变量中获取键，例如 <code>obj[varWithKey]</code>。</li>
</ul>
<p>其他操作：</p>
<ul>
<li>删除属性：<code>delete obj.prop</code>。</li>
<li>检查是否存在给定键的属性：<code>&quot;key&quot; in obj</code>。</li>
<li>遍历对象：<code>for(let key in obj)</code> 循环。</li>
</ul>
<blockquote>
<p>遍历的对象除了整数型的属性名是按照数值大小来排序；其余的对象都是按照编写顺序进行依次输出。</p>
</blockquote>
<p>我们在这一章学习的叫做“普通对象（plain object）”，或者就叫对象。</p>
<p>JavaScript 中还有很多其他类型的对象：</p>
<ul>
<li><code>Array</code> 用于存储有序数据集合，</li>
<li><code>Date</code> 用于存储时间日期，</li>
<li><code>Error</code> 用于存储错误信息。</li>
<li>……等等。</li>
</ul>
<p>它们有着各自特别的特性，我们将在后面学习到。有时候大家会说“Array 类型”或“Date 类型”，但其实它们并不是自身所属的类型，而是属于一个对象类型即 “object”。它们以不同的方式对 “object” 做了一些扩展。</p>
<p>JavaScript 中的对象非常强大。这里我们只接触了其冰山一角。在后面的章节中，我们将频繁使用对象进行编程，并学习更多关于对象的知识。</p>
<hr>
<h1 id="对象引用和复制"><a href="#对象引用和复制" class="headerlink" title="对象引用和复制"></a>对象引用和复制</h1><p>对象与原始类型的根本区别之一是，对象是“通过引用”存储和复制的，而原始类型：字符串、数字、布尔值等 —— 总是“作为一个整体”复制。</p>
<p>如果我们深入了解复制值时会发生什么，就很容易理解了。</p>
<p>让我们从原始类型开始，例如一个字符串。</p>
<p>这里我们将 <code>message</code> 复制到 <code>phrase</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> phrase = message;</span><br></pre></td></tr></table></figure>

<p>结果我们就有了两个独立的变量，每个都存储着字符串 <code>&quot;Hello!&quot;</code>。</p>
<p>显而易见的结果，对吧？</p>
<p>但是，对象不是这样的。</p>
<p><strong>赋值了对象的变量存储的不是对象本身，而是该对象“在内存中的地址” —— 换句话说就是对该对象的“引用”。</strong></p>
<p>让我们看一个这样的变量的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>我们可以将一个对象变量（例如 <code>user</code>）想象成一个有对象的地址的快捷方式。</p>
<p>当我们对对象执行操作时，例如获取一个属性 <code>user.name</code>，JavaScript 引擎会查看该地址中的内容，并在实际对象上执行操作。</p>
<p>现在，这就是为什么它很重要。</p>
<p><strong>当一个对象变量被复制 —— 引用被复制，而该对象自身并没有被复制。</strong></p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user; <span class="comment">// 复制引用</span></span><br></pre></td></tr></table></figure>

<p>现在我们有了两个变量，它们保存的都是对同一个对象的引用：</p>
<p>正如你所看到的，这里仍然只有一个对象，但现在有两个引用它的变量。</p>
<p>我们可以通过其中任意一个变量来访问该对象并修改它的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line"></span><br><span class="line">admin.<span class="property">name</span> = <span class="string">&#x27;Pete&#x27;</span>; <span class="comment">// 通过 &quot;admin&quot; 引用来修改</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// &#x27;Pete&#x27;，修改能通过 &quot;user&quot; 引用看到</span></span><br></pre></td></tr></table></figure>

<p>这就像我们为一个A文件创立了两个快捷方式，使用其中一个快捷方式（<code>admin</code>）打开文件并更改了里面的东西。那么，如果我们稍后用另一个快捷方式（<code>user</code>），我们仍然可以打开同一个文件并且可以访问更改的内容。</p>
<h2 id="通过引用来比较"><a href="#通过引用来比较" class="headerlink" title="通过引用来比较"></a>通过引用来比较</h2><p>仅当两个对象为同一对象时，两者才相等。</p>
<p>例如，这里 <code>a</code> 和 <code>b</code> 两个变量都引用同一个对象，所以它们相等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = a; <span class="comment">// 复制引用</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a == b ); <span class="comment">// true，都引用同一对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a === b ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>而这里两个独立的对象则并不相等，即使它们看起来很像（都为空）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;; <span class="comment">// 两个独立的对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( a == b ); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>对于类似 <code>obj1 &gt; obj2</code> 的比较，或者跟一个原始类型值的比较 <code>obj == 5</code>，对象都会被转换为原始值。我们很快就会学到对象是如何转换的，但是说实话，很少需要进行这样的比较 —— 通常是在编程错误的时候才会出现这种情况。</p>
<h2 id="克隆与合并，Object-assign"><a href="#克隆与合并，Object-assign" class="headerlink" title="克隆与合并，Object.assign"></a>克隆与合并，Object.assign</h2><p>那么，拷贝一个对象变量会又创建一个对相同对象的引用。</p>
<p>但是，如果我们想要复制一个对象，那该怎么做呢？</p>
<p>我们可以创建一个新对象，通过遍历已有对象的属性，并在原始类型值的层面复制它们，以实现对已有对象结构的复制。</p>
<p>就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = &#123;&#125;; <span class="comment">// 新的空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 user 中所有的属性拷贝到其中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) &#123;</span><br><span class="line">  clone[key] = user[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 clone 是带有相同内容的完全独立的对象</span></span><br><span class="line">clone.<span class="property">name</span> = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// 改变了其中的数据</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// 原来的对象中的 name 属性依然是 John</span></span><br></pre></td></tr></table></figure>

<p>我们也可以使用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法来达成同样的效果。</p>
<p>语法是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, [src1, src2, src3...])</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 <code>dest</code> 是指目标对象。</li>
<li>更后面的参数 <code>src1, ..., srcN</code>（可按需传递多个参数）是源对象。</li>
<li>该方法将所有源对象的属性拷贝到目标对象 <code>dest</code> 中。换句话说，从第二个开始的对象的所有参数的属性都被拷贝到第一个参数的对象中。</li>
<li>调用结果返回 <code>dest</code>。</li>
</ul>
<p>例如，我们可以用它来合并多个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> permissions1 = &#123; <span class="attr">canView</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> permissions2 = &#123; <span class="attr">canEdit</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 permissions1 和 permissions2 中的所有属性都拷贝到 user 中</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, permissions1, permissions2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 user = &#123; name: &quot;John&quot;, canView: true, canEdit: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>如果被拷贝的属性的属性名已经存在，那么它会被覆盖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(user, &#123; <span class="attr">name</span>: <span class="string">&quot;Pete&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// 现在 user = &#123; name: &quot;Pete&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>我们也可以用 <code>Object.assign</code> 代替 <code>for..in</code> 循环来进行简单克隆：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br></pre></td></tr></table></figure>

<p>它将 <code>user</code> 中的所有属性拷贝到了一个空对象中，并返回这个新的对象。</p>
<p>还有其他克隆对象的方法，例如使用 <a target="_blank" rel="noopener" href="https://zh.javascript.info/rest-parameters-spread">spread 语法</a> <code>clone = &#123;...user&#125;</code>，在后面的章节中我们会讲到。</p>
<h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h2><p>到现在为止，我们都假设 <code>user</code> 的所有属性均为原始类型。但属性可以是对其他对象的引用。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">sizes</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">182</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">sizes</span>.<span class="property">height</span> ); <span class="comment">// 182</span></span><br></pre></td></tr></table></figure>

<p>现在这样拷贝 <code>clone.sizes = user.sizes</code> 已经不足够了，因为 <code>user.sizes</code> 是个对象，它会以引用形式被拷贝。因此 <code>clone</code> 和 <code>user</code> 会共用一个 sizes：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">sizes</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">182</span>,</span><br><span class="line">    <span class="attr">width</span>: <span class="number">50</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">sizes</span> === clone.<span class="property">sizes</span> ); <span class="comment">// true，同一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user 和 clone 分享同一个 sizes</span></span><br><span class="line">user.<span class="property">sizes</span>.<span class="property">width</span>++;       <span class="comment">// 通过其中一个改变属性值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(clone.<span class="property">sizes</span>.<span class="property">width</span>); <span class="comment">// 51，能从另外一个获取到变更后的结果</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个问题，并让 <code>user</code> 和 <code>clone</code> 成为两个真正独立的对象，我们应该使用一个拷贝循环来检查 <code>user[key]</code> 的每个值，如果它是一个对象，那么也复制它的结构。这就是所谓的“深拷贝”。</p>
<p>我们可以使用递归来实现它。或者为了不重复造轮子，采用现有的实现，例如 <a target="_blank" rel="noopener" href="https://lodash.com/">lodash</a> 库的 <a target="_blank" rel="noopener" href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<p><strong>使用 const 声明的对象也是可以被修改的</strong></p>
<p>通过引用对对象进行存储的一个重要的副作用是声明为 <code>const</code> 的对象 <strong>可以</strong> 被修改。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="property">name</span> = <span class="string">&quot;Pete&quot;</span>; <span class="comment">// (*)</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// Pete</span></span><br></pre></td></tr></table></figure>

<p>看起来 <code>(*)</code> 行的代码会触发一个错误，但实际并没有。<code>user</code> 的值是一个常量，它必须始终引用同一个对象，但该对象的属性可以被自由修改。</p>
<p>换句话说，只有当我们尝试将 <code>user=...</code> 作为一个整体进行赋值时，<code>const user</code> 才会报错。</p>
<p>也就是说，如果我们真的需要创建常量对象属性，也是可以的，但使用的是完全不同的方法。我们将在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/property-descriptors">属性标志和属性描述符</a> 一章中学习它。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>对象通过引用被赋值和拷贝。换句话说，一个变量存储的不是“对象的值”，而是一个对值的“引用”（内存地址）。因此，拷贝此类变量或将其作为函数参数传递时，所拷贝的是引用，而不是对象本身。</p>
<p>所有通过被拷贝的引用的操作（如添加、删除属性）都作用在同一个对象上。</p>
<p>为了创建“真正的拷贝”（一个克隆），我们可以使用 <code>Object.assign</code> 来做所谓的“浅拷贝”（嵌套对象被通过引用进行拷贝）或者使用“深拷贝”函数，例如 <a target="_blank" rel="noopener" href="https://lodash.com/docs#cloneDeep">_.cloneDeep(obj)</a>。</p>
<hr>
<h1 id="对象方法，”this”"><a href="#对象方法，”this”" class="headerlink" title="对象方法，”this”"></a>对象方法，”this”</h1><p>作为对象属性的函数被称为 <strong>方法</strong>。</p>
<p>通常创建对象来表示真实世界中的实体，如用户和订单等：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>并且，在现实世界中，用户可以进行 <strong>操作</strong>：从购物车中挑选某物、登录和注销等。</p>
<p>在 JavaScript 中，行为<code>（action）</code>由属性中的函数来表示。</p>
<h2 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h2><p>刚开始，我们来教 <code>user</code> 说 hello：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用函数表达式创建了一个函数，并将其指定给对象的 <code>user.sayHi</code> 属性。</p>
<p>随后我们像这样 <code>user.sayHi()</code> 调用它。用户现在可以说话了！</p>
<p>作为对象属性的函数被称为 <strong>方法</strong>。</p>
<p>所以，在这我们得到了 <code>user</code> 对象的 <code>sayHi</code> 方法。</p>
<p>当然，我们也可以使用预先声明的函数作为方法，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先，声明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将其作为一个方法添加</span></span><br><span class="line">user.<span class="property">sayHi</span> = sayHi;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Hello!</span></span><br></pre></td></tr></table></figure>

<p><strong>面向对象编程</strong> OOP</p>
<p>当我们在代码中用对象表示实体时，就是所谓的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象编程</a>，简称为 “OOP”。</p>
<p>OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。</p>
<h3 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a>方法简写</h3><p>在对象字面量中，有一种更短的（声明）方法的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些对象作用一样</span></span><br><span class="line"></span><br><span class="line">user = &#123;</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法简写看起来更好，对吧？</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123; <span class="comment">// 与 &quot;sayHi: function()&#123;...&#125;&quot; 一样</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如上所示，我们可以省略 <code>&quot;function&quot;</code>，只写 <code>sayHi()</code>。</p>
<p>说实话，这种表示法还是有些不同。在对象继承方面有一些细微的差别（稍后将会介绍），但目前它们并不重要。在几乎所有的情况下，更短的语法是首选的。</p>
<h2 id="方法中的-“this”"><a href="#方法中的-“this”" class="headerlink" title="方法中的 “this”"></a>方法中的 “this”</h2><p>通常，对象方法需要访问对象中存储的信息才能完成其工作。</p>
<p>例如，<code>user.sayHi()</code> 中的代码可能需要用到 <code>user</code> 的 name 属性。</p>
<p><strong>为了访问该对象，方法中可以使用 <code>this</code> 关键字。</strong></p>
<p><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</p>
<p>举个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// &quot;this&quot; 指的是“当前的对象”</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p>
<p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// &quot;user&quot; 替代 &quot;this&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>……但这样的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。</p>
<p>下面这个示例证实了这一点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">name</span> ); <span class="comment">// 导致错误</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> admin = user;</span><br><span class="line">user = <span class="literal">null</span>; <span class="comment">// 重写让其更明显</span></span><br><span class="line"></span><br><span class="line">admin.<span class="title function_">sayHi</span>(); <span class="comment">// TypeError: Cannot read property &#x27;name&#x27; of null</span></span><br></pre></td></tr></table></figure>

<p>如果我们在 <code>console.log</code> 中以 <code>this.name</code> 替换 <code>user.name</code>，那么代码就会正常运行。</p>
<h2 id="“this”-不受限制"><a href="#“this”-不受限制" class="headerlink" title="“this” 不受限制"></a>“this” 不受限制</h2><p>在 JavaScript 中，<code>this</code> 关键字与其他大多数编程语言中的不同。JavaScript 中的 <code>this</code> 可以用于任何函数，即使它不是对象的方法。</p>
<p>下面这样的代码没有语法错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this</code> 的值是在代码运行时计算出来的，它取决于代码上下文。</p>
<p>例如，这里相同的函数被分配给两个不同的对象，在调用中有着不同的 “this” 值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> admin = &#123; <span class="attr">name</span>: <span class="string">&quot;Admin&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在两个对象中使用相同的函数</span></span><br><span class="line">user.<span class="property">f</span> = sayHi;</span><br><span class="line">admin.<span class="property">f</span> = sayHi;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这两个调用有不同的 this 值</span></span><br><span class="line"><span class="comment">// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象</span></span><br><span class="line">user.<span class="title function_">f</span>(); <span class="comment">// John（this == user）</span></span><br><span class="line">admin.<span class="title function_">f</span>(); <span class="comment">// Admin（this == admin）</span></span><br><span class="line"></span><br><span class="line">admin[<span class="string">&#x27;f&#x27;</span>](); <span class="comment">// Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）</span></span><br></pre></td></tr></table></figure>

<p>这个规则很简单：如果 <code>obj.f()</code> 被调用了，则 <code>this</code> 在 <code>f</code> 函数调用期间是 <code>obj</code>。所以在上面的例子中 this 先是 <code>user</code>，之后是 <code>admin</code>。</p>
<p><strong>在没有对象的情况下调用：<code>this == undefined</code></strong></p>
<p>我们甚至可以在没有对象的情况下调用函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHi</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，严格模式下的 <code>this</code> 值为 <code>undefined</code>。如果我们尝试访问 <code>this.name</code>，将会报错。</p>
<p>在非严格模式的情况下，<code>this</code> 将会是 <strong>全局对象</strong>（浏览器中的 <code>window</code>，我们稍后会在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/global-object">全局对象</a> 一章中学习它）。这是一个历史行为，<code>&quot;use strict&quot;</code> 已经将其修复了。</p>
<p>通常这种调用是程序出错了。如果在一个函数内部有 <code>this</code>，那么通常意味着它是在对象上下文环境中被调用的。</p>
<p><strong>解除 <code>this</code> 绑定的后果</strong></p>
<p>如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是有指向该对象的 <code>this</code>。</p>
<p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p>
<p>在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。</p>
<p>这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p>
<h2 id="箭头函数没有自己的-“this”"><a href="#箭头函数没有自己的-“this”" class="headerlink" title="箭头函数没有自己的 “this”"></a>箭头函数没有自己的 “this”</h2><p>箭头函数有些特别：它们没有自己的 <code>this</code>。如果我们在这样的函数中引用 <code>this</code>，<code>this</code> 值取决于外部“正常的”函数。</p>
<p>举个例子，这里的 <code>arrow()</code> 使用的 <code>this</code> 来自于外部的 <code>user.sayHi()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Ilya&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">firstName</span>);</span><br><span class="line">    <span class="title function_">arrow</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.<span class="title function_">sayHi</span>(); <span class="comment">// Ilya</span></span><br></pre></td></tr></table></figure>

<p>这是箭头函数的一个特性，当我们并不想要一个独立的 <code>this</code>，反而想从外部上下文中获取时，它很有用。在后面的 <a target="_blank" rel="noopener" href="https://zh.javascript.info/arrow-functions">深入理解箭头函数</a> 一章中，我们将深入介绍箭头函数。</p>
<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><ul>
<li>存储在对象属性中的函数被称为“方法”。</li>
<li>方法允许对象进行像 <code>object.doSomething()</code> 这样的“操作”。</li>
<li>方法可以将对象引用为 <code>this</code>。</li>
</ul>
<p><code>this</code> 的值是在程序运行时得到的。</p>
<ul>
<li>一个函数在声明时，可能就使用了 <code>this</code>，但是这个 <code>this</code> 只有在函数被调用时才会有值。</li>
<li>可以方便在对象之间复制函数。</li>
<li>以“方法”的语法调用函数时：<code>object.method()</code>，调用过程中的 <code>this</code> 值是 <code>object</code>。</li>
</ul>
<p>请注意箭头函数有些特别：它们没有 <code>this</code>。在箭头函数内部访问到的 <code>this</code> 都是从外部获取的。</p>
<hr>
<h1 id="构造器和操作符-“new”"><a href="#构造器和操作符-“new”" class="headerlink" title="构造器和操作符 “new”"></a>构造器和操作符 “new”</h1><p>常规的 <code>&#123;...&#125;</code> 语法允许创建一个对象。但是我们经常需要创建很多类似的对象，例如多个用户或菜单项等。</p>
<p>这可以使用构造函数和 <code>&quot;new&quot;</code> 操作符来实现。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数在技术上是常规函数。不过有两个约定：</p>
<ol>
<li>它们的命名以大写字母开头。</li>
<li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">name</span>); <span class="comment">// Jack</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">isAdmin</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>
<ol>
<li>一个新的空对象被创建并分配给 <code>this</code>。</li>
<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>
<li>返回 <code>this</code> 的值。</li>
</ol>
<p>换句话说，<code>new User(...)</code> 做的就是类似的事情：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// this = &#123;&#125;;（隐式创建）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加属性到 this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return this;（隐式返回）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="attr">isAdmin</span>: <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p>
<p>这是<strong>构造器的主要目的 —— 实现可重用的对象创建代码</strong>。</p>
<p>让我们再强调一遍 —— 从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>
<p><strong>new function() { … }</strong></p>
<p>如果我们有许多行用于创建单个复杂对象的代码，我们可以将它们封装在一个立即调用的构造函数中，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个函数并立即使用 new 调用它</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">isAdmin</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ……用于用户创建的其他代码</span></span><br><span class="line">  <span class="comment">// 也许是复杂的逻辑和语句</span></span><br><span class="line">  <span class="comment">// 局部变量等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个构造函数不能被再次调用，因为它不保存在任何地方，只是被创建和调用。因此，这个技巧旨在封装构建单个对象的代码，而无需将来重用。</p>
<h2 id="构造器模式测试：new-target-（选学）"><a href="#构造器模式测试：new-target-（选学）" class="headerlink" title="构造器模式测试：new.target （选学）"></a>构造器模式测试：new.target （选学）</h2><p><strong>进阶内容</strong></p>
<p><strong>本节涉及的语法内容很少使用</strong>，除非你想了解所有内容，否则你可以直接跳过该语法。</p>
<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了。</p>
<p>对于常规调用，它为 undefined，对于使用 <code>new</code> 的调用，则等于该函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带 &quot;new&quot;：</span></span><br><span class="line"><span class="title class_">User</span>(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带 &quot;new&quot;：</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">User</span>(); <span class="comment">// function User &#123; ... &#125;</span></span><br></pre></td></tr></table></figure>

<p>它可以被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p>
<p>我们也可以让 <code>new</code> 调用和常规调用做相同的工作，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">new</span>.<span class="property">target</span>) &#123; <span class="comment">// 如果你没有通过 new 运行我</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(name); <span class="comment">// ……我会给你添加 new</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>); <span class="comment">// 将调用重定向到新用户</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(john.<span class="property">name</span>); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 <code>new</code>，程序都能工作。</p>
<p>不过，到处都使用它并不是一件好事，因为省略了 <code>new</code> 使得很难观察到代码中正在发生什么。而通过 <code>new</code> 我们都可以知道这创建了一个新对象。</p>
<h2 id="构造器的-return"><a href="#构造器的-return" class="headerlink" title="构造器的 return"></a>构造器的 return</h2><p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>
<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>
<ul>
<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>
<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>
</ul>
<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p>
<p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">BigUser</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&quot;Godzilla&quot;</span> &#125;;  <span class="comment">// &lt;-- 返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">new</span> <span class="title class_">BigUser</span>().<span class="property">name</span> );  <span class="comment">// Godzilla，得到了那个对象</span></span><br></pre></td></tr></table></figure>

<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SmallUser</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>; <span class="comment">// &lt;-- 返回 this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="keyword">new</span> <span class="title class_">SmallUser</span>().<span class="property">name</span> );  <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p>
<p><strong>省略括号</strong></p>
<p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>; <span class="comment">// &lt;-- 没有参数</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> user = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br></pre></td></tr></table></figure>

<p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p>
<h2 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a>构造器中的方法</h2><p>使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。</p>
<p>当然，我们不仅可以将属性添加到 <code>this</code> 中，还可以添加方法。</p>
<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="string">&quot;My name is: &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">john.<span class="title function_">sayHi</span>(); <span class="comment">// My name is: John</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">john = &#123;</span></span><br><span class="line"><span class="comment">   name: &quot;John&quot;,</span></span><br><span class="line"><span class="comment">   sayHi: function() &#123; ... &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zh.javascript.info/classes">类</a> 是用于创建复杂对象的一个更高级的语法，我们稍后会讲到。</p>
<h2 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>构造函数，或简称构造器，就是常规函数，但大家对于构造器有个共同的约定，就是其命名首字母要大写。</li>
<li>构造函数只能使用 <code>new</code> 来调用。这样的调用意味着在开始时创建了空的 <code>this</code>，并在最后返回填充了值的 <code>this</code>。</li>
</ul>
<p>我们可以使用构造函数来创建多个类似的对象。</p>
<p>JavaScript 为许多内建的对象提供了构造函数：比如日期 <code>Date</code>、集合 <code>Set</code> 以及其他我们计划学习的内容。</p>
<p><strong>对象，我们还会回来哒！</strong></p>
<p>在本章中，我们只介绍了关于对象和构造器的基础知识。它们对于我们在下一章中，学习更多关于数据类型和函数的相关知识非常重要。</p>
<p>在我们学习了那些之后，我们将回到对象，在 <a target="_blank" rel="noopener" href="https://zh.javascript.info/prototypes">原型，继承</a> 和 <a target="_blank" rel="noopener" href="https://zh.javascript.info/classes">类</a> 章节中深入介绍它们。</p>
<hr>
<h1 id="可选链-“-”"><a href="#可选链-“-”" class="headerlink" title="可选链 “?.”"></a>可选链 “?.”</h1><p>这是一个最近添加到 JavaScript 的特性。 旧式浏览器可能需要 polyfills.<br>可选链 <code>?.</code> 是一种访问嵌套对象属性的安全的方式。即使中间的属性不存在，也不会出现错误。</p>
<h2 id="“不存在的属性”的问题"><a href="#“不存在的属性”的问题" class="headerlink" title="“不存在的属性”的问题"></a>“不存在的属性”的问题</h2><p>如果你才刚开始读此教程并学习 JavaScript，那可能还没接触到这个问题，但它却相当常见。</p>
<p>举个例子，假设我们有很多个 <code>user</code> 对象，其中存储了我们的用户数据。</p>
<p>我们大多数用户的地址都存储在 <code>user.address</code> 中，街道地址存储在 <code>user.address.street</code> 中，但有些用户没有提供这些信息。</p>
<p>在这种情况下，当我们尝试获取 <code>user.address.street</code>，而该用户恰好没提供地址信息，我们则会收到一个错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// 一个没有 &quot;address&quot; 属性的 user 对象</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span>.<span class="property">street</span>); <span class="comment">// Error!</span></span><br></pre></td></tr></table></figure>
<p>这是预期的结果。JavaScript 的工作原理就是这样的。因为 <code>user.address</code> 为 <code>undefined</code>，尝试读取 <code>user.address.street</code> 会失败，并收到一个错误。</p>
<p>但是在很多实际场景中，我们更希望得到的是 <code>undefined</code>（表示没有 <code>street</code> 属性）而不是一个错误。</p>
<p>……还有另一个例子。在 Web 开发中，我们可以使用特殊的方法调用（例如 <code>document.querySelector(&#39;.elem&#39;)）</code>以对象的形式获取一个网页元素，如果没有这种对象，则返回 <code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则这里不存在这个元素</span></span><br><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>).<span class="property">innerHTML</span>; </span><br><span class="line"><span class="comment">// 如果 document.querySelector(&#x27;.elem&#x27;) 的结果为 null，则会出现错误</span></span><br></pre></td></tr></table></figure>
<p>同样，如果该元素不存在，则访问 <code>null</code> 的 <code>.innerHTML</code> 属性时会报错。在某些情况下，当元素的缺失是没问题的时候，我们希望避免出现这种错误，而是接受 <code>html = null</code> 作为结果。</p>
<p>我们如何实现这一点呢？</p>
<p>可能最先想到的方案是在访问该值的属性之前，使用 <code>if</code> 或条件运算符 <code>?</code> 对该值进行检查，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> : <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>这样可以，这里就不会出现错误了……但是不够优雅。就像你所看到的，<code>&quot;user.address&quot;</code> 在代码中出现了两次。</p>
<p>我们看一个以相同方式获取 <code>document.querySelector</code> 的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>) ? <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>).<span class="property">innerHTML</span> : <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看到用于进行元素搜索的 <code>document.querySelector(&#39;.elem&#39;)</code> 在这里实际上被调用了两次。这样不优雅。</p>
<p>对于嵌套层次更深的属性，代码会变得更丑，因为需要更多的重复。</p>
<p>例如，让我们以相同的方式尝试获取 <code>user.address.street.name</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user.<span class="property">address</span> ? user.<span class="property">address</span>.<span class="property">street</span> ? user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span> : <span class="literal">null</span> : <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<p>这样就太扯淡了，并且这可能导致写出来的代码很难让别人理解。</p>
<p>这里有一种更好的实现方式，就是使用 <code>&amp;&amp;</code> 运算符：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user.<span class="property">address</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span> &amp;&amp; user.<span class="property">address</span>.<span class="property">street</span>.<span class="property">name</span> ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<p>依次对整条路径上的属性使用与运算进行判断，以确保所有节点是存在的（如果不存在，则停止计算），但仍然不够优雅。</p>
<p>就像你所看到的，在代码中我们仍然重复写了好几遍对象属性名。例如在上面的代码中，<code>user.address</code> 被重复写了三遍。</p>
<p>这就是为什么可选链 <code>?.</code> 被加入到了 <code>JavaScript</code> 这门编程语言中。那就是彻底地解决以上所有问题！</p>
<h2 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h2><p>如果可选链 <code>?.</code> 前面的值为 <code>undefined</code> 或者 <code>null</code>，它会停止运算并返回 <code>undefined</code>。</p>
<p>为了简明起见，在本文接下来的内容中，我们会说如果一个属性既不是 <code>null</code> 也不是 <code>undefined</code>，那么它就“存在”。</p>
<p>换句话说，例如 <code>value?.prop：</code></p>
<p>如果 <code>value</code> 存在，则结果与 <code>value.prop</code> 相同，<br>否则（当 <code>value</code> 为 <code>undefined</code> 或 <code>null</code> 时）则返回结果 <code>undefined</code>。<br>下面这是一种使用 <code>?.</code> 安全地访问 <code>user.address.street</code> 的方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123;&#125;; <span class="comment">// user 没有 address 属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span>?.<span class="property">street</span> ); <span class="comment">// undefined（不报错）</span></span><br></pre></td></tr></table></figure>
<p>代码简洁明了，也不用重复写好几遍属性名。</p>
<p>这里是一个结合 <code>document.querySelector</code> 使用的示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> html = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.elem&#x27;</span>)?.<span class="property">innerHTML</span>; </span><br><span class="line"><span class="comment">// 如果没有符合的元素，则为 undefined</span></span><br></pre></td></tr></table></figure>
<p>即使 对象 <code>user</code> 不存在，使用 <code>user?.address</code> 来读取地址也没问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span> ); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user?.<span class="property">address</span>.<span class="property">street</span> ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>请注意：?. 语法使其前面的值成为可选值，但不会对其后面的起作用。</p>
<p>例如，在 <code>user?.address.street.name</code> 中，<code>?.</code> 允许 <code>user</code> 为 <code>null/undefined</code>（在这种情况下会返回 <code>undefined</code>）也不会报错，但这仅对于 <code>user</code>。更深层次的属性是通过常规方式访问的。如果我们希望它们中的一些也是可选的，那么我们需要使用更多的 <code>?.</code> 来替换 .。</p>
<h2 id="不要过度使用可选链"><a href="#不要过度使用可选链" class="headerlink" title="不要过度使用可选链"></a>不要过度使用可选链</h2><p>我们应该只将 <code>?.</code> 使用在一些东西可以不存在的地方。</p>
<p>例如，如果根据我们的代码逻辑，<code>user</code> 对象必须存在，但 <code>address</code> 是可选的，那么我们应该这样写 <code>user.address?.street</code>，而不是这样 <code>user?.address?.street</code>。</p>
<p>那么，如果 <code>user</code> 恰巧为 <code>undefined</code>，我们会看到一个编程错误并修复它。否则，如果我们滥用 <code>?.</code>，会导致代码中的错误在不应该被消除的地方消除了，这会导致调试更加困难。</p>
<p><strong>?. 前的变量必须已声明</strong><br>如果未声明变量 <code>user</code>，那么 <code>user?.anything</code> 会触发一个错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReferenceError: user is not defined</span></span><br><span class="line">user?.<span class="property">address</span>;</span><br></pre></td></tr></table></figure>
<p><code>?.</code> 前的变量必须已声明（例如 <code>let/const/var user</code> 或作为一个函数参数）。可选链仅适用于已声明的变量。</p>
<h2 id="短路效应"><a href="#短路效应" class="headerlink" title="短路效应"></a>短路效应</h2><p>正如前面所说的，如果 <code>?.</code> 左边部分不存在，就会立即停止运算（“短路效应”）。</p>
<p>因此，如果在 <code>?.</code> 的右侧有任何进一步的函数调用或操作，它们均不会执行。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">user?.<span class="title function_">sayHi</span>(x++); <span class="comment">// 没有 &quot;user&quot;，因此代码执行没有到达 sayHi 调用和 x++</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 0，值没有增加</span></span><br></pre></td></tr></table></figure>
<p>其它变体：<code>?.()</code>，<code>?.[]</code><br>可选链 <code>?.</code> 不是一个运算符，而是一个特殊的语法结构。它还可以与函数和方括号一起使用。</p>
<p>例如，将 <code>?.()</code> 用于调用一个可能不存在的函数。</p>
<p>在下面这段代码中，有些用户具有 <code>admin</code> 方法，而有些没有：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userAdmin = &#123;</span><br><span class="line">  <span class="title function_">admin</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;I am admin&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> userGuest = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">userAdmin.<span class="property">admin</span>?.(); <span class="comment">// I am admin</span></span><br><span class="line"></span><br><span class="line">userGuest.<span class="property">admin</span>?.(); <span class="comment">// 啥都没发生（没有这样的方法）</span></span><br></pre></td></tr></table></figure>
<p>在这两行代码中，我们首先使用点符号<code>（userAdmin.admin）</code>来获取 <code>admin</code> 属性，因为我们假定对象 <code>userAdmin</code> 存在，因此可以安全地读取它。</p>
<p>然后 <code>?.()</code> 会检查它左边的部分：如果 <code>admin</code> 函数存在，那么就调用运行它（对于 <code>userAdmin）</code>。否则（对于 <code>userGuest）</code> 运算停止，没有报错。</p>
<p>如果我们想使用方括号 <code>[]</code> 而不是点符号 <code>.</code> 来访问属性，语法 <code>?.[]</code> 也可以使用。跟前面的例子类似，它允许从一个可能不存在的对象上安全地读取属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;firstName&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user1 = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user1?.[key] ); <span class="comment">// John</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user2?.[key] ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>此外，我们还可以将 <code>?.</code> 跟 <code>delete</code> 一起使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> user?.<span class="property">name</span>; <span class="comment">// 如果 user 存在，则删除 user.name</span></span><br></pre></td></tr></table></figure>
<p>我们可以使用 <code>?.</code> 来安全地读取或删除，但不能写入<br>可选链 <code>?.</code> 不能用在赋值语句的左侧。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">user?.<span class="property">name</span> = <span class="string">&quot;John&quot;</span>; <span class="comment">// Error，不起作用</span></span><br><span class="line"><span class="comment">// 因为它在计算的是：undefined = &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h2><p>可选链 <code>?.</code> 语法有三种形式：</p>
<p><code>obj?.prop</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.prop</code>，否则返回 <code>undefined</code>。<br><code>obj?.[prop]</code> —— 如果 <code>obj</code> 存在则返回 <code>obj.[prop]</code>，否则返回 <code>undefined</code>。<br><code>obj.method?.()</code> —— 如果 <code>obj.method</code> 存在则调用 <code>obj.method()</code>，否则返回 <code>undefined</code>。<br>正如我们所看到的，这些语法形式用起来都很简单直接。<code>?.</code> 检查左边部分是否为 <code>null/undefined</code>，如果不是则继续运算。</p>
<p><code>?.</code> 链使我们能够安全地访问嵌套属性。</p>
<p>但是，我们应该谨慎地使用 <code>?.</code>，根据我们的代码逻辑，仅在当左侧部分不存在也可接受的情况下使用为宜。以保证在代码中有编程上的错误出现时，也不会对我们隐藏。</p>
<hr>
<h1 id="symbol-类型"><a href="#symbol-类型" class="headerlink" title="symbol 类型"></a>symbol 类型</h1><p>【不常用】可以等基础知识学完再来学习。</p>
<p>根据规范，只有两种原始类型可以用作对象属性键：</p>
<ul>
<li>字符串类型</li>
<li>symbol 类型</li>
</ul>
<p>否则，如果使用另一种类型，例如数字，它会被自动转换为字符串， <code>obj[1]</code> 与 <code>obj[&quot;1&quot;]</code> 相同，而 <code>obj[true]</code> 与 <code>obj[&quot;true&quot;]</code> 相同。</p>
<p>到目前为止，我们一直只使用字符串。</p>
<p>现在我们来看看 <code>symbol</code> 能给我们带来什么。</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h2><p><code>“symbol”</code> 值表示唯一的标识符。</p>
<p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>();</span><br></pre></td></tr></table></figure>
<p>创建时，我们可以给 <code>symbol</code> 一个描述（也称为 symbol 名），这在代码调试时非常有用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// id 是描述为 &quot;id&quot; 的 symbol</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>symbol</code> 保证是唯一的。即使我们创建了许多具有相同描述的 <code>symbol</code>，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>
<p>例如，这里有两个描述相同的 <code>symbol</code> —— 它们不相等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id1 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> id2 = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id1 == id2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果你熟悉 <code>Ruby</code> 或者其他有 <code>“symbol”</code> 的语言 —— 别被误导。JavaScript 的 symbol 是不同的。</p>
<p>所以，总而言之，symbol 是带有可选描述的“原始唯一值”。让我们看看我们可以在哪里使用它们。</p>
<p><strong>symbol 不会被自动转换为字符串</strong><br>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 console.log 任何值，都可以生效。symbol 比较特殊，它不会被自动转换。</p>
<p>例如，这个 console.log 将会提示出错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id); <span class="comment">// 类型错误：无法将 symbol 值转换为字符串。</span></span><br></pre></td></tr></table></figure>
<p>这是一种防止混乱的“语言保护”，因为字符串和 symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p>
<p>如果我们真的想显示一个 <code>symbol</code>，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="title function_">toString</span>()); <span class="comment">// Symbol(id)，现在它有效了</span></span><br></pre></td></tr></table></figure>
<p>或者获取 <code>symbol.description</code> 属性，只显示描述<code>（description）</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(id.<span class="property">description</span>); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>

<h2 id="“隐藏”属性"><a href="#“隐藏”属性" class="headerlink" title="“隐藏”属性"></a>“隐藏”属性</h2><p><code>symbol</code> 允许我们创建对象的“隐藏”属性，代码的任何其他部分都不能意外访问或重写这些属性。</p>
<p>例如，如果我们使用的是属于第三方代码的 <code>user</code> 对象，我们想要给它们添加一些标识符。</p>
<p>我们可以给它们使用 <code>symbol</code> 键：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="comment">// 属于另一个代码</span></span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( user[id] ); <span class="comment">// 我们可以使用 symbol 作为键来访问数据</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>Symbol(&quot;id&quot;)</code> 作为键，比起用字符串 <code>&quot;id&quot;</code> 来有什么好处呢？</p>
<p>由于 <code>user</code> 对象属于另一个代码库，所以向它们添加字段是不安全的，因为我们可能会影响代码库中的其他预定义行为。但 <code>symbol</code> 属性不会被意外访问到。第三方代码不会知道新定义的 <code>symbol</code>，因此将 <code>symbol</code> 添加到 <code>user</code> 对象是安全的。</p>
<p>另外，假设另一个脚本希望在 <code>user</code> 中有自己的标识符，以实现自己的目的。</p>
<p>那么，该脚本可以创建自己的 <code>Symbol(&quot;id&quot;)</code>，像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">user[id] = <span class="string">&quot;Their id value&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>我们的标识符和它们的标识符之间不会有冲突，因为 <code>symbol</code> 总是不同的，即使它们有相同的名字。</p>
<p>……但如果我们处于同样的目的，使用字符串 <code>&quot;id&quot;</code> 而不是用 <code>symbol</code>，那么 就会 出现冲突：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们的脚本使用了 &quot;id&quot; 属性。</span></span><br><span class="line">user.<span class="property">id</span> = <span class="string">&quot;Our id value&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ……另一个脚本也想将 &quot;id&quot; 用于它的目的……</span></span><br><span class="line"></span><br><span class="line">user.<span class="property">id</span> = <span class="string">&quot;Their id value&quot;</span></span><br><span class="line"><span class="comment">// 砰！无意中被另一个脚本重写了 id！</span></span><br></pre></td></tr></table></figure>
<p>对象字面量中的 <code>symbol</code><br>如果我们要在对象字面量 {…} 中使用 <code>symbol</code>，则需要使用方括号把它括起来。</p>
<p>就像这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  [id]: <span class="number">123</span> <span class="comment">// 而不是 &quot;id&quot;：123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这是因为我们需要变量 <code>id</code> 的值作为键，而不是字符串 <code>“id”</code>。</p>
<p><code>symbol</code> 在 <code>for…in</code> 中会被跳过<br><code>symbol</code> 属性不参与 <code>for..in</code> 循环。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">[id]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> user) <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// name, age（没有 symbol）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 symbol 任务直接访问</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Direct: &quot;</span> + user[id]); <span class="comment">// Direct: 123</span></span><br></pre></td></tr></table></figure>
<p><code>Object.keys(user)</code> 也会忽略它们。这是一般“隐藏符号属性”原则的一部分。如果另一个脚本或库遍历我们的对象，它不会意外地访问到符号属性。</p>
<p>相反，<code>Object.assign</code> 会同时复制字符串和 <code>symbol</code> 属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">[id]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, user);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( clone[id] ); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>这里并不矛盾，就是这样设计的。这里的想法是当我们克隆或者合并一个 <code>object</code> 时，通常希望 所有 属性被复制（包括像 <code>id</code> 这样的 <code>symbol</code>）。</p>
<h2 id="全局-symbol"><a href="#全局-symbol" class="headerlink" title="全局 symbol"></a>全局 symbol</h2><p>正如我们所看到的，通常所有的 <code>symbol</code> 都是不同的，即使它们有相同的名字。但有时我们想要名字相同的 <code>symbol</code> 具有相同的实体。例如，应用程序的不同部分想要访问的 <code>symbol &quot;id&quot;</code> 指的是完全相同的属性。</p>
<p>为了实现这一点，这里有一个 全局 <code>symbol</code> 注册表。我们可以在其中创建 <code>symbol</code> 并在稍后访问它们，它可以确保每次访问相同名字的 <code>symbol</code> 时，返回的都是相同的 <code>symbol</code>。</p>
<p>要从注册表中读取（不存在则创建）<code>symbol</code>，请使用 <code>Symbol.for(key)</code>。</p>
<p>该调用会检查全局注册表，如果有一个描述为 <code>key</code> 的 <code>symbol</code>，则返回该 <code>symbol</code>，否则将创建一个新 <code>symbol（Symbol(key)）</code>，并通过给定的 <code>key</code> 将其存储在注册表中。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从全局注册表中读取</span></span><br><span class="line"><span class="keyword">let</span> id = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>); <span class="comment">// 如果该 symbol 不存在，则创建它</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次读取（可能是在代码中的另一个位置）</span></span><br><span class="line"><span class="keyword">let</span> idAgain = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相同的 symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( id === idAgain ); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>注册表内的 <code>symbol</code> 被称为 <code>全局 symbol</code>。如果我们想要一个应用程序范围内的 <code>symbol</code>，可以在代码中随处访问 —— 这就是它们的用途。</p>
<p>这听起来像 Ruby<br>在一些编程语言中，例如 Ruby，每个名字都有一个 symbol。</p>
<p>正如我们所看到的，在 JavaScript 中，全局 symbol 也是这样的。</p>
<p><strong>Symbol.keyFor</strong><br>我们已经看到，对于全局 symbol，<code>Symbol.for(key)</code> 按名字返回一个 symbol。<br>相反，通过全局 symbol 返回一个名字，我们可以使用 Symbol.keyFor(sym)：</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 name 获取 symbol</span></span><br><span class="line"><span class="keyword">let</span> sym = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> sym2 = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 symbol 获取 name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym) ); <span class="comment">// name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(sym2) ); <span class="comment">// id</span></span><br></pre></td></tr></table></figure>
<p>Symbol.keyFor 内部使用全局 symbol 注册表来查找 symbol 的键。所以它不适用于非全局 symbol。如果 symbol 不是全局的，它将无法找到它并返回 undefined。</p>
<p>但是，所有 symbol 都具有 description 属性。</p>
<p>例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> globalSymbol = <span class="title class_">Symbol</span>.<span class="title function_">for</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> localSymbol = <span class="title class_">Symbol</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(globalSymbol) ); <span class="comment">// name，全局 symbol</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( <span class="title class_">Symbol</span>.<span class="title function_">keyFor</span>(localSymbol) ); <span class="comment">// undefined，非全局</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( localSymbol.<span class="property">description</span> ); <span class="comment">// name</span></span><br></pre></td></tr></table></figure>

<h2 id="系统-symbol"><a href="#系统-symbol" class="headerlink" title="系统 symbol"></a>系统 symbol</h2><p>JavaScript 内部有很多“系统” symbol，我们可以使用它们来微调对象的各个方面。</p>
<p>它们都被列在了 众所周知的 symbol 表的规范中：</p>
<ul>
<li>Symbol.hasInstance</li>
<li>Symbol.isConcatSpreadable</li>
<li>Symbol.iterator</li>
<li>Symbol.toPrimitive<br>……等等。<br>例如，Symbol.toPrimitive 允许我们将对象描述为原始值转换。我们很快就会看到它的使用。</li>
</ul>
<p>当我们研究相应的语言特征时，我们对其他的 symbol 也会慢慢熟悉起来。</p>
<h2 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h2><p>symbol 是唯一标识符的基本类型</p>
<p>symbol 是使用带有可选描述（name）的 Symbol() 调用创建的。</p>
<p>symbol 总是不同的值，即使它们有相同的名字。如果我们希望同名的 symbol 相等，那么我们应该使用全局注册表：Symbol.for(key) 返回（如果需要的话则创建）一个以 key 作为名字的全局 symbol。使用 Symbol.for 多次调用 key 相同的 symbol 时，返回的就是同一个 symbol。</p>
<p>symbol 有两个主要的使用场景：</p>
<p> “隐藏” 对象属性。</p>
<p>如果我们想要向“属于”另一个脚本或者库的对象添加一个属性，我们可以创建一个 symbol 并使用它作为属性的键。symbol 属性不会出现在 for..in 中，因此它不会意外地被与其他属性一起处理。并且，它不会被直接访问，因为另一个脚本没有我们的 symbol。因此，该属性将受到保护，防止被意外使用或重写。</p>
<p>因此我们可以使用 symbol 属性“秘密地”将一些东西隐藏到我们需要的对象中，但其他地方看不到它。</p>
<p>JavaScript 使用了许多系统 symbol，这些 symbol 可以作为 Symbol.* 访问。我们可以使用它们来改变一些内建行为。例如，在本教程的后面部分，我们将使用 Symbol.iterator 来进行 迭代 操作，使用 Symbol.toPrimitive 来设置 对象原始值的转换 等等。</p>
<p>从技术上说，symbol 不是 100% 隐藏的。有一个内建方法 Object.getOwnPropertySymbols(obj) 允许我们获取所有的 symbol。还有一个名为 Reflect.ownKeys(obj) 的方法可以返回一个对象的 所有 键，包括 symbol。但大多数库、内建方法和语法结构都没有使用这些方法。</p>
<hr>
<h1 id="对象-——-原始值转换"><a href="#对象-——-原始值转换" class="headerlink" title="对象 —— 原始值转换"></a>对象 —— 原始值转换</h1><p>当对象相加 obj1 + obj2，相减 obj1 - obj2，或者使用 alert(obj) 打印时会发生什么？</p>
<p>JavaScript 不允许自定义运算符对对象的处理方式。与其他一些编程语言（Ruby，C++）不同，我们无法实现特殊的对象处理方法来处理加法（或其他运算）。</p>
<p>在此类运算的情况下，对象会被自动转换为原始值，然后对这些原始值进行运算，并得到运算结果（也是一个原始值）。</p>
<p>这是一个重要的限制：因为 obj1 + obj2（或者其他数学运算）的结果不能是另一个对象！</p>
<p>例如，我们无法使用对象来表示向量或矩阵，把它们相加并期望得到一个“总和”向量作为结果。这样的想法是行不通的。</p>
<p>因此，由于我们从技术上无法实现此类运算，所以在实际项目中不存在对对象的数学运算。如果你发现有，除了极少数例外，通常是写错了。</p>
<p>本文将介绍对象是如何转换为原始值的，以及如何对其进行自定义。</p>
<p>我们有两个目的：</p>
<p>让我们在遇到类似的对对象进行数学运算的编程错误时，能够更加理解到底发生了什么。<br>也有例外，这些操作也可以是可行的。例如日期相减或比较（Date 对象）。我们稍后会遇到它们。</p>
<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><p>在 类型转换 一章中，我们已经看到了数字、字符串和布尔转换的规则。但是我们没有讲对象的转换规则。现在我们已经掌握了方法（method）和 symbol 的相关知识，可以开始学习对象原始值转换了。</p>
<p>没有转换为布尔值。所有的对象在布尔上下文（context）中均为 true，就这么简单。只有字符串和数字转换。<br>数字转换发生在对象相减或应用数学函数时。例如，Date 对象（将在 日期和时间 一章中介绍）可以相减，date1 - date2 的结果是两个日期之间的差值。<br>至于字符串转换 —— 通常发生在我们像 alert(obj) 这样输出一个对象和类似的上下文中。<br>我们可以使用特殊的对象方法，自己实现字符串和数字的转换。</p>
<p>现在让我们一起探究技术细节，因为这是深入讨论该主题的唯一方式。</p>
<h2 id="hint"><a href="#hint" class="headerlink" title="hint"></a>hint</h2><p>JavaScript 是如何决定应用哪种转换的？</p>
<p>类型转换在各种情况下有三种变体。它们被称为 “hint”，在 规范 所述：</p>
<p>“string”<br>对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 “alert”：</p>
<p>&#x2F;&#x2F; 输出<br>alert(obj);</p>
<p>&#x2F;&#x2F; 将对象作为属性键<br>anotherObj[obj] &#x3D; 123;<br>“number”<br>对象到数字的转换，例如当我们进行数学运算时：</p>
<p>&#x2F;&#x2F; 显式转换<br>let num &#x3D; Number(obj);</p>
<p>&#x2F;&#x2F; 数学运算（除了二元加法）<br>let n &#x3D; +obj; &#x2F;&#x2F; 一元加法<br>let delta &#x3D; date1 - date2;</p>
<p>&#x2F;&#x2F; 小于&#x2F;大于的比较<br>let greater &#x3D; user1 &gt; user2;<br>大多数内建的数学函数也包括这种转换。</p>
<p>“default”<br>在少数情况下发生，当运算符“不确定”期望值的类型时。</p>
<p>例如，二元加法 + 可用于字符串（连接），也可以用于数字（相加）。因此，当二元加法得到对象类型的参数时，它将依据 “default” hint 来对其进行转换。</p>
<p>此外，如果对象被用于与字符串、数字或 symbol 进行 &#x3D;&#x3D; 比较，这时到底应该进行哪种转换也不是很明确，因此使用 “default” hint。</p>
<p>&#x2F;&#x2F; 二元加法使用默认 hint<br>let total &#x3D; obj1 + obj2;</p>
<p>&#x2F;&#x2F; obj &#x3D;&#x3D; number 使用默认 hint<br>if (user &#x3D;&#x3D; 1) { … };<br>像 &lt; 和 &gt; 这样的小于&#x2F;大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint，而不是 “default”。这是历史原因。</p>
<p>上面这些规则看起来比较复杂，但在实践中其实挺简单的。</p>
<p>除了一种情况（Date 对象，我们稍后会讲到）之外，所有内建对象都以和 “number” 相同的方式实现 “default” 转换。我们也可以这样做。</p>
<p>尽管如此，了解上述的 3 个 hint 还是很重要的，很快你就会明白为什么这样说。</p>
<p>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</p>
<p>调用 obj<a href="hint">Symbol.toPrimitive</a> —— 带有 symbol 键 Symbol.toPrimitive（系统 symbol）的方法，如果这个方法存在的话，<br>否则，如果 hint 是 “string” —— 尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。<br>否则，如果 hint 是 “number” 或 “default” —— 尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。</p>
<h2 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h2><p>我们从第一个方法开始。有一个名为 Symbol.toPrimitive 的内建 symbol，它被用来给转换方法命名，像这样：</p>
<p>obj[Symbol.toPrimitive] &#x3D; function(hint) {<br>  &#x2F;&#x2F; 这里是将此对象转换为原始值的代码<br>  &#x2F;&#x2F; 它必须返回一个原始值<br>  &#x2F;&#x2F; hint &#x3D; “string”、”number” 或 “default” 中的一个<br>}<br>如果 Symbol.toPrimitive 方法存在，则它会被用于所有 hint，无需更多其他方法。</p>
<p>例如，这里 user 对象实现了它：</p>
<p>let user &#x3D; {<br>  name: “John”,<br>  money: 1000,</p>
<p>  <a href="hint">Symbol.toPrimitive</a> {<br>    alert(<code>hint: $&#123;hint&#125;</code>);<br>    return hint &#x3D;&#x3D; “string” ? <code>&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;</code> : this.money;<br>  }<br>};</p>
<p>&#x2F;&#x2F; 转换演示：<br>alert(user); &#x2F;&#x2F; hint: string -&gt; {name: “John”}<br>alert(+user); &#x2F;&#x2F; hint: number -&gt; 1000<br>alert(user + 500); &#x2F;&#x2F; hint: default -&gt; 1500<br>从代码中我们可以看到，根据转换的不同，user 变成一个自描述字符串或者一个金额。user[Symbol.toPrimitive] 方法处理了所有的转换情况。</p>
<h2 id="toString-valueOf"><a href="#toString-valueOf" class="headerlink" title="toString&#x2F;valueOf"></a>toString&#x2F;valueOf</h2><p>如果没有 Symbol.toPrimitive，那么 JavaScript 将尝试寻找 toString 和 valueOf 方法：</p>
<p>对于 “string” hint：调用 toString 方法，如果它不存在，则调用 valueOf 方法（因此，对于字符串转换，优先调用 toString）。<br>对于其他 hint：调用 valueOf 方法，如果它不存在，则调用 toString 方法（因此，对于数学运算，优先调用 valueOf 方法）。<br>toString 和 valueOf 方法很早己有了。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。</p>
<p>这些方法必须返回一个原始值。如果 toString 或 valueOf 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。</p>
<p>默认情况下，普通对象具有 toString 和 valueOf 方法：</p>
<p>toString 方法返回一个字符串 “[object Object]”。<br>valueOf 方法返回对象自身。<br>下面是一个示例：</p>
<p>let user &#x3D; {name: “John”};</p>
<p>alert(user); &#x2F;&#x2F; [object Object]<br>alert(user.valueOf() &#x3D;&#x3D;&#x3D; user); &#x2F;&#x2F; true<br>所以，如果我们尝试将一个对象当做字符串来使用，例如在 alert 中，那么在默认情况下我们会看到 [object Object]。</p>
<p>这里提到的默认的 valueOf 只是为了完整起见，以避免混淆。正如你看到的，它返回对象本身，因此被忽略。别问我为什么，这是历史原因。所以我们可以假设它根本就不存在。</p>
<p>让我们实现一下这些方法来自定义转换。</p>
<p>例如，这里的 user 执行和前面提到的那个 user 一样的操作，使用 toString 和 valueOf 的组合（而不是 Symbol.toPrimitive）：</p>
<p>let user &#x3D; {<br>  name: “John”,<br>  money: 1000,</p>
<p>  &#x2F;&#x2F; 对于 hint&#x3D;”string”<br>  toString() {<br>    return <code>&#123;name: &quot;$&#123;this.name&#125;&quot;&#125;</code>;<br>  },</p>
<p>  &#x2F;&#x2F; 对于 hint&#x3D;”number” 或 “default”<br>  valueOf() {<br>    return this.money;<br>  }</p>
<p>};</p>
<p>alert(user); &#x2F;&#x2F; toString -&gt; {name: “John”}<br>alert(+user); &#x2F;&#x2F; valueOf -&gt; 1000<br>alert(user + 500); &#x2F;&#x2F; valueOf -&gt; 1500<br>我们可以看到，执行的动作和前面使用 Symbol.toPrimitive 的那个例子相同。</p>
<p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 toString，就像这样：</p>
<p>let user &#x3D; {<br>  name: “John”,</p>
<p>  toString() {<br>    return this.name;<br>  }<br>};</p>
<p>alert(user); &#x2F;&#x2F; toString -&gt; John<br>alert(user + 500); &#x2F;&#x2F; toString -&gt; John500<br>如果没有 Symbol.toPrimitive 和 valueOf，toString 将处理所有原始转换。</p>
<p>转换可以返回任何原始类型<br>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>
<p>没有限制 toString() 是否返回字符串，或 Symbol.toPrimitive 方法是否为 “number” hint 返回数字。</p>
<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>
<p>历史原因<br>由于历史原因，如果 toString 或 valueOf 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>
<p>相反，Symbol.toPrimitive 更严格，它 必须 返回一个原始值，否则就会出现 error。</p>
<h2 id="进一步的转换"><a href="#进一步的转换" class="headerlink" title="进一步的转换"></a>进一步的转换</h2><p>我们已经知道，许多运算符和函数执行类型转换，例如乘法 * 将操作数转换为数字。</p>
<p>如果我们将对象作为参数传递，则会出现两个运算阶段：</p>
<p>对象被转换为原始值（通过前面我们描述的规则）。<br>如果还需要进一步计算，则生成的原始值会被进一步转换。<br>例如：</p>
<p>let obj &#x3D; {<br>  &#x2F;&#x2F; toString 在没有其他方法的情况下处理所有转换<br>  toString() {<br>    return “2”;<br>  }<br>};</p>
<p>alert(obj * 2); &#x2F;&#x2F; 4，对象被转换为原始值字符串 “2”，之后它被乘法转换为数字 2。<br>乘法 obj * 2 首先将对象转换为原始值（字符串 “2”）。<br>之后 “2” * 2 变为 2 * 2（字符串被转换为数字）。<br>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p>
<p>let obj &#x3D; {<br>  toString() {<br>    return “2”;<br>  }<br>};</p>
<p>alert(obj + 2); &#x2F;&#x2F; 22（”2” + 2）被转换为原始值字符串 &#x3D;&gt; 级联</p>
<h2 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h2><p>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。</p>
<p>这里有三种类型（hint）：</p>
<p>“string”（对于 alert 和其他需要字符串的操作）<br>“number”（对于数学运算）<br>“default”（少数运算符，通常对象以和 “number” 相同的方式实现 “default” 转换）<br>规范明确描述了哪个运算符使用哪个 hint。</p>
<p>转换算法是：</p>
<p>调用 obj<a href="hint">Symbol.toPrimitive</a> 如果这个方法存在，<br>否则，如果 hint 是 “string”<br>尝试调用 obj.toString() 或 obj.valueOf()，无论哪个存在。<br>否则，如果 hint 是 “number” 或者 “default”<br>尝试调用 obj.valueOf() 或 obj.toString()，无论哪个存在。<br>所有这些方法都必须返回一个原始值才能工作（如果已定义）。</p>
<p>在实际使用中，通常只实现 obj.toString() 作为字符串转换的“全能”方法就足够了，该方法应该返回对象的“人类可读”表示，用于日志记录或调试。</p>
<hr>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>点我对博主进行赞赏——最真诚的认可🍻！</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/paymentCode/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/paymentCode/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/images/paymentCode/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/images/paymentCode/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/note/software-use/Trpora.html" title="Trpora的使用说明"><img class="cover" src="https://typoraio.cn/img/favicon-128.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Trpora的使用说明</div></div></a></div><div class="next-post pull-right"><a href="/blog/liferecord/Dare-to-ask-where-the-road-is.html" title="敢问路在何方（伴奏视频分享）"><img class="cover" src="https://puui.qpic.cn/vpic_cover/a0977oxi7h2/a0977oxi7h2_hz.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">敢问路在何方（伴奏视频分享）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/note/code/JavaScript3.html" title="JavaScript学习笔记（3）数据类型-进阶"><img class="cover" src="https://emaillistvalidation.com/blog/content/images/2023/09/JavaScript-Symbol.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-11-08</div><div class="title">JavaScript学习笔记（3）数据类型-进阶</div></div></a></div><div><a href="/blog/note/code/JavaScript1.html" title="JavaScript学习笔记（1）基础知识"><img class="cover" src="https://emaillistvalidation.com/blog/content/images/2023/09/JavaScript-Symbol.png" alt="cover"><div class="content is-center"><div class="date"><i class="fas fa-history fa-fw"></i> 2024-11-08</div><div class="title">JavaScript学习笔记（1）基础知识</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://puui.qpic.cn/vpic_cover/l3165317c7s/l3165317c7s_hz.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Yuan</div><div class="author-info__description">日拱一卒，不期而至</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" href="mailto:ahoucide@qq.com"><i class="fab fa fa-envelope"></i><span>联系我</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">文本和属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.2.</span> <span class="toc-text">方括号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%80%BC%E7%AE%80%E5%86%99"><span class="toc-number">1.3.</span> <span class="toc-text">属性值简写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%A7%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">属性名称限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%AD%98%E5%9C%A8%E6%80%A7%E6%B5%8B%E8%AF%95%EF%BC%8C%E2%80%9Cin%E2%80%9D-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">1.5.</span> <span class="toc-text">属性存在性测试，“in” 操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9Cfor-in%E2%80%9D-%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.6.</span> <span class="toc-text">“for..in” 循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%8F%E5%AF%B9%E8%B1%A1%E4%B8%80%E6%A0%B7%E6%8E%92%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">像对象一样排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">对象引用和复制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%95%E7%94%A8%E6%9D%A5%E6%AF%94%E8%BE%83"><span class="toc-number">2.1.</span> <span class="toc-text">通过引用来比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E4%B8%8E%E5%90%88%E5%B9%B6%EF%BC%8CObject-assign"><span class="toc-number">2.2.</span> <span class="toc-text">克隆与合并，Object.assign</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%B1%82%E5%85%8B%E9%9A%86"><span class="toc-number">2.3.</span> <span class="toc-text">深层克隆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%EF%BC%8C%E2%80%9Dthis%E2%80%9D"><span class="toc-number">3.</span> <span class="toc-text">对象方法，”this”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">方法示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%AE%80%E5%86%99"><span class="toc-number">3.1.1.</span> <span class="toc-text">方法简写</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84-%E2%80%9Cthis%E2%80%9D"><span class="toc-number">3.2.</span> <span class="toc-text">方法中的 “this”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9Cthis%E2%80%9D-%E4%B8%8D%E5%8F%97%E9%99%90%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">“this” 不受限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84-%E2%80%9Cthis%E2%80%9D"><span class="toc-number">3.4.</span> <span class="toc-text">箭头函数没有自己的 “this”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6-%E2%80%9Cnew%E2%80%9D"><span class="toc-number">4.</span> <span class="toc-text">构造器和操作符 “new”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F%E6%B5%8B%E8%AF%95%EF%BC%9Anew-target-%EF%BC%88%E9%80%89%E5%AD%A6%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">构造器模式测试：new.target （选学）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%9A%84-return"><span class="toc-number">4.3.</span> <span class="toc-text">构造器的 return</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">构造器中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">4.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE-%E2%80%9C-%E2%80%9D"><span class="toc-number">5.</span> <span class="toc-text">可选链 “?.”</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E2%80%9D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">“不存在的属性”的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-number">5.2.</span> <span class="toc-text">可选链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%80%89%E9%93%BE"><span class="toc-number">5.3.</span> <span class="toc-text">不要过度使用可选链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E8%B7%AF%E6%95%88%E5%BA%94"><span class="toc-number">5.4.</span> <span class="toc-text">短路效应</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#symbol-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">symbol 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#symbol"><span class="toc-number">6.1.</span> <span class="toc-text">symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%80%9C%E9%9A%90%E8%97%8F%E2%80%9D%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.</span> <span class="toc-text">“隐藏”属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80-symbol"><span class="toc-number">6.3.</span> <span class="toc-text">全局 symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F-symbol"><span class="toc-number">6.4.</span> <span class="toc-text">系统 symbol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">6.5.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-%E2%80%94%E2%80%94-%E5%8E%9F%E5%A7%8B%E5%80%BC%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.</span> <span class="toc-text">对象 —— 原始值转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">7.1.</span> <span class="toc-text">转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hint"><span class="toc-number">7.2.</span> <span class="toc-text">hint</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-toPrimitive"><span class="toc-number">7.3.</span> <span class="toc-text">Symbol.toPrimitive</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#toString-valueOf"><span class="toc-number">7.4.</span> <span class="toc-text">toString&#x2F;valueOf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.5.</span> <span class="toc-text">进一步的转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">7.6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined" title="无题">无题</a><time datetime="2024-11-08T09:59:31.769Z" title="发表日期 2024-11-08 09:59:31">2024-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined" title="无题">无题</a><time datetime="2024-11-08T09:59:31.765Z" title="发表日期 2024-11-08 09:59:31">2024-11-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/undefined" title="无题">无题</a><time datetime="2024-11-08T09:59:31.765Z" title="发表日期 2024-11-08 09:59:31">2024-11-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/chemistry/international-chemistry/international-chemistry-study-guide.html" title="国际化学-学习指北"><img src="https://www.cambridge.org/modules/custom/gnav/icons/cup&amp;a-logo-@2x.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="国际化学-学习指北"/></a><div class="content"><a class="title" href="/blog/chemistry/international-chemistry/international-chemistry-study-guide.html" title="国际化学-学习指北">国际化学-学习指北</a><time datetime="2024-11-01T10:55:44.000Z" title="发表日期 2024-11-01 10:55:44">2024-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/note/code/HTTP-axios.html" title="HTTP请求笔记"><img src="https://newsxday.com/wp-content/uploads/2021/03/HTTP-vs-HTTPS-Hypertext-Transfer-Protocol-Full-Form-1-1536x730.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="HTTP请求笔记"/></a><div class="content"><a class="title" href="/blog/note/code/HTTP-axios.html" title="HTTP请求笔记">HTTP请求笔记</a><time datetime="2024-10-30T20:00:59.000Z" title="发表日期 2024-10-30 20:00:59">2024-10-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Yuan</div><div class="framework-info"><span>本博客框架基于 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>本博客使用的主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const getGiscusTheme = theme => {
    return theme === 'dark' ? 'dark' : 'light'
  }

  const loadGiscus = () => {
    const config = Object.assign({
      src: 'https://giscus.app/client.js',
      'data-repo': 'aboucide/hexo-aboucide-comment',
      'data-repo-id': 'R_kgDOM8yVSQ',
      'data-category-id': 'DIC_kwDOM8yVSc4CjJFp',
      'data-mapping': 'pathname',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true
    },null)

    const ele = document.createElement('script')
    for (let key in config) {
      ele.setAttribute(key, config[key])
    }
    document.getElementById('giscus-wrap').appendChild(ele)
  }

  const changeGiscusTheme = theme => {
    const sendMessage = message => {
      const iframe = document.querySelector('iframe.giscus-frame')
      if (!iframe) return
      iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
    }

    sendMessage({
      setConfig: {
        theme: getGiscusTheme(theme)
      }
    });
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment= loadGiscus
  }
})()</script></div><script async data-pjax src="https://cdn.bootcdn.net/ajax/libs/busuanzi/2.3.0/bsz.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>